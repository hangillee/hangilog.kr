<?xml version="1.0" ?>
  <rss
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    version="2.0"
  >
    <channel>
        <title><![CDATA[Hangilog]]></title>
        <link>https://blog.hangilog.kr</link>
        <description>
          <![CDATA[다른 사람을 돕는 개발자를 꿈꿉니다.]]>
        </description>
        <language>en</language>
        <lastBuildDate>2024-04-18</lastBuildDate>
        <item>
    <title><![CDATA[우아한테크코스 레벨1 - 체스]]></title>
    <link>https://blog.hangilog.kr/woowacourse-level1-mission4</link>
    <pubDate>2024-04-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/woowacourse-level1-mission4</guid>
    <description>
    <![CDATA[나의 클린코드를 찾아서]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="체스---oop--db" class="heading">체스 - OOP &#x26; DB</h2>
<p>대망의 레벨 1 마지막 미션, 체스 미션을 마쳤습니다. 살면서 체스를 한 번도 플레이하지 않아서 미션 시작 전에는 걱정이 많았습니다.(블랙잭 미션에서도 그랬지만...) 그래도 체스는 엄청 유명한 보드 게임이다보니 도메인 지식을 쌓는 것은 크게 어렵지 않았습니다. 기물의 움직임, 초기 보드의 상태, 체스의 승리 조건 등을 공부했고, 페어 <a href="https://github.com/dwax1324" target="_blank" rel="noopener noreferer">종이</a>와 함께 구현을 시작했습니다.</p>
<h3 id="1-2단계---체스판-초기화와-말-이동">1, 2단계 - 체스판 초기화와 말 이동</h3>
<p>이번 미션은 앞선 미션들과 다르게 총 4단계로 구성되어 있었습니다. 1, 2단계는 페어와 함께 진행하고 3, 4단계는 각자 진행하면 됐는데, 3, 4단계에 비해 1, 2단계가 훨씬 어려웠습니다. 체스의 대부분이라고 할 수 있는 체스판 세팅과 기물 이동 기능 구현을 1, 2단계에서 모두 끝내야했기 때문입니다. 사실상 페어와 함께 개발하는 3일 동안 거의 모든 기능을 구현해야 했던 것입니다.</p>
<p>그래도 1차 리뷰 요청 마감까지 매일매일 퇴근도 늦춰가면서 열심히 구현했습니다. 중간에 한번 코드를 완전 갈아엎기도 하고 종이와 디자인 패턴 도입을 가지고 열띤 토론을 하기도 했습니다. 장장 1시간에 가까운 토론 끝에 이번 미션에서는 <strong>커맨드 패턴</strong>, <strong>전략 패턴</strong>과 <strong>상태 패턴</strong>을 도입해봤습니다. 특히, 상태 패턴은 여러 도메인에서 활용했습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">package</span> <span class="token namespace">domain<span class="token punctuation">.</span>game<span class="token punctuation">.</span>state</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">State</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token class-name">State</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">boolean</span> <span class="token function">isInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">boolean</span> <span class="token function">isStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">boolean</span> <span class="token function">isEnded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">boolean</span> <span class="token function">isNotEnded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">package</span> <span class="token namespace">domain<span class="token punctuation">.</span>piece<span class="token punctuation">.</span>state</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">domain<span class="token punctuation">.</span>piece<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">Color</span></span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">domain<span class="token punctuation">.</span>piece<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">Direction</span></span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Direction</span><span class="token punctuation">></span></span> <span class="token function">movableDirection</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Color</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<div align="center"><I>상태 패턴을 이용해 체스 게임과 기물의 상태를 추상화</I></div>
<p>이번 미션의 핵심 키워드 중 하나가 OOP였던 만큼, 객체의 역할과 책임을 제대로 부여하려고 꽤 많은 시간을 쏟았습니다. '체스 기물의 움직임은 누구의 책임인가?', '체스 보드가 해야하는가?', '체스 기물이 스스로 해야하는가?'와 같은 질문들 뿐만 아니라 '현재 이기고 있는 플레이어는 누구인가?', '게임의 시작과 종료는 누가 결정하는가?'와 같은 질문들을 끊임없이 던졌습니다.</p>
<p>그러다보니 설계가 너무 복잡해졌고 객체의 역할과 책임은 모호해지기 시작했습니다. 이 문제를 어떻게 해결해야 할지 고민하던 중, 다른 크루들이 디자인 패턴 도입을 고민하고 있는 것을 알게 됐습니다. 저와 페어도 스스로 구조를 고민하기보다 디자인 패턴들을 활용하는 것이 더 효율적으로 코드를 작성할 수 있는 방법이 될 수 있음을 깨달았습니다. 제가 맞닥뜨린 객체 설계에서의 문제들은 이미 디자인 패턴으로 해결된 것들이었습니다.</p>
<p>사실 이전 미션들에서는 디자인 패턴을 적용하는 것이 꺼려졌습니다. 뭔가 디자인 패턴을 적용하면 스스로 생각해낸 해결책이 아니라는 생각에 올바르지 않은 학습법 같았습니다.</p>
<p>그러나, 블랙잭 미션의 리뷰어 현구막의 피드백을 읽고 생각을 바꿨습니다.</p>
<img width="738" alt="design-pattern" src="https://github.com/hangillee/coderoad.kr/assets/14046092/26838e81-98eb-4cba-b70b-2917b7a33b81">
<div align="center"><I>디자인 패턴의 필요성에 대한 현구막의 생각</I></div>
<p>결국 디자인 패턴은 수많은 개발자들의 연구 끝에 탄생한 <strong>Best Practice</strong>라고 볼 수 있습니다. 훌륭한 OOP를 위해 획기적인 객체 설계 아이디어를 떠올리기 보다 이미 널리 알려진 문제의 해결책을 활용하는게 더 낫다는 생각을 하게 됐습니다. 제가 정말 기가 막히게 멋진 코드를 작성했다고 해서 모든 개발자가 그 코드를 한번에 이해하리라는 보장은 없습니다. 차라리 그렇다면 <strong>더 큰 문제를 해결하기 위해 이미 해결된 작은 문제의 해결책들을 활용</strong>하는 것이 다른 개발자에게도 좋고 저도 편할 것입니다.</p>
<p>그래서 커맨드 패턴, 상태 패턴, 전략 패턴을 도입했습니다. 각각 사용자의 명령어 입력에 따른 동작 수행의 책임, 체스 게임과 보드의 상태에 대한 책임, 체스 기물의 이동 방식에 대한 책임을 가집니다. 이렇게 한번 디자인 패턴을 적용해보니 미션 구현이 훨씬 편안해졌습니다.</p>
<p>물론 디자인 패턴을 깊게 학습해보진 못했기 때문에 객체 간의 의존성을 제대로 관리하지 못해서 이번 미션의 리뷰어인 <a href="https://github.com/Hyunta" target="_blank" rel="noopener noreferer">아서</a>에게 여러번 피드백을 받았습니다...</p>
<h3 id="3-4단계---승패-및-점수와-db-적용">3, 4단계 - 승패 및 점수와 DB 적용</h3>
<p>3, 4단계는 1, 2단계에 비하면 정말 쉽게 해결할 수 있었던 것 같습니다. <code>JDBC</code>와 <code>Connection pool</code>에 대해서 학습해야 해서 소요된 시간을 제외하면 훨씬 여유로웠습니다. 실제로, 게임 승패 처리와 점수 계산 로직을 구현하는데는 크게 어려움이 없었습니다. 오히려, <code>JPA</code>나 <code>MyBatis</code>를 사용하지 않고 처음으로 Java와 DB를 연결하다보니 DB쪽 코드에서 이런저런 시행착오가 많았습니다.</p>
<p>특히, DB에 대한 의존성이 생긴 코드들을 테스트하는 것은 처음이라 도무지 방법이 떠오르지 않았습니다. 거기다 어떻게든 작성한 테스트들은 일부는 성공하고 일부는 실패했습니다. 문제의 원인을 찾던 중, 이전 테스트 메소드가 다음 메소드에 영향을 준다는 것을 알게 됐습니다. 즉, 테스트 분리가 제대로 이루어지지 않아서 DB의 상태가 매 테스트에 영향을 준 것입니다.</p>
<p>이것을 해결하기 위해 여러 방법을 모색하다 <code>Fake</code> 객체를 통한 테스트 더블을 활용하기로 했습니다. <code>@Transactional</code>을 사용하거나 DB에 쿼리를 직접 날리는 방법도 있었겠지만 전자는 Spring Framework 없이는 사용할 수 없었고, DB에 쿼리를 날리는 방식은 결국 DB의 종류에 의존해야 한다는 문제가 있었습니다. 저는 DB가 테스트에 필요해진 것 자체가 통합 테스트지 단위 테스트의 범위가 아니라는 생각했습니다. 레벨 1에서 학습한 테스트는 단위 테스트가 전부인데, 통합 테스트를 하려해서 어려워진 것입니다.</p>
<img width="820" alt="dao-test" src="https://github.com/hangillee/coderoad.kr/assets/14046092/56eee753-20b2-40a9-89f7-c87da655aba8">
<div align="center"><I>테스트 더블, Fake 객체를 활용하기로 한 이유</I></div>
<p>이렇게 생각한 이유를 PR 메시지에 적어서 3, 4단계를 제출했습니다.</p>
<p><img width="820" alt="test-double" src="https://github.com/hangillee/coderoad.kr/assets/14046092/b94c7c67-530d-4e9c-8d33-2f55b84d0120"><div align="center"><I>아서도 공감해주셨다...</I></div></p>
<p>다행히 아서도 제 생각에 공감해주셔서 미션을 잘 마무리 할 수 있었습니다. 커넥션 풀을 직접 구현해보기도 하고 직접 구현한 커넥션 풀 때문에 테스트에서 문제가 발생하기도 했지만 잘 해결했습니다. 이번 미션은 디자인 패턴에 대한 생각과 Java가 DB를 다루는 방법에 대해 많이 배운 미션이었습니다.</p>
<h2 id="공부할-개념들" class="heading">공부할 개념들</h2>
<ul>
<li>JDBC</li>
<li>테스트 더블</li>
<li>디자인 패턴</li>
<li>슬라이스 테스트</li>
<li>컴파일 타임 의존성과 런타임 의존성</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[우아한테크코스 레벨1 - 블랙잭]]></title>
    <link>https://blog.hangilog.kr/woowacourse-level1-mission3</link>
    <pubDate>2024-03-24</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/woowacourse-level1-mission3</guid>
    <description>
    <![CDATA[나의 클린코드를 찾아서]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="블랙잭---clean-code" class="heading">블랙잭 - Clean Code</h2>
<p>사다리 타기 미션의 여운이 채 가시기도 전인 3월 초, 새로운 미션의 날이 밝았습니다. 아는 사람들도 많고 꽤 유명한 카드 게임인 <strong>블랙잭</strong>을 구현하는 것이 이번 미션의 목표였습니다. 물론, 저는 블랙잭을 플레이 해본 적도, 룰을 잘 알고 있는 것도 아니었어서 조금 걱정됐습니다.</p>
<h3 id="1단계---블랙잭-게임-실행">1단계 - 블랙잭 게임 실행</h3>
<p>첫 단계는 블랙잭 게임을 실행하는 것이 핵심 목표였습니다. 물론, 제목만 블랙잭 게임 실행이지, 블랙잭의 거의 모든 핵심 비즈니스 로직을 구현해야 했습니다. 이번 미션의 페어였던 <a href="https://github.com/Mingyum-Kim" target="_blank" rel="noopener noreferer">안나</a>와 저는 개발 스타일이 달라 1단계 구현에 어려움을 조금 겪었습니다. 구현 방법에 대해 고민하는 것 뿐만 아니라, 서로의 코드 스타일을 이해하는데에도 시간이 꽤 많이 소모됐습니다. 거기다 블랙잭의 규칙은 사다리 타기와는 비교도 할 수 없게 복잡해 생각해야할 것도 많았습니다.</p>
<p>그러다보니 이번 미션의 핵심 주제가 <strong>Clean Code</strong>였지만, 안나와 제가 작성한 코드는 클린 코드와는 거리가 먼 '돌아가는 쓰레기'였습니다. 메소드의 indent는 최대 4개까지 생겼고, 역할과 책임은 제대로 부여되지도 않았습니다. 당연하지만 다른 무엇보다도 제출 기한에 맞춰는게 우선이었기 때문에 어쩔 수 없는 부분이었습니다. 그래도, 리팩토링을 진행하면서 어느 정도 깔끔한 코드가 만들어졌다고 생각했습니다. 언제나 그렇듯 제 생각일 뿐이었지만요. 😢</p>
<p>블랙잭 미션의 리뷰어는 <a href="https://github.com/Hyeon9mak" target="_blank" rel="noopener noreferer">현구막</a>이었습니다. 앞선 미션들에서 현구막에게 리뷰를 받아본 주변 크루들에게 현구막이 엄청 정성스러운 리뷰를 해주신다는 이야기를 들었습니다. 저도 많은 리뷰와 피드백을 주고 받을 생각에 조금 기대하고 코드 리뷰를 요청했습니다. 내심 깔끔하게 리팩토링까지 성공했다고 생각하고 요청한 코드 리뷰였지만, 돌아온 것은 소문대로 엄청나게 정성스러웠던 현구막의 '고봉밥' 리뷰였습니다.</p>
<img width="817" alt="blackjack-01" src="https://github.com/hangillee/coderoad.kr/assets/14046092/a1230717-56a9-4690-be33-7d1f6f7fed1c">
<div align="center"><I>감사합니다, 현구막!</I></div><br/>
<p>처음 리뷰를 받고 나서 든 생각은 아쉬움보다도 기쁨이었습니다. 현구막의 리뷰를 보면서 정말 많은 것을 배울 수 있었습니다. 요구사항은 결국 가독성을 위함인 것, DTO 내부에는 로직을 두지 않아야 한다는 점, Enum은 수단일 뿐인 점, Controller에 비즈니스 로직을 두지 않아야 하는 이유, 클린 코드의 기준 등, 정말 많은 부분에서 놓친 점들을 다시 상기할 수 있었습니다.</p>
<p>물론, 리뷰와 피드백을 주고 받는 과정은 조금 힘들었습니다. 제가 MVC 패턴을 제대로 이해하지 못하고 구현하다보니 1단계 미션 <code>merge</code>까지도 현구막이 지적한 부분을 올바르게 리팩토링하지 못했습니다. 그래도 배운 것들을 바탕으로 2단계 미션은 잘해내겠다는 다짐을 가지고 2단계 미션 구현을 시작했습니다.</p>
<h3 id="2단계---블랙잭-베팅">2단계 - 블랙잭 베팅</h3>
<p>2단계 구현에 앞서서 깊게 고민해본 것이 있습니다. <strong>"Clean Code란 무엇인가?"</strong> 그 동안 저는 이 질문에 명쾌하게 답변할 수 없었습니다. 현구막 역시 제가 클린 코드의 기준을 명확하게 세우지 않았다는 것을 눈치챘는지 저의 클린 코드의 기준이 무엇인지 물어보기도 했습니다. 그래서 꽤 오랜 시간을 고민해봤고, 제가 세운 저의 클린 코드 기준은 다음과 같습니다.</p>
<img width="732" alt="blackjack-02" src="https://github.com/hangillee/coderoad.kr/assets/14046092/951638cf-633e-4b55-8787-ffa1c793ae92">
<div align="center"><I>그래도 가장 우선되는 기준은 "읽기 쉬운 코드"</I></div><br/>
<p>위의 상세한 기준들은 결국 제가 처음부터 끝까지 추상적으로 가지고 있던 클린 코드의 기준인 "읽기 쉬운 코드"를 위한 기준들입니다. 클린 코드를 추구하는 이유는 결국 다른 개발자들과의 협업을 위함입니다. 내가 쓴 코드를 동료가 읽고, 동료가 쓴 코드를 내가 읽는 상황이 필연적으로 찾아올텐데, 그 코드가 읽기 쉬운 코드가 아니라면 능률이 떨어지고, 같이 일하기 싫어질 수도 있습니다.</p>
<p>그래서 객체지향 생활체조와 같은 여러 코드 컨벤션들이 생기고 디자인 패턴이 탄생한다고 생각합니다. 우리가 수학에서 여러 개념을 통일하자고 약속하듯, 나와 동료의 코드 사이에 약속을 만드는 것입니다. 약속이 생기면 약속만 잘 알고 있어도 이해할 수 있는 범위가 차원이 달라지니까요.</p>
<p>2단계 구현 자체는 그렇게 어렵지 않았습니다. 한 두개 정도의 도메인만 추가됐고, 기존의 코드가 거의 수정되지 않았습니다. 리뷰의 개수에서부터 알 수 있는데, 리뷰와 피드백 과정에서 46개의 대화가 오고 간 1단계와 다르게 이번 단계에서는 10개의 대화에 그쳤습니다.</p>
<p>물론 짧다면 짧을 이 과정에서도 또 배워가는 것이 있었습니다. 앞서서 언급한 클린 코드를 위한 약속의 일종인 디자인 패턴의 중요성과 모든 것을 예측할 수 없으니 현재 상황에 가장 어울리는 구조로 코드를 작성하라는 점을 배울 수 있었습니다.</p>
<h2 id="생각해볼-것들" class="heading">생각해볼 것들</h2>
<blockquote>
<p>이번 주 미션에서 학습한 내용에 대한 우아한테크코스의 질문과, 제 답변을 간략하게 정리해봤습니다.</p>
</blockquote>
<h3 id="블랙잭을-구현하며-클린-코드를-작성하기-위해-어떠한-것을-하였는가">블랙잭을 구현하며 클린 코드를 작성하기 위해 어떠한 것을 하였는가?</h3>
<p>사실 부끄럽지만 블랙잭을 구현하는 동안 클린 코드로 작성하기 위해 따로 고민한 부분은 없었던 것 같습니다. 특히 1단계에서는 일단 동작하는 프로그램을 만드려고 바쁘게 코드를 작성하다보니 객체지향 생활체조, <a href="https://codingnuri.com/seven-virtues-of-good-object/" target="_blank" rel="noopener noreferer">좋은 객체를 위한 7가지 덕목</a>와 같은 컨벤션은 커녕 기본적인 요구사항도 준수하지 못한 코드가 완성되었습니다.</p>
<p>그래도 현구막과 리뷰와 피드백을 주고 받으며 열심히 리팩토링했고, 요구사항도 준수하고 여러 컨벤션을 적용하는데 성공했습니다. 시간을 들여 천천히 구현해보니 제 클린 코드의 기준인 "읽기 쉬운 코드"가 완성된 것입니다. 정작, 완성에 급급했던 1단계 구현 당시에는 왜 진작 이렇게 하지 못했는지 아쉽기도 했습니다.</p>
<h3 id="본인이-정한-클린-코드의-기준은-무엇인가-그-기준을-지키기-위해-노력한-부분은-무엇인가">본인이 정한 클린 코드의 기준은 무엇인가? 그 기준을 지키기 위해 노력한 부분은 무엇인가?</h3>
<p>계속 이야기 했지만 <strong>제 클린 코드의 기준은 "읽기 쉬운 코드"입니다.</strong> 다른 무엇보다도 코드는 읽기 쉬어야 합니다. 함께 협업하는 동료를 위해서가 아니라 나를 위해서라도 읽기 쉬어야 유지보수성도 높아지고, 확장성도 높아집니다. 협업을 비단 다른 개발자와의 협업만 생각하기 쉽지만, 미래의 나와의 협업도 놓쳐서는 안됩니다. 결국, 코드를 유지보수하다보면 먼 미래에 내가 작성한 코드를 내가 읽어야 합니다.</p>
<p>과거의 내가 지금의 나와의 협업을 신경쓰지 않고 일단 돌아가는 코드를 작성하고 만족해버렸다면 그로 인한 손해는 고스란히 제게 돌아옵니다. 따라서 저는 무슨 일이 있어도 읽기 쉬운 코드를 작성하는 것을 최우선 목표로 삼으려고 노력합니다. 메소드 이름이 길어져도 절대 축약해서 작성하지 않는 것부터, 코드를 읽는 것이 책을 읽는 것처럼 자연스럽게 읽히도록 매개변수도 메소드 이름의 일부분으로 활용하기도 했습니다.</p>
<p>아래는 그 예시 코드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasLessCardThan</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Player</span> player<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token function">getHandSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&#x3C;=</span> player<span class="token punctuation">.</span><span class="token function">getHandSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasMoreCardThan</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Player</span> player<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token function">getHandSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> player<span class="token punctuation">.</span><span class="token function">getHandSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>제 기준에서 이렇게 작성하면 메소드 시그니처만 읽어도 해당 메소드가 무슨 일을 하는지 알기 쉽습니다. 이것이 제 클린 코드의 기준이고, 이를 지키기 위한 노력의 일부분입니다.</p>
<h3 id="피드백을-받으며-리팩토링하는-과정에서-어려움을-느낀-부분이-있는가-그-문제를-어떠한-방식으로-해결했는가">피드백을 받으며 리팩토링하는 과정에서 어려움을 느낀 부분이 있는가? 그 문제를 어떠한 방식으로 해결했는가?</h3>
<p>처음에는 막연하게 세운 클린 코드의 기준인 "읽기 쉬운 코드"에만 집중하다가 리팩토링 과정에서 조금 어려움을 겪었습니다. 상세한 기준이 없으니 당연히 읽기 쉬우면 전부라는 생각을 하게 됐고, 전체적인 코드의 구조는 잘 신경쓰지 않고 구현했습니다. 피드백을 통해 리팩토링하면서도 코드 부분 부분이 읽기 쉬우니 된 것이라고 생각했습니다. 그러나, 현구막과 대화하면서 진짜 읽기 쉬운 코드는 결국 전체적으로 이해하기 쉬운 코드라는 것을 깨달았습니다.</p>
<p>그래서 2단계를 구현하기 전에 우선 저만의 클린 코드 기준을 상세하게 세우고, 이를 기반으로 구현을 시작했습니다. (자세한 기준은 위의 사진에 있습니다!) 그 덕분인지 확실히 피드백도 1단계에 비해 많이 줄었습니다. 또한, 제대로 학습하지 못하고 그냥 활용했던 개념들이 많았던 탓에 리팩토링 과정이 순탄치 않았던 것도 있었습니다. 그래서 앞으론 어떤 개념을 활용하기 앞서, 해당 개념을 확실히 학습하고 활용하고자 합니다.</p>
<h3 id="해당-미션에서-작성한-본인의-코드가-만족스러운가-다음-미션에선-어떠한-목표로-코드를-작성할-예정인가">해당 미션에서 작성한 본인의 코드가 만족스러운가? 다음 미션에선 어떠한 목표로 코드를 작성할 예정인가?</h3>
<p>저는 항상 제 코드에 완전히 만족하지 않습니다. 아무리 잘 짠 코드라고 하더라도 누군가에는 읽기 어려울 수 있습니다. 만약, 미래의 제 동료가 지금의 블랙잭 코드를 이해하기 어렵다고 말한다면 리팩토링 해야 한다고 생각합니다. 그래서 저는 항상 제 코드에 대해 비판적인 자세를 가지고 언제든 바뀔 수 있다고 생각하려고 합니다.</p>
<p>그렇다고 해서 제 코드에 애정이 없는 것은 아닙니다. 언제든 더 나아질 수 있는, 무궁무진한 가능성을 가졌다고 생각하려고 하는 것입니다. 제가 더 성장할 수 있다면, 제 코드도 그럴테니까요!</p>
<h2 id="공부할-개념들" class="heading">공부할 개념들</h2>
<ul>
<li>상태 패턴을 비롯한 디자인 패턴</li>
<li>클린 코드의 기준</li>
<li>객체지향 생활체조</li>
<li>함수형 인터페이스</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[우아한테크코스 레벨1 - 사다리 타기]]></title>
    <link>https://blog.hangilog.kr/woowacourse-level1-mission2</link>
    <pubDate>2024-03-10</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/woowacourse-level1-mission2</guid>
    <description>
    <![CDATA[테스트 주도 개발 도전기]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="사다리-타기" class="heading">사다리 타기</h2>
<p>이번 미션은 우리가 흔히 알고 있는 "사다리 타기"를 구현하는 미션이었습니다. 평소에 친구들과 사다리 타기를 할 때는, 너무 간단한 게임이고 어려운 규칙이 있는 것도 아니어서 쉬울 수도 있겠다는 생각을 했습니다. (물론 쉽진 않았습니다.)</p>
<h3 id="1단계---사다리-생성">1단계 - 사다리 생성</h3>
<p>3일 안에 완성해야하는 미션의 첫 단계는 사다리를 요구사항대로 생성하는 일이었습니다. 이번 미션의 페어였던 <a href="https://github.com/ksk0605" target="_blank" rel="noopener noreferer">테바</a>가 졸업식에 참석해야하는 이슈로 2일 만에 끝내야 했기에 조금 서둘렀습니다. 토론도 속전속결, 드라이버와 네비게이터의 역할 전환도 서로의 <code>git</code> 저장소에 <code>push</code>하고 <code>pull</code>해오는 방법을 이용해 빠르게 진행했습니다. 테바와 저의 개발 스타일이 비슷했던 것도 큰 도움이 되었습니다.</p>
<p>다행히 1단계 미션은 이틀 만에 완료했고, 테바는 큰 걱정 없이 졸업식에 다녀올 수 있었습니다. 물론, 저희가 개발을 엄청 잘해서 빨리 끝냈던 건 아니고, 이렇게 속도를 낼 수 있었던 이유는 다름 아닌 이번 미션의 핵심 주제 <strong>TDD</strong>(테스트 주도 개발) 덕분이었습니다. TDD 사이클을 적극적으로 활용해 미션을 진행했더니 <a href="https://blog.coderoad.kr/woowacourse-level1-mission1" target="_blank" rel="noopener noreferer">자동차 경주</a> 미션 때와는 다르게 코드를 신뢰할 수 있게 되었고, 혹시나 발생할 오류를 걱정하는 것과 같은 불필요한 고민을 줄일 수 있었습니다.</p>
<blockquote>
<p>TDD에 대한 자세한 설명은 추후 정리해서 포스팅할 예정입니다.</p>
</blockquote>
<p>1단계는 빠르게 완료했던 것만큼, 지금 돌아봐도 크게 어려웠던 점은 없었던 것 같습니다. 다만, 미션 중에 테바와 함께 고민했던 부분과 코치의 피드백은 조금 공유하고 싶습니다.</p>
<p>저와 테바는 <code>View</code>와 <code>Domain</code>의 의존관계를 끊어내기 위해 DTO를 사용하기로 합의했고, 어떤 객체에게 DTO 생성의 책임을 부여해야할지 토론하고 있었습니다. 테바는 <code>Controller</code> 역할을 하는 객체에게, 저는 도메인이 직접 생성하는 쪽이 낫다고 생각했습니다. 쉽사리 의견은 좁혀지지 않았고, 저희는 코치에게 어느 쪽이 더 나은지 의견을 듣고자 코치룸으로 찾아갔습니다.</p>
<p>하지만 코치들은 명쾌한 해답을 내심 바라고 있던 저희의 기대와는 다르게 오히려 더 고민할만한 질문을 던져주셨습니다. DTO를 사용하는 이유를 명확하게 설명할 수 있는지, <code>Domain</code>에 <code>View</code>를 위한 기능이 존재하는게 아니라, <code>View</code>가 <code>Domain</code>의 기능을 활용하는 것 뿐이라고 생각하면 안되는 건지 등, 정말 다양한 관점의 질문을 주셨고, 저흰 나름 저희의 답을 드렸지만 번번히 반박 당했습니다.</p>
<p>약 20분 가량의 코치와의 토론(?)끝에 내린 결론은 굳이 DTO를 사용할 이유를 설명하지 못했으니, DTO 사용을 포기하고 기능을 더 명확하게 분리해서 <code>View</code>와 <code>Domain</code> 사이의 의존관계를 끊어내자는 것이었습니다. 다행히, 만족할만한 코드를 작성해 앞서 말했던 것처럼 1단계를 빠르고, 무사히 마칠 수 있었습니다.</p>
<p>개인적으로 DTO의 사용 이유와 <code>View</code>와 <code>Domain</code> 사이의 연관관계를 끊어내야하는 이유를 설명하자면,</p>
<ol>
<li>
<p>DTO는 객체를 직접 의존하지 않고도 객체의 상태(값)를 전달하거나, 전달 받도록 할 수 있는 "정류장"의 역할로 사용할 수 있다고 생각합니다. 굳이 외부에서 필요로하지 않는 상태나 메소드를 노출하지 않고도 서로 다른 두 객체가 협력할 수 있다는 것 자체로 충분히 활용할만한 가치가 있습니다.</p>
</li>
<li>
<p><code>View</code>와 <code>Domain</code>의 의존관계를 끊어내야 하는 이유는 객체지향 프로그래밍의 원칙 중 하나인 개방-폐쇄 원칙(OCP)를 준수하기 위함과 동시에, 코드를 수정할 때, 그 파급효과가 최소화 되기 때문입니다. <code>View</code>는 사용자나 클라이언트의 의견에 따라 자주 변경될 가능성이 높은데, <code>Domain</code>과 강한 연관관계를 맺고 있다면 개발자가 사소한 <code>View</code> 수정에도 읽어야하는 코드가 너무 길고, 실수하기 쉬워집니다.</p>
</li>
</ol>
<h3 id="2단계---사다리-게임-실행">2단계 - 사다리 게임 실행</h3>
<p>짧지만 강렬했던 1단계가 리뷰어 <a href="https://github.com/ddu0422" target="_blank" rel="noopener noreferer">미르</a>의 <code>merge</code>로 종료되면서, 본격적인 사다리 타기를 구현하는 2단계 미션을 시작했습니다. 워낙 1단계가 빨리 끝나서 다소 여유로울 것이라는 제 생각과 다르게 2단계에서는 신경써야 할 부분이 훨씬 많았습니다.</p>
<p>사다리를 그리는 것만 잘되면 OK였던 1단계와 다르게 사다리를 타고 내려오는 연산을 어떻게 해야할지부터 상당한 고민거리였습니다. 이중 <code>for</code>문을 사용하기에는 프로그래밍 요구사항의 <strong>indent(인덴트, 들여쓰기) depth를 2를 넘지 않도록 구현한다. 1까지만 허용한다.</strong> 때문에 적합하지 않았고, 성능 상으로도 그닥 좋지 않을 것 같았습니다. (물론 성능을 신경쓰라는 요구사항은 없었습니다.)</p>
<p>그때 마침 다른 크루인 <strong>폭포</strong>와 대화하면서 폭포가 떠올린 알고리즘을 들을 수 있었고, 저는 이를 활용해 사다리를 타고 내려오는 연산을 구현했습니다. 제 마음에도 들고, 코드도 그리 복잡하지 않았기 때문에 저는 좋은 코드를 작성했다고 생각했지만, 다른 러쉬나 테바는 오히려 너무 복잡하다는 의견을 제시했습니다.</p>
<p>알고리즘을 이해하는 것부터 조금 어렵고, 성능 개선에서 드라마틱한 효과가 있는 것도 아닌데 너무 다른 동료 개발자들의 능률을 떨어뜨리는게 아니냐는 의견이었습니다. 그러나 저는 이 정도의 알고리즘은 개발자라면 누구나 이해할 수 있고, 성능 개선은 하지 않는 것보단 조금이나마 하는게 낫지 않겠냐는 생각을 가지고 있었습니다.</p>
<p>이미 상당 부분 구현을 완료한 상황이라 저는 크루들의 의견을 반영하기 보다, 리뷰어인 미르의 피드백을 받아보기로 했습니다. 미르는 알고리즘 자체는 이해하기 어렵지 않고, 오히려 애매한 변수나 메소드 이름 때문에 이해하기 어렵다는 피드백을 주셨습니다.</p>
<img width="800" alt="java-ladder-review" src="https://github.com/hangillee/coderoad.kr/assets/14046092/6a20a24f-b1ef-484d-83b8-4f597aa7d365">
<div align="center"><I>알고리즘이 문제가 아니라 작명 센스가 문제였다...</I></div><br/>
<p>물론, 알고리즘을 활용하는 방법이 더 좋다는 건 아니었습니다. 당연하겠지만 저희는 다른 개발자들과 협업하면서 살아갑니다. 제가 작성한 코드는 저보다도 다른 동료들이 더 많이 읽게 된다는 미르의 피드백에, 저는 "남이 읽기 좋은 코드"를 저만의 좋은 코드의 기준으로 삼아야겠다는 생각을 했습니다. 개발자로서의 좌우명이 "나를 위해 남을 돕는 개발자가 되자."인 만큼, 다른 동료 개발자들이 읽기 좋은 코드를 작성하고자 노력하려 합니다.</p>
<p>이외에도 매개변수에 <code>final</code>을 붙인 이유, <code>NPE</code>를 방지하기 위한 방법들, 경계값 테스트, Enum의 <code>values()</code>를 활용하기 등, 다양한 피드백을 받았고, 이를 바탕으로 코드를 개선한 끝에, 2단계 미션도 무사히 마칠 수 있었습니다.</p>
<h2 id="생각해볼-것들" class="heading">생각해볼 것들</h2>
<blockquote>
<p>이번 주 미션에서 학습한 내용에 대한 우아한테크코스의 질문과, 제 답변을 간략하게 정리해봤습니다.</p>
</blockquote>
<h3 id="내가-tdd-리팩토링을-하는-이유">내가 TDD, 리팩토링을 하는 이유</h3>
<p>저는 TDD와 리팩토링을 더 빠르고, 믿을 수 있게 코드를 작성하고자 활용합니다. 결국 테스트를 작성한다는 것은 제가 설계한 기능과 객체들의 동작을 검증하는 것이고, 리팩토링 역시 코드를 더 깔끔하고 읽기 쉽게 하기 위해 진행합니다.</p>
<p>또한, 실패하는 단위 테스트를 작성하고, 성공하는 로직을 구현하고, 리팩토링을 통해 코드를 깔끔하게 만드는 TDD 과정(TDD Cycle)에서, 개발자는 필요한 모든 기능을 위한 테스트를 작성하게 됩니다. 이는 결국, 테스트 코드가 프로그램의 기능 명세서이자 모든 기능이 정상 동작한다는 보증서가 된다는 방증입니다. 테스트가 주도하는 개발, TDD를 올바르게 활용하고 있다면, 테스트가 작성되지 않은 그 어떤 기능도 먼저 구현되어서는 안됩니다.</p>
<p>개발자는 컴퓨터가 아닌 사람이기 때문에 누구나 실수할 수 있습니다. 그러나, 개발자의 실수가 때로는 치명적인 프로그램 오류나 회사의 금전적 피해로 이어질 수 있습니다. 따라서, 돈을 벌어다주는 개발자(회사가 원하는 인재...)가 되기 위해선 테스트를 잘 작성해서 "내 코드는 믿을만합니다!"라고 당당하게 말할 수 있어야 합니다. 그래서 저는 TDD와 리팩토링을 합니다.</p>
<p><strong>더 빠르고, 꼼꼼하고, 믿을 수 있게 코드를 작성하고자.</strong></p>
<h3 id="기존에-구현하는-방식과-tdd로-코드를-구현할-때의-차이는">기존에 구현하는 방식과 TDD로 코드를 구현할 때의 차이는</h3>
<p>기존의 방식과는 다르게 TDD로 코드를 구현할 때는, <strong>내가 구현한 코드에 대한 확실한 신뢰감을 얻을 수 있었습니다.</strong> 이미 성공한 테스트의 기능들은 다시 살펴보지 않아도 정상 작동한다고 가정하고 다른 기능의 테스트를 작성하고, 구현하다보니 속도도 훨씬 빨랐습니다. 지금 당장 무엇을 해야하고, 다음엔 무엇을 해야할지 명확한 방향성도 알 수 있었습니다.</p>
<h3 id="리팩토링에서의-어려움과-어려움을-줄이기-위한-시도들">리팩토링에서의 어려움과 어려움을 줄이기 위한 시도들</h3>
<p>리팩토링하면서 겪었던 어려움의 대부분은 테스트가 통과된 기존의 기능들을 수정해야할 때 발생했습니다. 도메인 설계 과정에서의 실수로, 새 기능을 추가하는 과정에서 기존 코드에 수정해야하는 일이 생기면, 덩달아 테스트도 깨져서 실패하기도 하고, 프로그램이 아예 돌아가지 않기도 했습니다.</p>
<p>이러한 어려움을 줄이기 위해 저는 객체의 역할과 책임을 더 작게 나누고 명확하게 구분하려고 노력했습니다. 결국 TDD와 리팩토링은 기능에 대한 보증을 해줄 뿐, 설계에 대한 책임은 개발자인 저에게 있습니다. 제가 처음부터 설계를 잘못하면 아무리 테스트를 열심히 작성하고 예쁘게 리팩토링해도 결국 코드를 수정해야하는 순간이 올 수 밖에 없습니다.</p>
<p>신뢰할 수 있는 코드를 작성하기 위해 TDD를 하고, 리팩토링을 하는데, 기초부터 잘못됐다면 과연 믿을 수 있는 코드일까요?</p>
<h3 id="개발을-잘한다의-기준">개발을 잘한다의 기준?</h3>
<p>개발을 잘한다의 기준은 <strong>동료 개발자들에게 얼마나 많은 신뢰와 지지를 얻고 있는가에 달렸다</strong>고 생각합니다. 물론 절대적인 기준으로 많은 지식을 가지고 있고(본인이 작성한 논문이나 저서가 있다던지), 대회 수상 이력이나 여러 자격증을 내세울 순 있겠지만, 동료 개발자들이 함께 일하기 꺼려한다면 결국 프로그래밍은 잘할 수 있어도 개발은 잘한다고 보기 어렵다고 생각합니다.</p>
<p>보통 개발은 혼자서 하는 것이 아니라, 회사나 동아리 등의 단체에서 함께 하는 것이 일반적입니다. 특히, 회사에서는 수많은 개발자들이 서로 협력하며 하나의 목표를 향해 함께 나아가고 있습니다. 어느 팀에서는 더 나은 사용자 경험을 위해, 또 다른 어느 팀은 더 나은 서비스 성능을 위해, 혹은 정확한 금액 계산을 위해 "함께" 노력하고 있습니다. 더 많은 경험과 지식을 바탕으로 다른 개발자들을 도와 공통의 목표를 달성하는 개발자는 결국 동료 개발자들이 "저 사람은 개발을 참 잘해."와 같이 실력이
뛰어나다고 인정해줄 것입니다.</p>
<p>적어도 저는 그런 개발자를 "개발 잘하는 개발자"라고 생각하고, 그걸 목표로 하고 있습니다.</p>
<h3 id="내가-작성한-코드가-만족스러운가">내가 작성한 코드가 만족스러운가?</h3>
<p>물론, 전혀 만족스럽지 않습니다. 😢 아직 부족한 실력 탓인지 처음 TDD를 해봤던 탓인지 여러모로 완벽하게 요구사항을 준수하지 못한 것 같아 너무 아쉽습니다. 리뷰어의 질문에 제대로 답하지 못했던 것부터, 코드 전반적으로 읽기 쉬웠나 한다면 별로 그렇지도 않았던 것 같습니다.</p>
<p>리뷰어였던 미르의 피드백처럼, 메소드나 변수의 이름이 한번에 그 의미를 파악하기 어려웠고, 객체들의 역할과 책임을 제대로 분리하지 못해 중복되거나 위치가 애매한 기능들도 꽤 있었습니다. 그래도 TDD는 꽤 만족스럽게 이루어졌던 것 같아 다행인 것 같습니다. 다음 미션에서는 제가 생각하는 클린 코드의 기준인 "남이 읽기 쉬운 코드"를 위해 조금 더 노력해봐야겠습니다.</p>
<h2 id="공부할-개념들" class="heading">공부할 개념들</h2>
<ul>
<li>TDD</li>
<li>DTO</li>
<li>경계값 테스트</li>
<li>좋은 테스트를 위한 원칙들
<ul>
<li>CORRECT</li>
<li>Right-BICEP</li>
<li>FIRST</li>
</ul>
</li>
<li>Enum</li>
<li>불변 객체</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[우아한테크코스 레벨1 - 자동차 경주]]></title>
    <link>https://blog.hangilog.kr/woowacourse-level1-mission1</link>
    <pubDate>2024-02-23</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/woowacourse-level1-mission1</guid>
    <description>
    <![CDATA[우아한테크코스에 합류하다.]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="welcome-on-board" class="heading">Welcome On Board!</h2>
<p>길고 긴 우아한테크코스 선발 과정 이후, 저는 <strong>리건</strong>이라는 닉네임으로 우아한테크코스 6기 웹 백엔드 과정에 합류했습니다. 2024년 2월, 오리엔테이션에서 처음 받아본 온보딩 미션은 프리코스에서도 이미 한번 해결해봤던 <strong>자동차 경주</strong>였습니다.(또 하나 어마무시한 미션이 주어졌지만 혹시 이 글을 읽을지도 모를 미래의 크루를 위해 비밀로 하겠습니다.) 미리 경험해봤던 미션이라 그런지 요구사항도 크게 어렵지 않게 분석할 수 있었고, 금방 끝낼 수 있을 것 같다는 생각이 들었습니다. 그러나, 생각과는 다르게 이번 미션이 단순히 기능을 구현하는게 전부가 아니었습니다.</p>
<p><strong>페어 프로그래밍</strong>, 우아한테크코스에서 맺어준 페어와 <strong>함께</strong> 이번 미션을 해결해야하는게 진정한 도전이었습니다. 지금까지 한번도 해본 적 없는 방식으로 개발해야한다는 것이 상당히 어색했습니다. 페어 프로그래밍은 드라이버(Driver)와 네비게이터(Navigator)가 한 팀으로 개발하는 방식을 말하는데, 드라이버는 직접 코드를 작성하는 사람, 네비게이터는 방향성을 제시하고 드라이버가 놓치는 부분을 찾아주는 사람입니다.</p>
<p>페어와 의견이 맞지 않으면 어떡하지, 혹시나 서로 감정이 상해 미션 시작부터 망쳐버리면 어떡하지라는 생각에 조금 긴장되기도 했습니다. 그러나, 제 첫 페어인 <a href="https://github.com/xogns1514" target="_blank" rel="noopener noreferer">러쉬</a>는 제 걱정이 전혀 쓸데없었다는 듯, 소통도 잘되고, 협업도 잘 됐던 페어였습니다. 서로의 개발 스타일을 고집하지 않고, 토론을 통해 서로를 설득하여 개발 방식을 결정했습니다. 메소드와 변수의 이름, 객체 설계, 문서 작성 등, 다양한 부분에서 정말 많은 대화를 나눴고, 예상보다 빠른 속도로 1단계를 완료할 수 있었습니다.</p>
<h3 id="긴장됐던-코드-리뷰">긴장됐던 코드 리뷰!</h3>
<p>우아한테크코스의 미션 진행 방식을 간단하게 설명하자면 다음과 같습니다.</p>
<ol>
<li>페어와 함께 1단계 미션을 해결한다.</li>
<li>리뷰어에게 코드 리뷰를 요청한다.</li>
<li>리뷰어의 리뷰를 바탕으로 리팩토링한다.</li>
<li>리뷰어가 미션 통과를 알리면 다음 단계 미션을 진행한다.</li>
</ol>
<p>우아한테크코스를 수료한 선배들에게 내 코드를 리뷰 받는다니! 우아한테크코스에 지원하길 잘했다고 생각한 순간이기도 합니다. 아무리 페어와 함께 개발하면서 최대한 더 나은 방법이 무엇이 있을까 고민했어도, 훨씬 경험이 많은 선배들의 의견을 듣는 것은 차원이 다른 경험이라고 생각합니다. 실제로, 리뷰를 받고 그 리뷰를 바탕으로 코드를 리팩토링 해본 소감도 이 코드 리뷰는 둘도 없는 경험이라는 것입니다.</p>
<p>저와 페어 모두 완전히 놓치고 있었던 부분이나, 아예 몰랐던 개념, 잘못 생각하고 있었던 것들까지 배울 수 있는 것이 정말 많은 한 주였습니다. 주어진 시간 자체도 그렇게 길지 않았음에도 제 첫 리뷰어셨던 <a href="https://github.com/sihyung92" target="_blank" rel="noopener noreferer">웨지</a>는 DM으로 친절하게 리뷰를 요청하는 방법에 대해 설명해주시고, 아무리 긴 질문이나 간단한 질문이라도 자세하게 답변해주셨습니다. 궁금했던 점이 진짜 시원하게 해결되는 느낌이었고, 내가 고민한 내용들이 선배 크루들도 다 겪고 지나간 어려움이었구나라는 생각도 들었습니다.</p>
<p>다르게 보자면, 우아한테크코스에 열심히 몰입했을 때, 웨지와 같이 멋진 선배 개발자가, 누군가에게 좋은 영향을 줄 수 있는 개발자가 될 수 있겠다는 생각도 들었습니다. 첫 번째 미션을 무사히 끝내고나니 앞으로 무엇이든 해낼 수 있겠다는 자신감도 생겼습니다.</p>
<h2 id="생각해볼-것들" class="heading">생각해볼 것들</h2>
<blockquote>
<p>이번 주 미션에서 학습한 내용에 대한 우아한테크코스의 질문과, 제 답변을 간략하게 정리해봤습니다.</p>
</blockquote>
<h3 id="내가-단위-테스트를-작성하는-이유는-무엇인가">내가 단위 테스트를 작성하는 이유는 무엇인가?</h3>
<p>이번 자동차 미션의 부제는 <strong>단위 테스트</strong>였습니다. 그동안 TDD나 테스트 작성의 중요성에 대해서 들어는 봤지만, 실제로 개발에 적극적으로 테스트를 도입해본 적은 없었습니다. 항상 기능을 구현하는데 급급했고, 직접 프로그램을 실행해 하나하나 확인하면서 모든 예외 케이스를 체크했습니다. 당연히 예외가 발생하면 프로그램이 중지되니 매번 다시 프로그램을 시작해야했습니다. 개발 능률은 떨어지고, 놓친 예외는 없는지 확인하기도 힘들었습니다.</p>
<p>예외는 물론이거니와 잘못 구현된 기능이 존재하는지 찾는 것도 일이었습니다. 제 생각에는 제대로 구현된 것 같은데 알고보니 완전 잘못된 구현이었다는 걸 알아채는 것도 오랜 시간이 걸렸습니다. 심지어는 끝까지 찾아내지 못하다가 나중에서야 발견하기도 했습니다. 저는 제 코드를 전혀 믿을 수 없고, 항상 불안함에 살게 됐습니다.</p>
<p>버그 없는 코드는 없다지만, 충분히 예방할 수 있는 버그는 막는게 좋을 것입니다. 저는 버그를 예방할 수 있는 가장 좋은 방법이 단위 테스트라고 생각합니다. 즉, <strong>제가 단위 테스트를 작성하는 이유는 제 코드를 믿을 수 있고, 안전하게 만들기 위해서</strong>입니다.</p>
<h3 id="내가-작성한-좋은-단위-테스트는-어떠한-부분에서-좋은가">내가 작성한 좋은 단위 테스트는 어떠한 부분에서 좋은가?</h3>
<p>저는 <strong>'좋은' 단위 테스트</strong>는 읽기 좋고 어떤 기능을 테스트하는지 한눈에 파악하기 쉬워야 한다고 생각합니다. 단위 테스트의 이름에서부터 알 수 있듯, 최소 개체를 테스트하는 것이 단위 테스트입니다. 보통은 한 메소드가 하나의 기능만 담당하는 것이 좋은 코드라고 여겨지니, 좋은 단위 테스트는 한 테스트에 하나의 기능만 테스트하는 것이 좋은 것 같습니다.</p>
<p>한번에 하나의 기능만 테스트하면 자연스레 읽기 편하고 어떤 기능을 테스트하는지 알기 쉬워질 것입니다. 물론, 저는 예외 상황에 대한 검증도 기능이라고 생각해, 각 예외 상황에서 제대로 예외를 발생시키는지 테스트하는 것도 단위 테스트라고 생각합니다. 이러한 기준을 바탕으로 이번 미션에선 최대한 한 테스트 메소드가 하나의 기능만 테스트하도록 작성했습니다.</p>
<p>이렇게 작성하고나니 테스트 코드만 보더라도 대략적으로 각 객체가 어떤 기능을 가지고 있고, 어떤 상황에서 예외가 발생할지 알 수 있게 되었습니다. 코드가 읽기 좋다는 건 그만큼 유지보수하기 쉽다는 뜻이기도 하니, 제가 작성한 테스트는 제 <strong>프로그램의</strong> 일종의 <strong>설명서 역할을 하는 점에서 좋은 것 같습니다.</strong></p>
<h3 id="좋은-단위-테스트를-작성하기-위해-어떠한-시도를-해볼-수-있는가">좋은 단위 테스트를 작성하기 위해 어떠한 시도를 해볼 수 있는가?</h3>
<p>좋은 단위 테스트를 작성하기 위해서는 일단, 구현 요구사항을 정확하게 이해하는 것이 중요하다고 생각합니다. 결국 단위 테스트는 <strong>구현한 기능이 의도한대로 정확하게 동작하는지 확인하기 위한 것</strong>이고, 개발자가 요구사항을 제대로 이해하지 못했다면 단위 테스트를 작성하는 의미가 없기 때문입니다. 시작부터 잘못 동작하는 기능을 구현하게 될텐데, 기능이 잘못 동작하는지 확인하는 테스트는 결코 좋은 테스트라고 볼 수 없습니다.</p>
<p>다음으로, <strong>테스트 주도 개발(TDD)을 시도해 보는 것</strong>도 좋은 단위 테스트를 작성하기 위한 훌륭한 시도라고 생각합니다. 테스트 주도 개발은 먼저 실패하는 테스트를 작성하고, 실패한 테스트가 성공하도록 기능을 구현하고, 테스트가 성공하면 구현 코드가 깔끔해지도록 리팩토링을 시도하는 개발 방법론입니다. TDD를 도입하면, 자연스럽게 구현 요구사항을 상세하게 분석하여, 프로그램에서 가장 작은 단위인 기능들을 명확하게 정의하게 될 것입니다.</p>
<p>어떤 기능을 구현해야할지 명확해지면, 자연스럽게 객체의 역할과 책임이 명확해질 수 있고, 기능 구현 속도도 빨라질 수 있다고 생각합니다. 결국 좋은 테스트는 내가 작성한 코드를 완전히 신뢰할 수 있게 만들어주고, 새로 구현된 기능들이 제대로 동작하는지 빠르게 확인할 수 있어야 좋은 테스트입니다. 구현 요구사항의 정확한 이해와 TDD와 같은 방법론의 도입을 통해 테스트 작성의 효율을 극대화한다면 자연스레 좋은 테스트가 될 수 있을 것입니다.</p>
<h3 id="자동차-경주에-단위-테스트를-얼마나-추가하였는가-어려웠던-점은-없었는가">자동차 경주에 단위 테스트를 얼마나 추가하였는가? 어려웠던 점은 없었는가?</h3>
<p>이번 미션에서는 11개 단위 테스트를 작성하여 핵심 도메인 클래스 기준, 66%의 테스트 커버리지(Test Coverage)를 확보했습니다. 어려웠던 점은 프리코스에서부터 꾸준히 겪고 있는 <strong>랜덤 값과 같은 테스트하기 어려운 코드에 대한 테스트 작성</strong>이었습니다. 자동차 경주에서는 인터페이스를 활용해 자동차의 전진을 위한 숫자 생성 객체를 추상화하여 해결했지만, 피드백을 보니 메소드만 단순하게 분리해 더 간단하게 해결하는 방법도 있을 것 같다는 생각이 들었습니다.</p>
<p>예를 들어, 자동차의 전진에 필요한 숫자의 요구사항이 변경되지 않는다면, 너무 과한 추상화는 아니었는가라는 생각도 들었습니다. 확실히 인터페이스를 통해 테스트할 수 있게 된 것은 좋았지만, 테스트하기 위한 코드가 추가될 수 밖에 없었습니다. 테스트 코드 내부에 난수가 아닌 지정된 숫자를 생성하도록 하는 클래스를 새로 정의해야했고, 이 자체만으로 개발자의 에너지를 소모하는 일이었습니다. 조금 더 생각해볼 여지가 있는 부분이었습니다.</p>
<h3 id="코드-품질을-위해-노력한-부분은-무엇인가">코드 품질을 위해 노력한 부분은 무엇인가?</h3>
<p>코드 품질을 높이기 위해 그동안 알고 있었던 여러 지식과 Google Java Convention을 준수하면서 코드를 작성하려고 노력했습니다. 변수 이름을 지을 때는 자료형의 이름을 최대한 제외한다든지, 메소드 이름을 축약하지 않고 읽었을 때 어떤 기능을 할지 알 수 있도록 했다든지, <code>public</code> 메소드와 연관된 <code>private</code> 메소드들을 바로 아래 두어서 메소드가 어떻게 동작하는지 쉽게 파악하도록 했습니다.</p>
<p><strong>코드의 품질은 결국 협업하는 동료 개발자들이 얼마나 읽기 쉬운가에서 온다고 생각합니다.</strong> 평생 혼자 개발하겠다는 사람이 아니라면, 필연적으로 다른 동료 개발자들과 소통하게 될텐데, 내가 읽어도 어렵고, 동료는 읽을 수 조차 없는 코드는 재사용은 커녕 유지보수하는 것도 힘들어질 것입니다. 그래서 여러 컨벤션들이 정해지고, 개발 방법론들이 생겨났다고 생각합니다.</p>
<p>선배 개발자들의 시행착오에서 탄생한 여러 컨벤션과 개발 방법론을 공부하는 것만으로도 이미 누군가 지나온 시행착오들을 가뿐하게 건너 뛰어 좋은 코드를 작성할 수 있을 것입니다. 그래서 저는 코드 품질을 높이기 위해 Google Java Convention을 준수하려고 노력했습니다. 이런 컨벤션을 작성한 선배 개발자들도 이런 후배 개발자들이 많아지길 원하지 않았을까요?</p>
<h3 id="본인의-코드가-만족스러운가-다음-미션에선-어떠한-목표로-코드를-작성할-예정인가">본인의 코드가 만족스러운가? 다음 미션에선 어떠한 목표로 코드를 작성할 예정인가?</h3>
<p>이번 미션에서의 코드는 당연히 만족스럽지 않습니다.(아마 평생을 만족하지 못할 것 같습니다.) 리뷰어 웨지의 피드백이나, 다른 크루들의 코드를 읽어보니 제가 놓치고 있는 부분이 너무 많다는 생각이 들었습니다. 사소한 부분부터, 기능의 구현 방법까지 저보다 잘하는 사람은 정말 많은 것 같습니다. 그래도 정말 긍정적인 것은, 제가 앞으로 성장할 수 있는 부분이 아직 엄청 많다는 것입니다.</p>
<p>그래서 저는, 다른 크루들의 장점을 배우고, 리뷰어의 피드백을 적극 수용하면서 저만의 코드 스타일을 정립하고자 합니다. 크루들과 대화해보면 리뷰어들마다도 스타일이 달라 페어끼리 어떤 방식이 더 나은지 고민이 많은 것 같았습니다. 저 역시 계속해서 더 나은 방식은 무엇일까, 왜 내 리뷰어와 페어의 리뷰어는 의견이 달랐는지 많은 고민을 했습니다.</p>
<p>다음 미션에서는 이번 미션에서의 여러 피드백들을 적극 반영해볼 생각입니다. 또, 다른 방식으로 이번 미션에서 겪었던 문제를 해결하며 어떤 방식으로 해결하는게 더 나을지 리뷰어의 의견을 들으려합니다. 코치들끼리도 모두 스타일이 다르다고하니, 저는 정말 다양한 사람들의, 다양한 방법에 대한 의견을 듣고 제 스타일, 저만의 기준을 찾는데 더 집중해볼 생각입니다.</p>
<h2 id="공부할-개념들" class="heading">공부할 개념들</h2>
<ul>
<li>Fluent API</li>
<li><code>final</code></li>
<li>Google Java Convention</li>
<li>MVC 패턴</li>
<li><code>static</code></li>
<li>객체지향 프로그래밍</li>
<li>테스트 주도 개발</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[우아한테크코스 최종 코딩 테스트 회고]]></title>
    <link>https://blog.hangilog.kr/woowacourse-final-test</link>
    <pubDate>2024-01-23</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/woowacourse-final-test</guid>
    <description>
    <![CDATA[후회 없이 달려본, 그래도 아쉬운 5시간]]>
    </description>
    <content:encoded>
      <![CDATA[<blockquote>
<p>최종 코딩 테스트는 <code>private</code> 저장소에 커밋하는 미션이었습니다. 따라서, 코드를 공개하지 않기로 결정했습니다.</p>
</blockquote>
<h2 id="12월의-어느-날" class="heading">12월의 어느 날</h2>
<p>프리코스를 끝내고 평화로운 나날을 보내고 있던 12월의 어느 날, 기말 고사 기간이었던 저는 강의실에서 부랴부랴 벼락치기를 하고 있었습니다. 프리코스 미션을 하느라 학업에 살짝 소홀했지만, 그래도 자신 있던 강의여서 놓친 부분은 없나 다시 한번 복습하고 있었지만, 제 정신은 다른 곳으로 떠난지 오래였습니다.</p>
<p>하필이면 기말 고사가 있는 날이 우아한테크코스 1차 심사 결과가 나오는 날이었기 때문입니다. 아무리 마음을 비우고 있었다하더라도 기대를 할 수 밖에 없었고, 함께 프리코스에 참여했던 동기, 후배들과 떨리는 마음으로 심사 결과를 기다리고 있었습니다. 시험을 보는 둥 마는 둥 후딱 해치우고 나온 저는 떨리는 마음으로 메일함을 열었습니다. (물론 그렇다고 시험을 완전 망치진 않았습니다...)</p>
<img width="620" alt="woowacourse-accept-firststep" src="https://github.com/hangillee/coderoad.kr/assets/14046092/6c078feb-7c6e-49a0-9c41-60e802cf0cdf">
<div align="center"><I>다시봐도 떨리는 합격 통보 메일!</I></div><br/>
<p>입이 바짝 마르고 턱이 달달 떨리던 제가 열어 본 메일에는 합격 소식이 담겨있었습니다. 한 달 동안 쉬지 않고 개발만 했던 제 노력이 보상 받는 순간이었습니다. 더 나은 개발자, 더 좋은 개발자가 되고 싶어 꼭 합류하고 싶었던 우아한테크코스에 진짜 합류할 수 있는 기회가 주어진 것입니다.</p>
<p>차근차근 최종 코딩 테스트 안내를 읽고, 다가올 결전의 그 날을 위해 이전 기수 선배들이 만났던 최종 코딩 테스트 미션과 프리코스 미션들을 풀어보기로 결정했습니다. 생각보다 더 어려웠던 미션도 있고, 어느 정도 감이 잡히는 미션들도 있어 최종 코딩 테스트의 난이도가 예상되지 않았습니다. 5시간 제한을 지키기 위해 타이머를 켜고 미션을 구현해보니 생각보다 시간이 많이 부족했습니다.</p>
<p>프리코스와 다르게 최종 코딩 테스트는 5시간 밖에 주어지지 않고, 프리코스처럼 여유를 두고 생각하고, 개발할 시간이 없으니 전략을 잘 세워야겠다는 생각도 들었습니다. 그래서 저는 우아한테크코스 설명회, 코수타, 여러 선배들의 우아한테크코스 관련 회고글을 참고해 딱 한가지 전략을 세웠습니다. 이 전략은 최종 코딩 테스트 안내 메일에도 적혀있던 글이기도 합니다.</p>
<blockquote>
<p>일단 돌아가는 쓰레기를 만들고, 개선하는 방법은 우아한테크코스에서 배우자!</p>
</blockquote>
<p>프리코스를 스스로의 힘으로 완수했는지를 증명하는 자리라고 하니, 프리코스에서 학습한 개념들을 모두 녹여내려고 하려했지만, 그랬다가는 시간이 부족할 것 같았습니다. 그래서 저는 우아한테크코스에서 원하는대로, <strong>일단 돌아는 가는 쓰레기를 만들 각오</strong>로 최종 코딩 테스트를 준비했습니다. 미션을 잘 수행했는지 스스로 판단하기 위한 체크리스트, 부족한 개념들에 대한 학습, 객체 설계를 위한 노트까지, 코드 퀄리티만 제외하고 만반의 준비를 했습니다.</p>
<h2 id="선릉-캠퍼스에서의-5시간" class="heading">선릉 캠퍼스에서의 5시간</h2>
<p>전날 늦게까지 프리코스 미션들, 이전 최종 코딩 테스트 미션들을 다시 살펴보며 잠이 부족했음에도, 기상 알람이 울리기도 전에 눈을 떴습니다. 결전의 날이 밝은 것입니다. 정신을 맑게하기 위해 샤워도하고 빠진 준비물이 없나 두세번 검토하고 운명의 장소 우아한테크코스 선릉 캠퍼스로 향했습니다.</p>
<p>저는 지하철에 몸을 싣고 곰곰히 생각해봤습니다. 내가 이번에 실패한다 해도 내가 해온 노력이 물거품이 되는 것인가? 나는 우아한테크코스에 합류하지 못하면 실패한 사람인가? 물론 아쉽긴 하겠지만 제가 이번 최종 코딩 테스트에서 잃을 것은 없다는 생각을 하니 조금은 긴장이 풀렸습니다. 어떤 문제가 나올까, 얼머나 어려울까 같은 온갖 생각에 잠시 멍하니 서있었던 저를 태운 지하철은 어느덧 선릉역에 도착했습니다. 깊게 한숨을 내쉬고 "나는 할 수 있다, 나는 해낼 수 있다."고 자기 암시를 하며 선릉 캠퍼스로 걸어갔습니다.</p>
<h3 id="예상보다-더-무거웠던-캠퍼스-분위기">예상보다 더 무거웠던 캠퍼스 분위기</h3>
<p>선릉 캠퍼스에 도착해 엘레베이터에 탔습니다. 저와 같이 최종 코딩 테스트를 보러 온 예비 크루들이 굳은 얼굴로 함께 탔습니다. 대망의 캠퍼스 내부에 도착하자 코치들께서 밝은 얼굴로 맞아주셨습니다. 그렇게 무거운 분위기의 테스트는 아니구나라는 생각도 잠시, 강의실에 들어서자 잔뜩 긴장한 듯한 예비 크루들의 모습에 저도 덩달아 긴장되기 시작했습니다. 심지어, 테이블에 다닥다닥 붙어 앉아 코딩 테스트를 응시해야하다 보니 잘 집중할 수 있을지도 걱정됐습니다.</p>
<p>그래도 마음을 가다듬고 와이파이 연결 설정 등, 테스트 환경을 구축하고 문제 공개만 기다렸습니다. 1분이 1시간 같은 시간이 지나고, 문제가 공개된 후, 처음 미션을 마주한 저는 그렇게 어렵진 않겠다는 생각이 들었습니다. 오히려, 4주 차 프리코스 미션인 크리스마스 프로모션보다 구현 자체는 쉬울 수도 있을 것 같았습니다. 프리코스 때의 실수를 하지 않기 위해, 5기 크루였던 선배의 조언대로 요구사항을 여러번 읽고 분석해 구현 기능을 정리했습니다.</p>
<p>열심히 구현하고 나니, 주어진 테스트는 통과됐고, 해냈구나하는 생각이 들었습니다. 일단 돌아가는 쓰레기는 완성된 것입니다! 시계를 보니 3시간 정도 흐른 후였고, 여러 예외 상황에 대한 테스트를 작성해 나갔습니다. 그러나, 테스트를 작성하면서 예상보다 더 많은 오류가 발견됐고, 고치다보니 또 시간이 빠르게 흘렀습니다. 심지어, 잘 동작한다고 생각했던 기능이 잘못 구현됐다는 것을 발견했을 때는 정말 아찔했습니다.</p>
<p>여유를 부릴 시간이 없다는 것을 깨닫고 다시 열심히 개발했습니다. 발견한 오류를 모두 잡고, 테스트도 많이 작성한 다음 제출하려다가 또 다시 놓친 것을 발견했습니다. 프리코스에서는 없었던 어떻게 미션을 해결했는가를 설명하고, 다른 방법은 없었는지 구현한 방법과 다시 생각해본 방법의 차이는 무엇인지를 설명해야하는 요구사항을 발견한 것입니다.</p>
<p>온 몸에서 식은땀이 흐르기 시작했습니다. 남은 시간은 얼마 없는데, 차분히 생각하고 작성해야하는 문서가 완전히 비어있는 상황이었습니다. 그래도 두 번째 문항인 다른 방법을 생각하고 구현한 방식과의 차이점을 적는 것은 선택 사항이었기 때문에 첫 문항을 최대한 빠르게 써내려 갔습니다. 마감 마지막 1분 전, 아슬아슬하게 제출에 성공했고, 길다면 길 5시간이 순식간에 지나갔습니다.</p>
<h2 id="아쉬웠던-것들" class="heading">아쉬웠던 것들</h2>
<p>최종 코딩 테스트를 마치고 나서, 집으로 돌아가던 길, 조금 아쉽다고 느껴졌습니다. 조금 더 확실하게 요구사항을 파악하고 미션을 풀어나갔다면 어땠을까하는 생각이 들었습니다. 프리코스에서는 여러번 요구사항을 읽고 필요한 것들을 확실하게 챙겼지만 시간 여유가 없다고 생각한 최종 코딩 테스트에서는 그러질 못했다는 생각에 너무 성급했나라는 후회도 하게됐습니다.</p>
<p>또, 돌아가는 쓰레기를 만들어야겠다는 전략에 너무 매몰되어 유지보수하기 힘든 코드를 작성한 것은 아닌가라는 생각도 들었습니다. 오류가 발생하고나니 고치는데 너무 많은 시간을 들이게 됐습니다. 테스트 작성도 어려워 실제 기능 구현보다 부수적인 일에 더 많은 시간이 소모된 것 같아 아쉬웠습니다. 그래도 후회하지 않기로 했으니, 테스트는 통과했다는 점을 다행이라 생각하기로 했습니다.</p>
<p>최선을 다했고, 어떤 결과가 주어지든 받아들일 수 있을 것 같습니다.</p>
<h2 id="노력의-보상" class="heading">노력의 보상</h2>
<p>1차 심사 결과를 기다리던 날처럼 최종 코딩 테스트 결과를 기다리던 연말의 어느 날, 학교 도서관 안내 데스크에서 국가근로 근무를 하고 있었습니다. 운명의 시간 오후 3시, 어김 없이 제 메일함에는 최종 결과를 담고 있는 메일이 도착했고, 저는 후회하지 않겠다는 다짐이 무색하게 터질 것 같은 심장을 부여잡고 메일을 열어봤습니다.</p>
<img width="614" alt="woowacourse-accept-final" src="https://github.com/hangillee/coderoad.kr/assets/14046092/78bcff90-a3f0-4ff5-8d43-2c7e65f44393">
<div align="center"><I>나는 해냈다!</I></div><br/>
<p>도서관이라 소리는 크게 지르지 못했지만 의자에서 펄쩍 뛰어오르고, 주먹을 꽉쥐며 온 몸으로 기쁨을 표현했습니다. 아마 이 순간의 저를 누군가 봤다면 미쳤다고할지도 모르겠습니다. 제 인생에 있어 두 번 다시 없을 좋은 기회를 잡았다는 기쁨과, 최고의 동료들과 함께할 수 있다는 기쁨, 그토록 바랐던 오로지 프로그래밍에만 몰두할 수 있는 환경을 누릴 수 있다는 기쁨까지, 살면서 이렇게 기뻤던 순간은 손에 꼽을 것 같습니다.</p>
<p>사실, 작성해야 했던 문서는 선택 사항이긴 하지만 비워둔 채로 제출했고, 프리코스 커뮤니티(디스코드)에서는 저보다 더 멋진 방식으로 구현해낸 사람들의 이야기를 보고 살짝 마음을 놓고 있었습니다. 그러나 제 진심이 통했는지, <strong>당당하게 우아한테크코스 6기의 크루가 되었습니다.</strong> 저는 저에게 특출난 재능이 없다고 생각했습니다. 그저 관심이 조금 더 많아서, 특성화 고등학교에 진학했고, 동기들보다 더 빨리 프로그래밍을 접했을 뿐입니다. 단순히 프로그래밍이 재밌어서, 개발 동아리의 회장을 했고, 전공을 소프트웨어공학으로 정했습니다.</p>
<p>저보다 훨씬 개발에 재능이 넘치고, 프로그래밍을 잘하고, CS 지식이 많은 사람도 있지만 제가 합격한 이유를 감히 추측해보자면, "한가지 일에 몰입한 경험"이 아닐까 싶습니다. 우아한테크코스 6기 지원하면서 작성한 자기소개서에는 제가 1년이라는 시간을 모두 투자한 경험을 적었습니다. 우아한테크코스가 원하는 교육 대상자는 <strong>한가지 일에 몰입해 성공한 경험</strong>이 있어야 합니다. 저는 다행히 프로그래밍이 좋아서 살아온 삶에 이런 경험이 있었고, 할 말이 많았습니다.</p>
<p>그래서 저는 합격한 것 같습니다. 만약 이 글을 읽으실 미래의 우아한테크코스 예비 크루께서도 꼭, 한가지 일에 몰두해보는 경험을 가지셨으면 좋겠습니다. 그 일이 꼭 개발과 관련된 일일 필요도 없습니다. 저도 해냈으니 여러분도 할 수 있습니다.</p>
<p>정말 감사합니다! 우아한테크코스!</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[프리코스 4주 차를 돌아보며]]></title>
    <link>https://blog.hangilog.kr/precourse-week4</link>
    <pubDate>2024-01-13</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/precourse-week4</guid>
    <description>
    <![CDATA[프리코스의 피날레, 크리스마스 프로모션]]>
    </description>
    <content:encoded>
      <![CDATA[<blockquote>
<p>해당 미션은 <code>private</code> 저장소에 커밋하는 미션이었습니다. 따라서, 코드를 공개하지 않기로 결정했습니다.</p>
</blockquote>
<h2 id="프리코스-4주-차-미션---크리스마스-프로모션" class="heading">프리코스 4주 차 미션 - 크리스마스 프로모션</h2>
<p>이메일을 열어보고 마주한 4주 차 미션은 이전의 프리코스 미션들과 첫인상부터 완전히 달랐습니다. 이전에는 없었던 이미지를 활용한 길고 긴 요구사항들의 압박감과 <code>private</code> 저장소로 미션을 진행하고 제출해야하는 생소함에 미션 시작부터 막막해졌습니다.</p>
<h3 id="요구사항-분석부터-난관이었다">요구사항 분석부터 난관이었다.</h3>
<p>이번 미션의 요구사항은 이메일 형식으로 주어졌습니다. 지난 3주 간의 미션에서는 그래도 요구사항이 어느 정도 이해되고, 어떤 기능을 구현하고 어떻게 객체를 설계해야할지 감이 잡혔지만 이번 미션은 이 단계부터 많이 어려웠습니다. 요구사항을 열심히 읽어봐도 도대체 뭘 구현하길 원하는 건지 한번에 이해되지 않아서 몇번이고 읽어봤던 것 같습니다.</p>
<p>솔직히 말해서, 저는 기능 구현 중간에 객체 설계 자체를 완전히 갈아엎을 정도로 처음에는 요구사항을 이해하지 못했습니다. 요구사항을 읽으면 읽을 수록 머릿속이 복잡해지고, 객체의 역할과 책임은 두루뭉실해졌습니다. 대략적으로 설계도를 그려봐도 명쾌한 답이 나오지 않았습니다. 거기다 지난 3주 간의 모든 요구사항 상의 구현 제약(else문을 사용할 수 없다든지)을 포함하고 있었기 때문에 고려해야할 것도 매우 많았습니다.</p>
<p>이런 이유로 저는 이번 미션이 최종 코딩 테스트로 가는 마지막 관문이겠다는 생각이 들었습니다. 이번 미션의 제출에 성공하느냐 실패하느냐에서 최종 코딩 테스트 기회가 주어지느냐 마느냐가 결정될 것 같았습니다. 마치 우아한테크코스에서 저에게 그동안 프리코스를 얼마나 성실히 했는지를 물어보는 것 같았습니다. 부랴부랴 이전 미션들을 어떻게 구현했는지 살펴보며 활용할 수 있을만한 지식들을 학습하기 시작했습니다.</p>
<p>생소한 테스트 작성, 구현 기능의 잦은 수정, 그로 인해 터져 나오는 버그까지, 수많은 난관들이 절 괴롭혔습니다. 그래도 저에게만 어려운게 아니라는 마음가짐으로 차분히 미션을 진행했고, 다행히 마감 기한에 맞춰 제출에 성공했습니다. 미리 이번 미션의 총평을 하자면, 다음과 같습니다.</p>
<blockquote>
<p><strong>과연 최종 테스트도 이렇게 어려울까?</strong></p>
</blockquote>
<p>왜 이렇게 생각했는지, 코드를 모두 공개할 순 없지만, 프리코스의 모든 미션에서 매번 등장했던 요구사항인 <code>기능을 구현하기 전 README.md에 구현할 기능 목록을 정리</code>하기의 <strong>README.md</strong> 전문으로 그 이유를 대신하겠습니다.</p>
<details>
<summary><b>README.md</b></summary>
<pre class="language-markdown"><code class="language-markdown code-highlight"><span class="code-line"><span class="token title important"><span class="token punctuation">#</span> 12월 이벤트 플래너</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token title important"><span class="token punctuation">##</span> 구현 기능 목록</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token title important"><span class="token punctuation">###</span> Main</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token list punctuation">-</span> Application
</span><span class="code-line">  <span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`EventController`</span>를 통해 12월 이벤트 플래너를 시작한다.
</span><span class="code-line">
</span><span class="code-line"><span class="token title important"><span class="token punctuation">###</span> Model</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token list punctuation">-</span> Badge
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 제공할 이벤트 배지의 열거형이다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 제공 받은 총 혜택 금액에 따라 이벤트 배지를 부여한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Bounds
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 여러 조건 기준에 대한 정보를 제공하는 열거형이다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 이벤트 기간의 첫 번째 날과 마지막 날에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 크리스마스 날짜에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 이벤트 적용을 위한 최소 주문 금액에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 주문 메뉴의 최소 주문 수량에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 주문 메뉴의 최대 주문 수량에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 증정 메뉴의 기준 총 주문 금액에 대한 정보를 제공한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Date
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 방문 날짜 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 숫자가 아니라면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 12월의 1일부터 31일 사이가 아니라면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 크리스마스 이전인지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 평일인지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 주말인지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 특별 할인일인지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜를 제공한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Discount
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 할인 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜와 주문 메뉴에 따른 할인 내역에 대한 정보를 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜와 주문 메뉴에 따른 총 할인 금액을 제공한다.
</span><span class="code-line"><span class="token list punctuation">-</span> DiscountCondition
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 할인 정책 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 방문 날짜가 현재 정책이 적용 가능한지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 적용된 할인 금액을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> ChristmasDiscount
</span><span class="code-line">    <span class="token list punctuation">-</span> 크리스마스 디데이 할인 정책을 적용하고 할인 금액과 혜택 내역을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> SpecialDiscount
</span><span class="code-line">    <span class="token list punctuation">-</span> 특별 할인 정책을 적용하고 할인 금액과 혜택 내역을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> WeekdayDiscount
</span><span class="code-line">    <span class="token list punctuation">-</span> 평일 할인 정책을 적용하고 할인 금액과 혜택 내역을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> WeekendDiscount
</span><span class="code-line">    <span class="token list punctuation">-</span> 주말 할인 정책을 적용하고 할인 금액과 혜택 내역을 반환한다.
</span><span class="code-line"><span class="token list punctuation">-</span> EventDay
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 이벤트 적용 날짜 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 날짜가 이벤트에 적용되는지 판별한다.
</span><span class="code-line"><span class="token list punctuation">-</span> EventPlanner
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 이벤트 플래너 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴 목록 문자열을 생성하고 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 주문 메뉴가 지정된 형식을 따르지 않으면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 입력한 주문 메뉴가 중복되면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴에 대한 혜택 내역을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액에 대한 증정 메뉴의 정보를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액에 대한 증정 메뉴의 가격을 반환한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Gift
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 증정 메뉴 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액에 따라 증정 메뉴의 정보를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액에 따라 증정 메뉴의 가격을 반환한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Menu
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 선택할 메뉴에 대한 정보를 나타내는 열거형이다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 주문 금액을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴가 존재하지 않으면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴가 음료 밖에 없다면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 종류별 주문 개수를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴가 존재하는지 판별한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 이름을 제공한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 종류에 대한 정보를 제공한다.
</span><span class="code-line"><span class="token list punctuation">-</span> Message
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자에게 정보를 제공하기 위한 메시지의 열거형이다.
</span><span class="code-line"><span class="token list punctuation">-</span> Order
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 주문서 역할을 담당한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 가격에 대한 정보를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 종류에 대한 정보를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴가 존재하지 않으면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 개수가 최소 주문 수량보다 적으면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 개수가 최대 주문 수량보다 많으면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 음료만 주문했다면 예외가 발생한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 총 가격을 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴의 종류별 주문 개수를 반환한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 사용자가 주문한 메뉴 목록을 문자열 형태로 반환한다.
</span><span class="code-line">
</span><span class="code-line"><span class="token title important"><span class="token punctuation">###</span> View</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token list punctuation">-</span> InputView
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 사용자 입력을 받는 UI 역할을 담당한다.
</span><span class="code-line"><span class="token list punctuation">-</span> OutputView
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너에서 사용자에게 이벤트 적용 결과를 보여주는 UI 역할을 담당한다.
</span><span class="code-line">
</span><span class="code-line"><span class="token title important"><span class="token punctuation">###</span> Controller</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token list punctuation">-</span> EventController
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너의 전체적인 흐름을 제어한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`InputView`</span>로부터 사용자의 입력을 받는다.
</span><span class="code-line">  <span class="token list punctuation">-</span> 12월 이벤트 플래너의 핵심 로직들을 모델을 통해 수행한다.
</span><span class="code-line">  <span class="token list punctuation">-</span> <span class="token code-snippet code keyword">`OutputView`</span>를 통해 12월 이벤트 플래너의 결과를 출력한다.
</span></code></pre>
</details>
<p>읽기도 벅차며, 한번에 이해하기도 쉽지 않은 이 많은 양의 기능들을 처음부터 완벽하게 설계하려했던 제 자신이 바보 같아지기도 했습니다. 뭔가 다른 방법으로 구현했다면 더 빠르고 간단하게 구현할 수 있지 않았을까 하는 생각도 들었습니다. 앞선 회고들에서도 말했듯이, 분명히 더 나은 방법은 존재하겠지만, 기한을 맞추느라 급급했던 저는 스스로 고통받으며 이번 미션을 끝냈습니다.</p>
<h2 id="객체의-분리-역할과-책임을-다시-생각하기" class="heading">객체의 분리, 역할과 책임을 다시 생각하기</h2>
<p>이번 미션에서 끝까지 고민했던 부분은 <strong>내가 정말 객체의 역할과 책임을 잘 분배한 걸까?</strong> 였습니다. 미션 구현 도중 한번 몽땅 뒤집어 엎은 이유이기도 합니다. 처음 생각한 구현 기능 목록에 맞춰서 객체를 설계하고 기한에 쫓겨 급하게 구현하다보니 객체가 점점 비대해졌습니다. 한 객체가 너무 많은 기능을 가지고 있게 되었고 객체 간의 의존성도 많이 복잡해졌습니다. 사소한 수정에 영향을 받아 함께 수정되어야 하는 객체가 많아지니 유지보수는 커녕 버그도 제대로 잡을 수 없게 되었습니다.</p>
<p>결국, 아무리 IDE의 디버깅 기능을 이용해 버그를 잡아보려해도 어디서부터 구현이 잘못된 건지 찾을 수 없을 지경이 되었습니다. 이렇게 시간을 끌어서는 기한 안에 미션을 완성할 수 없겠다는 생각이 들었고, 저는 객체의 설게, 역할과 책임의 분배부터 잘못되었다고 판단해 처음부터 다시하기로 결정했습니다.</p>
<p><strong>괜히 요구사항에서 구현하기 전 구현할 기능 목록을 README에 정리하라는 내용이 있는게 아님을</strong> 뼈저리게 느끼고 다시 객체 설계를 시작했습니다. 좀 더 작은 객체로 나눌 수는 없는지, 각 기능이 올바른 객체에게 주어졌는지, 객체가 다른 객체에게 과하게 의존적이진 않은지, 스스로 질문하며 설계해보니 처음 생각했던 구현할 객체 목록보다 훨씬 많아졌습니다. (이 과정의 결과물은 위의 README.md를 참고해주세요!)</p>
<p>약 6시간 남짓 남았을 무렵 처음부터 다시 구현하기 시작했고, 제자리에서 한 번도 움직이지 않고 개발만 해 마감 기한 직전에 제출에 성공했습니다. 미션을 끝내고 나선, 도대체 이번 미션이 저에게 뭘 물어보고 싶은 건지 천천히 고민해봤습니다. 물론 구현해야 하는 기능들이 난이도가 높았던 것은 맞지만 그렇다고 <strong>"너가 얼마나 개발을 잘하는지 보자!"</strong> 는 아닌 것 같았습니다.</p>
<p>이전의 미션들과 달리 복잡하고 긴 요구사항 전달 방식, 필요하다고 판단되는 객체의 수, 제출 방식의 차이 등을 고려해봤을 때, 얼마나 깊게 생각하고, 생각을 잘 현실에 실체화할 수 있는지를 묻는 것 같았습니다. 글을 읽고, 자신만의 생각으로 정리하고, 이를 코드에 옮겨 동작하도록 하는 것이 프로그래머라고 본다면, 이번 미션은 <strong>"너가 정말 프로그래머가 될 수 있을까?"</strong> 를 묻는 것이라고 생각합니다.</p>
<p>그렇게 본다면, 전 아직 부족한 프로그래머인 것 같지만 말입니다.</p>
<h2 id="프리코스를-모두-마치고" class="heading">프리코스를 모두 마치고</h2>
<p>이번 미션을 끝으로 프리코스는 모두 끝이 났습니다. 한 달이라는 시간 동안 학업과 병행하며 1주일 안에 시간을 짜내고 머리를 굴리며 주어진 미션을 완성하는 일은 꽤 색다른 경험이었던 것 같습니다. 프리코스 전의 프로그래밍 경험이라고 해봐야 제 머릿속의 아이디어를 코드로 옮기는 것이 전부였으며, 무엇인가 문제를 맞추는 개념의 개발은 알고리즘 풀이 뿐이었습니다.</p>
<p>그러나 우아한테크코스 프리코스는 누군가가 작성한 요구사항을 해석하고, 나만의 방식으로 이를 구현하기 위해 고민하고, 내 아이디어가 맞는지 평가받는 전혀 다른 방식의 프로그래밍이었습니다. 그동안 참여했던 팀 프로젝트, 경진대회 모두 제가 아이디어를 내고, 제가 아이디어를 구체화하고, 제 생각대로, 제 방식대로 팀원에게 할일을 분배했었습니다. 그러나 프리코스는 다른 사람이 원하는 방식이 아닐 경우 잘못된 구현이 될 수 있다는 점이 새롭게 느껴졌습니다.</p>
<p><code>switch-case</code> 구문과 <code>else</code> 예약어를 사용하지 못했던 것, 예외 처리, 테스트 작성, 코드의 <code>indent</code>(들여쓰기)도 신경써야 하고 내가 무엇을 구현할 것인지 문서화해야 했던 모든 제약 사항들이 처음에는 불편하고 귀찮았습니다. 그러나 프리코스가 모두 끝난 지금 돌아보면 이런 제약들이 오히려 좋은 코드를 쓸 수 있도록 돕는 규칙이라는 생각이 들었습니다.</p>
<p>그래서 저는 우아한테크코스가 <strong>누구보다도 잘하는 개발자</strong>가 아닌 <strong>함께하기 좋은 개발자</strong>를 만드는 곳인 것 같습니다. 제 목표가 <strong>좋은 개발자</strong>인 만큼 꼭 우아한테크코스에 함께하고 싶습니다.</p>
<h2 id="그리고-저는-해냈습니다" class="heading">그리고 저는 해냈습니다.</h2>
<img width="620" alt="woowacourse-accept-firststep" src="https://github.com/hangillee/coderoad.kr/assets/14046092/6c078feb-7c6e-49a0-9c41-60e802cf0cdf">
<p>저를 좋게 봐주셨는지 최종 코딩 테스트 기회를 받았고, 이에 대한 회고는 다음 글에 있습니다. <a href="https://blog.coderoad.kr/woowacourse-final-test/" target="_blank" rel="noopener noreferer">우아한테크코스 최종 코딩 테스트 회고</a></p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[프리코스 3주 차를 돌아보며]]></title>
    <link>https://blog.hangilog.kr/precourse-week3</link>
    <pubDate>2023-12-21</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/precourse-week3</guid>
    <description>
    <![CDATA[열거형을 다시 알게 해준 로또 게임]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="프리코스-3주-차-미션---로또-게임" class="heading">프리코스 3주 차 미션 - 로또 게임</h2>
<p>다소 늦은 감이 없지 않아 있지만 프리코스 3주 차 미션의 회고를 작성해보고자 합니다. 11월과 12월, 기말고사 준비, 프로젝트 과제와 프리코스를 병행하려니 눈코 뜰 새 없이 지나간 것 같습니다.</p>
<p>3주 차 미션은 로또 게임을 구현하는 것이었습니다. 이번에는 '간단한'이라는 말은 없는 걸로 보아 확실히 1주나 2주차 과제보다 훨씬 까다롭겠다는 생각이 들었습니다. 특히, 프로그래밍 요구 사항에서 추가된 요구 사항은 조금 당황스러웠습니다. 절 당황시켰던 요구 사항은 바로, <strong>Java Enum을 적용한다.</strong> 와 <strong>도메인 로직에 단위 테스트를 구현해야 한다.</strong> 라는 요구 사항이었습니다. 이 두 요구 사항을 적용하려면 제가 앞선 프리코스 미션을 수행하면서 자주 활용했던 문제 해결 전략을 수정해야 했습니다.</p>
<img width="775" alt="added_requirement" src="https://github.com/hangillee/coderoad.kr/assets/14046092/698ad591-f5e2-48ab-94bc-979a0feaffa3">
<div align="center"><I>3주 차 미션이 막막해졌던 2개의 요구 사항들</I></div><br/>
<h3 id="열거형-그냥-상수-모음-아닌가요">열거형? 그냥 상수 모음 아닌가요?</h3>
<p>추가된 요구 사항들을 준수하기 위해서는 먼저, <strong>도메인 설계 과정부터 고쳐야 했습니다.</strong> 그동안 저는 Java의 Enum, <strong>열거형</strong>을 단순히 코드에서 자주 사용되는 매직 넘버(Magic Number)나 문자열 리터럴(String Literal)값들을 상수로 정의해 하나의 클래스에서 관리하기 위한 수단으로만 생각했습니다. 그래서 열거형에는 단순히 특정 값을 대신하는 상수와 상수에 정의되어 있는 값을 얻기 위한 메소드만 두었습니다. 즉, 열거형에 무엇인가 도메인 로직을 둔다는 것은 미처 생각하지 못한 것입니다.</p>
<blockquote>
<p>저는 매직 넘버(Magic Number)와 문자열 리터럴(String Literal)을 그대로 사용하는 것이 대표적인 안티 패턴이라고 생각합니다. <strong>우아한테크코스에서도 숫자나 문자열 등의 값을 하드 코딩하지 말고 상수로 정의할 것을 권장</strong>하고 있습니다.</p>
</blockquote>
<p>이번 미션 전까지 열거형에 대해 오해하고 있었기 때문에 저는 상수를 모아두기만 하는 열거형이 굳이 필요한가에 대한 의문이 들었습니다. 어차피 상수는 해당 상수를 활용하는 클래스에서 바로 정의할 수 있는데 따로 '열거형'의 형태로 정의할 필요를 느끼지 못했습니다.</p>
<p>필요성을 느끼지 못했으니 자연스럽게 다른 프리코스 미션이나 참여했던 여러 프로젝트에서 열거형을 잘 사용하지 않았고 효율적인 사용법도 당연히 알지 못했습니다. 그런 상황에서 좋든 실든 요구 사항을 준수하기 위해 열거형을 무조건 활용해야 했습니다. 그래서 저는 열거형에 대한 오해를 풀고자 처음부터 다시 열거형을 학습하기로 결정했습니다.</p>
<h3 id="열거형의-진가를-찾아서">열거형의 진가를 찾아서</h3>
<p>지금까지는 앞에서 계속 말했던 것처럼 열거형을 단순히 상수를 나열하는데 목적을 두고 도메인을 설계했습니다. 즉, 핵심 모델들에서 사용된 매직 넘버와 문자열 리터럴을 상수로 대체하기 위해서<strong>만</strong> 열거형을 사용했습니다. 물론, Java에서 열거형이 서로 관련 깊은 여러 상수들의 집합인 것은 맞지만, <strong>프리코스에서 요구하는 열거형의 사용이 단순히 상수 집합으로서의 사용이 아닐 것 같았습니다.</strong></p>
<p>그래서 개발자들의 영원한 동반자, 구글링을 통해 왜 열거형을 사용해야 하는지, 어떻게 해야 잘 사용할 수 있는지 검색하던 중, 우아한 기술 블로그의 포스트를 찾게 되었습니다. 바로 <a href="https://techblog.woowahan.com/2527/" target="_blank" rel="noopener noreferer">Java Enum 활용기</a>입니다. 이 포스트에는 무려 6년 전인 2017년에, 지금의 저와 같은 고민을 하셨던 선배 개발자께서 스스로 고민하고 학습하신 내용이 담겨있었습니다. 포스트를 모두 읽고 나서, 제가 정말 Java Enum의 진정한 장점을 단 하나도 제대로 활용하지 못하고 있구나라는 생각이 들었습니다.</p>
<p>6년 전부터 선배 개발자분들은 좋은 이정표를 제시해주셨지만 저는 어느 하나 제대로 알고 있지 못했습니다. 특히, 열거형은 잘 사용하지 않겠지라는 안일하고 위험한 생각을 가지고 제대로 학습하지 않았던 제 태도가 부끄러워졌습니다.</p>
<blockquote>
<p>이 회고 포스트는 기술의 설명 보다는 제가 프리코스 미션을 해결하며 느꼈던 점을 위주로 작성하고자 합니다. 열거형을 사용해야 하는 자세한 이유는 위의 우아한 기술 블로그의 포스트를 직접 읽어보시는 것을 추천드립니다!</p>
</blockquote>
<p>위 블로그 포스트에서 읽은 <strong>Java의 Enum은 완전한 기능을 갖춘 클래스</strong>라는 구절에 제 뒤통수가 얼얼했습니다. 열거형도 Java 클래스라면 당연히 상태(상수)를 가지고 있으며 이를 활용하는 여러 행동도 수행할 수 있겠다는 생각이 들었습니다. 저는 어쩌면 가장 기본 중의 기본인 객체지향 프로그래밍을 등한시하고 있었던 것 같습니다.</p>
<p>이때부터 저는 열거형도 하나의 도메인으로 생각하고 상수값들과 관련된 도메인 로직을 열거형 내부에 구현하기 시작했습니다. 예를들어, 이번 미션인 로또 게임에서는 정수형 당첨금 정보를 상수로 정의한 <code>Prize</code> 열거형에서 일치한 번호 개수와 2등 여부를 전달받아 그에 맞는 당첨금을 반환하는 도메인 로직을 구현했습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getPrize</span><span class="token punctuation">(</span><span class="token keyword">int</span> winCount<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isSecond<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line">            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>prize <span class="token operator">-></span> prize<span class="token punctuation">.</span>winCount <span class="token operator">==</span> winCount<span class="token punctuation">)</span>
</span><span class="code-line">            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>prize <span class="token operator">-></span> prize<span class="token punctuation">.</span>isSecond <span class="token operator">==</span> isSecond<span class="token punctuation">)</span>
</span><span class="code-line">            <span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">            <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>NONE<span class="token punctuation">)</span>
</span><span class="code-line">            <span class="token punctuation">.</span><span class="token function">getPrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>그렇게 깔끔한 코드라고는 할 수 없지만 저의 첫 열거형 내부의 도메인 로직 코드입니다. <code>Prize</code> 열거형 객체는 로또 당첨금에 대한 정보를 저장하고 있기 때문에, <strong>당첨 등수에 따른 당첨금 정보를 다른 객체에 제공해야 하는 책임</strong>이 있습니다. 따라서, <strong>다른 객체와의 협력을 통해 로또 당첨금 정보를 제공하는 역할을 가지도록 설계</strong>했습니다. 드디어 역할, 책임, 협력 관계가 적절하게 갖춰진, 제가 공부한 객체지향 프로그래밍에 알맞은 도메인 설계가 이뤄졌습니다.</p>
<p><strong>Java Enum을 적용한다.</strong> 라는 추가 요구 사항 덕분에 Java 도메인 설계에서 더 유연한 사고가 가능해진 것 같습니다. 개인적으로 3주 차 미션에서 가장 크게 얻어가는 점입니다.</p>
<h3 id="단위-테스트는-또-무엇인가">단위 테스트는 또 무엇인가...</h3>
<p>열거형을 어떻게 사용해야 할지 감이 잡히면서 추가된 요구 사항 중 하나는 그래도 잘 지켜가며 개발할 수 있었습니다. 이대로만 하면 무난하게 미션을 완수하고 제출할 수 있을 것 같았습니다. 그러나, <strong>도메인 로직에 단위 테스트를 구현해야 한다.</strong> 라는 하나 남은 요구 사항은 제 생각보다 더 복잡했습니다.</p>
<p>요구 사항을 준수하기 위해 가장 먼저, 단위 테스트에 대해서 조금 더 학습했습니다. 다음은 AWS의 문서 <a href="https://aws.amazon.com/ko/what-is/unit-testing/" target="_blank" rel="noopener noreferer">유닛 테스트란?</a>에서 발췌한 단위 테스트에 대한 설명입니다.</p>
<blockquote>
<p>단위 테스트는 코드의 가장 작은 기능적 단위를 테스트하는 프로세스입니다.</p>
</blockquote>
<p>즉, 단위 테스트는 각 객체가 제공하는 <strong>최소 단위의 기능을 테스트하는 일련의 과정</strong>입니다. 예를 들어, 두 정수를 더하는 기능(메소드)가 있다면, 두 양의 정수, 두 음의 정수, 양과 음의 정수끼리 더하는 모든 경우를 테스트하는 것이 단위 테스트입니다. 다음은 앞서 설명한 단위 테스트의 예제 코드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Test</span>
</span><span class="code-line"><span class="token keyword">void</span> 두_양의_정수를_더한다<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// given</span>
</span><span class="code-line">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// when</span>
</span><span class="code-line">    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Calculator</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// then</span>
</span><span class="code-line">    <span class="token function">assertThat</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Test</span>
</span><span class="code-line"><span class="token keyword">void</span> 두_음의_정수를_더한다<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// given</span>
</span><span class="code-line">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// when</span>
</span><span class="code-line">    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Calculator</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// then</span>
</span><span class="code-line">    <span class="token function">assertThat</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Test</span>
</span><span class="code-line"><span class="token keyword">void</span> 양의_정수와_음의_정수를_더한다<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// given</span>
</span><span class="code-line">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// when</span>
</span><span class="code-line">    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">Calculator</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// then</span>
</span><span class="code-line">    <span class="token function">assertThat</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>단위 테스트가 어떤 것인지는 대략적으로 파악했고, 테스트 코드도 앞선 미션에서 작성해봤기 때문에 쉽게 작성할 수 있을 줄 알았습니다. 그러나 이번에 주어진 요구 사항은 조금 달랐습니다. 일단, UI 로직에서 사용한 <code>System.in</code>, <code>System.out</code>과 같은 입출력 클래스는 테스트에서 활용할 수 없었습니다. 2주 차 미션에서는 사용자 입력에 따라 동작하는 로직에 대한 검증을 <code>System.in</code>을 통해 직접 입력값을 설정해주는 방식으로 테스트를 작성했습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Test</span>
</span><span class="code-line"><span class="token keyword">void</span> 사용자는_쉼표를_기준으로_구분되는_자동차_이름들을_입력한다<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// given</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setIn</span><span class="token punctuation">(</span><span class="token function">createInputStream</span><span class="token punctuation">(</span><span class="token string">"pobi,woni,jun"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// when, then</span>
</span><span class="code-line">    <span class="token function">assertThat</span><span class="token punctuation">(</span>raceView<span class="token punctuation">.</span><span class="token function">inputNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token string">"pobi,woni,jun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>그런데, 이번 미션에서는 이 방식이 금지되어버린 것입니다. 지금까지 구현해 온 도메인 로직에서 제공하는 기능은 단위 테스트 작성이 불가능했습니다. 하지만 사용자 입력에 대한 검증도 필수이기 때문에 단위 테스트를 작성하지 않을 수도 없었습니다. 그래서 저는 지금까지 작성한 핵심 도메인들의 코드를 몽땅 뜯어고치기로 결정했습니다.</p>
<p>2주 차 미션에서는 <code>View</code> 계층에서부터 입력값에 대한 검증을 처리했습니다. 저는 UI를 담당하는 객체에서 입력값을 검증하면 프로그램 전반에서 자동으로 검증된다고 생각했습니다. 그런데, 막상 핵심 도메인 로직에서 잘못된 값을 통한 예외 발생 단위 테스트를 작성하려고보니 예외를 발생시키고 이를 검증할 방법이 없었습니다. 실제로 <a href="https://github.com/hangillee/java-racingcar-6/tree/hangillee/src/test/java/racingcar/model" target="_blank" rel="noopener noreferer">자동차 경주 테스트 코드</a>를 보면, <code>assertThatThrownBy().isInstanceOf();</code>과 같이 예외 발생을 테스트하는 코드가 없습니다.</p>
<p>이 문제를 해결하기 위해 저는 핵심 도메인을 더 세분화하고, 입력값에 대한 검증을 UI가 아니라 해당 입력값을 사용하는 도메인에 위임했습니다. 해당 리팩토링의 <a href="https://github.com/hangillee/java-lotto-6/commit/2594ead2d3ba8eca8be9efeeb626d3621e7bb9ac" target="_blank" rel="noopener noreferer">커밋 내역</a>입니다. 이렇게 코드를 리팩토링하고나니 단위 테스트를 작성하는 것이 훨씬 수월해졌습니다. UI는 오로지 입출력만 담당하게 되면서 요구 사항대로 UI에 대한 테스트도 작성하지 않을 수 있게 됐고, 각 핵심 도메인 객체들이 스스로를 검증하도록 하는 더 객체지향다운 설계를 할 수 있게 됐습니다.</p>
<h2 id="더-나은-방법은-무조건-있다" class="heading">더 나은 방법은 무조건 있다!</h2>
<p>이번 미션을 수행하면서 가장 절실하게 느낀 점은 <strong>'내가 생각한 것보다 더 나은 방법은 무조건 있다.'</strong> 입니다. 제출하신 코치님들께서는 간단하다고 주장하시는 프리코스 미션마저 여러 시행착오를 겪는 것을 보면 제 실력은 아직 주니어 개발자 근처도 가지 못한 햇병아리입니다. 그렇기 때문에 저는 제가 설계한 도메인 로직들은 크던 작던 분명히 개선할 점이 존재한다고 생각합니다. 더 나은 방법을 찾고, 이를 적용하는 과정이 저를 더 나은 개발자로 만들어줄 것이라고 믿습니다.</p>
<p>실제로 이번 미션에서 더 나은 Java Enum 사용법, 단위 테스트 작성을 위한 도메인 설계 개선점 등을 배울 수 있었고, 제 코드를 개선하는 경험을 했습니다. 더 나은 방법은 무조건 있습니다. 이를 찾아내고 내 것으로 만들면 성장하지 않을 수 없을 것입니다. 결국 우아한테크코스에서 강조하는 몰입의 경험이 이렇게 내가 쓴 코드를 개선하기 위해 그 너머를 바라보는 것을 말하는게 아닐까하는 생각도 들었습니다. 프로그래밍에 몰입하지 않고서는 한번 작성한 코드를 다시 읽기란 쉽지 않은 일이기 때문이니까요. :)</p>
<h2 id="repository" class="heading">Repository</h2>
<p><a href="https://github.com/hangillee/java-lotto-6/tree/hangillee" target="_blank" rel="noopener noreferer">로또 게임 - hangillee</a></p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[프리코스 2주 차를 돌아보며]]></title>
    <link>https://blog.hangilog.kr/precourse-week2</link>
    <pubDate>2023-11-03</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/precourse-week2</guid>
    <description>
    <![CDATA[테스트와 씨름했던 자동차 경주 게임]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="프리코스-2주-차-미션---자동차-경주-게임" class="heading">프리코스 2주 차 미션 - 자동차 경주 게임</h2>
<p>1주 차 미션이 끝나고 <a href="https://blog.coderoad.kr/precourse-week1" target="_blank" rel="noopener noreferer">회고</a>를 작성 중이었던 10월 26일 목요일 오후 3시, 2주 차 미션에 대한 안내가 메일로 도착했습니다. 1주 차 미션을 무사히 완료한 프리코스 참가자들에게 주어진 2주 차 미션은 '초간단' 자동차 경주 게임이었습니다. 물론, 요구 사항에 적힌 내용은 전혀 간단하지 않았습니다. 1주 차보다 주어진 요구 사항도 많아졌고 신경 써야 하는 부분이 더 늘어났습니다. 그래도 1주 차 미션 이후, 프리코스 미션 진행 방식에 감이 잡힌 덕분에 구현 계획을 빠르게 세울 수 있었습니다.</p>
<p>먼저, 구현 기능 목록을 작성하고 이를 바탕으로 클래스들을 구현하기 시작했습니다.</p>
<img width="492" alt="function_list" src="https://github.com/hangillee/coderoad.kr/assets/14046092/ba049ed8-1c1b-4b48-8e02-1aecee16f9ad">
<div align="center"><I>구현 기능 목록을 가장 먼저 작성</I></div>
<p>확실히 1주 차와 다르게 머릿속에 있던 클래스 설계도를 문서화 해두니 구현하면서 혼동이 오는 일도 없었고, 더 빠르게 구현할 수 있었습니다. 예상외로 자동차 경주 게임 자체는 구현이 정말 빨리 끝났습니다.</p>
<h3 id="구현은-빠르게-끝났지만">구현은 빠르게 끝났지만...</h3>
<p>그러나 정말 큰 난관은 자동차 경주 게임 구현이 아니었습니다. 2주 차에 추가된 요구 사항들이야말로 저에게 주어진 진정한 미션이었습니다. 가장 먼저 저를 괴롭혔던 요구 사항은 기능 단위 커밋이었습니다. 구현이 정말 빨리 끝났기 때문에, 오히려 기능 단위 커밋을 어떻게 해야 할지 애매했습니다. 이미 모든 기능이 1차적으로 완성된 상황에서 공통된 역할과 책임으로 묶인 모델 단위로 커밋을 해야 하는 건지, 아니면 정말 '기능'을 담당하는 메소드 단위로 커밋을 해야 하는 건지 고민이 많았습니다.</p>
<img width="403" alt="car_model_commit" src="https://github.com/hangillee/coderoad.kr/assets/14046092/ba33045d-91a7-4226-b494-8401f80e6507">
<div align="center"><I>모델(객체) 단위로 커밋했던 2주 차 미션</I></div>
<p>그래서 저는 기능 단위 커밋을 '역할과 책임 단위 커밋'으로 제 나름대로 해석했습니다. 객체지향 프로그래밍이 역할과 책임을 가지는 자율적인 객체들의 협력을 통해 사용자가 원하는 결과를 도출하는 것이므로, 객체의 <strong>역할과 책임</strong>이 곧 <strong>기능</strong>이라고 생각했습니다. 더군다나, <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>의 <strong>단일 책임 원칙</strong>을 지키기 위해서는 한 모델(객체)이 하나의 책임(기능)만 가지고 있어야 하므로, 기능 단위 커밋은 결국 모델 단위로 커밋하는 것과 같다고 볼 수 있습니다.</p>
<p>실제로 제가 설계한 <code>Car</code> 모델은 자동차의 이름과 이동거리 정보를 가공한 데이터를 다른 객체에 제공하는 책임(기능)을 가지고 있습니다. 상세하게는, 현재 상황에 대한 데이터, 다른 <code>Car</code> 객체와의 이동거리 비교 데이터, 자동차 이름에 대한 데이터를 제공합니다. 이렇게 기능 단위 커밋 요구 사항은 지킬 수 있었습니다.</p>
<h3 id="진짜-미션-테스트-코드-작성">진짜 미션, 테스트 코드 작성.</h3>
<p>기능 단위 커밋은 그래도 스스로 판단해서 해낼 수 있었지만, 테스트 코드 작성은 정말 막막했습니다. 테스트를 직접 구현해봤던 경험도 거의 없었고, 그나마 직접 구현했던 테스트들도 클론 코딩이었으니, 어쩌면 당연한 일이었습니다. 그래도 JUnit의 대략적인 사용법은 알고 있었기 때문에 주어진 테스트 예제와 이전에 구현해봤던 테스트들을 다시 살펴보며 테스트 구현을 시작했습니다.</p>
<p>그러나, 이전의 테스트 코드들은 저에게 큰 도움이 되지 못했습니다. 처음으로 구현하기 시작한 테스트부터 정말 난감했습니다. 자동차 경주 게임은 우테코에서 제공한 <code>Randoms</code> 라이브러리의 난수를 통해 자동차의 전진과 정지를 결정하게 됩니다. 문제는, 발생할 난수를 예측할 수 없으니 자동차가 전진할지, 정지할지 알 수 없었고, 당연히 테스트도 불가능했습니다. 그래서 저는 어떻게 하면 난수가 포함된 기능을 테스트할 수 있을지 고민하기 시작했습니다.</p>
<p>구글링을 통해 열심히 학습한 결과, 제가 생각하는 난수에 대한 테스트 방식은 다음과 같습니다.</p>
<ul>
<li>난수를 생성하는 기능을 별도의 클래스로 분리해서 자동차의 전진은 해당 클래스로부터 난수를 매개변수로 받아 수행. (메소드 시그니처 수정)</li>
<li>난수를 생성하는 외부 라이브러리를 신뢰하고, 주어진 범위 안에서 난수가 생성될 것임을 전제로 테스트. (외부 라이브러리 신뢰)</li>
</ul>
<p>저는, 위의 방식들을 통해 테스트를 구현하고자 기존에 구현을 완료했던 모델들을 다시 살펴봤습니다.</p>
<p>먼저, 테스트 코드 작성 전, <code>Car</code> 모델의 자동차의 이동을 담당하는 메소드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">int</span> moveCondition <span class="token operator">=</span> <span class="token class-name">Randoms</span><span class="token punctuation">.</span><span class="token function">pickNumberInRange</span><span class="token punctuation">(</span>lowerBound<span class="token punctuation">,</span> upperBound<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>moveCondition <span class="token operator">>=</span> MOVE_CRITERIA<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        distance<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>매번 자동차를 움직이려고 시도할 때마다, 난수를 생성하고 난수가 조건에 부합하면 자동차의 이동거리를 증가시켰습니다. 이렇게 메소드를 작성해도 자동차 경주 게임이 작동하는 데는 문제가 없었습니다. 그러나, 이 메소드는 치명적인 문제가 있었습니다. 제가 제어할 수 없는 부분이 코드 깊숙이 존재한다는 점입니다. (메소드 내부에 있기 때문에 외부에서 난수를 원하는 대로 설정할 방법이 없습니다.)</p>
<p>또한, <code>Car</code> 모델에 '자동차의 데이터를 제공한다.'라는 책임에 '이동을 위한 난수를 생성한다.'는 책임까지 부여됐습니다. 즉, 단일 책임 원칙이 위반된 것입니다. 테스트를 위해 로직을 수정한다는 것은 좋지 못한 방식이라고 하지만, 이 부분은 좋은 객체지향 프로그래밍을 위해서라도 고쳐야 했습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveCar</span><span class="token punctuation">(</span><span class="token keyword">int</span> moveCondition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>moveCondition <span class="token operator">>=</span> MOVE_CRITERIA<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        distance<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>앞서 알아본 난수에 대한 테스트 방식을 적용해 메소드의 시그니처를 수정하고 난수의 생성을 다른 클래스로 분리했습니다. 이전과 다르게 자동차는 직접 난수를 생성하는 것이 아닌, 외부로부터 난수를 전달받아 조건에 맞춰 전진 혹은 정지하게 되었습니다. 덕분에 난수 라이브러리와 상관없이 자동차의 이동에 관련된 테스트를 구현할 수 있게 됐습니다.</p>
<p>난수 생성 라이브러리가 주어진 범위 내의 난수를 제대로 생성하는지도 테스트 해봐야 하지 않을까 생각했지만, 외부 라이브러리는 의도대로 동작한다는 전제하에 자동차 경주 게임을 구현했기 때문에, 여기까지 신경 쓸 필요는 없다고 생각했습니다.</p>
<blockquote>
<p>개인적인 의견으론, 제가 직접 구현하지 않은 코드를 테스트하는 것은 불필요한 작업인 것 같습니다.</p>
</blockquote>
<p>이렇게 테스트 구현에 2배 정도 더 시간을 쏟고 나서야 주어진 요구 사항에 맞게 2주 차 미션을 완료했습니다.</p>
<h2 id="개발-습관을-돌아보게-된-2주-차-미션" class="heading">개발 습관을 돌아보게 된 2주 차 미션</h2>
<p>테스트 구현도 어떻게든 해내고 미션을 제출하고 나니 정말 많은 생각이 들었습니다. '과연 내가 제대로 테스트를 구현한 걸까?', '이런 사소한 것까지 테스트 코드를 작성하는 게 맞을까?' 등, 누군가 속 시원하게 알려주는 사람도 없다 보니 제출하고 나서도 해냈다는 느낌이 크게 들지 않았습니다. 또한, 테스트를 먼저 작성한 것이 아닌, 이미 구현된 객체들을 테스트해 테스트를 위한 코드 수정도 발생했습니다.</p>
<p>테스트를 위해 서비스 로직을 수정한다는 것이, 주객 전도된 것 같았습니다. 분명 내 코드를 신뢰하기 위해 테스트를 구현하는 것이라고 공부했는데, 테스트가 제대로 동작하도록 내 코드를 수정하고 있었습니다. 그래도 좋은 경험이었다고 생각합니다. 그동안 제가 얼마나 테스트를 등한시했는지, 돌아가면 장땡이라는 안일한 생각으로 개발했는지 되돌아보게 되었습니다. 좋은 코드와 더불어 좋은 테스트도 중요하다는 것을 알았으니 앞으로는 테스트 주도 개발에 대해서 더 공부해볼 생각입니다.</p>
<h2 id="repository" class="heading">Repository</h2>
<p><a href="https://github.com/hangillee/java-racingcar-6/tree/hangillee" target="_blank" rel="noopener noreferer">자동차 경주 게임 - hangillee</a></p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[프리코스 1주 차를 돌아보며]]></title>
    <link>https://blog.hangilog.kr/precourse-week1</link>
    <pubDate>2023-10-27</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/precourse-week1</guid>
    <description>
    <![CDATA[간단하지 않았던 간단한 숫자 야구 게임]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="우아한테크코스-6기에-지원하기까지" class="heading">우아한테크코스 6기에 지원하기까지</h2>
<p>작년 겨울, 제가 활동 중인 동아리에서는 교내 대학생 개발자를 위한 IT 컨퍼런스를 개최했었습니다. 해당 컨퍼런스의 강연 연사로 졸업한 선배들을 초청했었는데, 초청되었던 선배들은 대부분 우아한테크코스(우테코)를 수료해 다양한 기업에서 일하고 있었습니다. 저는 현업 선배들의 이야기를 들을 수 있는 좋은 기회를 놓치지 않고 어렴풋이 알고 있었던 우테코의 궁금했던 점들을 질문했습니다.</p>
<p>선배들은 우테코가 일방적인 강의식 학습이 아닌 상호 협력을 통해 함께하는 학습을 제공하고, 현장형 인재로 성장할 수 있게 도와준다고 이야기했습니다. 저는 그 대답을 듣고 꼭 우테코에 도전해봐야겠다는 생각이 들었습니다. 그렇게 시간이 흘러 6기 모집 공고가 올라왔고, 저는 저의 지난 날들을 돌아보며 열심히 지원서를 작성했습니다. 쓰고 고치고를 반복하다가 모집 마감날에 지원서를 제출헸고, 곧바로 시작될 프리코스를 준비했습니다.</p>
<h2 id="프리코스-1주-차-미션---숫자-야구-게임" class="heading">프리코스 1주 차 미션 - 숫자 야구 게임</h2>
<p>10월 19일 목요일 오후 3시, 어떤 미션이 주어졌을지 긴장 반 설렘 반으로 메일함을 열어 미션을 확인했습니다. 6기 프리코스 참가자들에게 주어진 첫 미션은 간단한 <strong>숫자 야구 게임</strong>이었습니다. 처음 미션을 확인하고 들었던 생각은, '어? 의외로 쉬운 문제네?'였습니다. 숫자 야구 게임은 이전에도 접해본 유명한 프로그래밍 실습 과제이기도 했고, 게임 자체가 복잡한 알고리즘을 요구하지도 않습니다. 그러나, 제 생각과 달리 우테코의 숫자 야구 게임은 간단하지만 간단하지 않은 미션이었습니다.</p>
<p>물론 우테코가 요구하는 숫자 야구 게임의 규칙도 크게 어려울 것 없이 간단했습니다. 그러나, 게임의 핵심 로직 외에 생각해야하는 것들이 정말 많았습니다. 단순한 알고리즘 코딩 테스트처럼 출력값만 요구 사항과 동일하면 해결되는 미션이 아니었습니다. 코드 컨벤션을 통일하고, 좋은 객체지향 프로그래밍을 위해 지켜야하는 원칙을 숙지하고, 어떻게 하면 더 클린 코드에 가깝게 코드를 작성할 수 있을지 매순간 고민했어야 했습니다.</p>
<h3 id="첫번째-구현-일단-동작하게-하자">첫번째 구현, 일단 동작하게 하자!</h3>
<p>요구 사항이 이렇게 다양하고 엄격한 과제를 해보는 것은 처음이라 평소 습관처럼 일단 동작하는 숫자 야구 게임을 구현하려고 했습니다. 미션의 기능 요구 사항만 보고 구현하면서 그때그때 생각나는 클래스들을 생성하고, 메소드를 작성했습니다. 이 단계에서 저의 목표는 오로지 단 하나, '<strong>일단 잘 동작하는 쓰레기를 만들자!</strong>'였습니다. 아무리 예쁘고 예술적인 코드여도 동작하지 않으면 동작하는 쓰레기 코드보다 못하다는 말처럼, 1주라는 시간 안에 일단 동작은 하도록 만들고 싶었습니다.</p>
<img width="1235" alt="first_commits" src="https://github.com/hangillee/coderoad.kr/assets/14046092/4cf92b17-3c80-41d9-b481-3eadcfc0d9d2">
<div align="center"><I>일단 동작은 하게 만들었던 첫번째 구현 기능들의 commit 내역</I></div>
<p>중간 고사 기간과 겹쳐 조금 늦긴했지만 미션이 주어진지 3일만에 숫자 야구 게임의 첫번째 구현을 완료했습니다. 저는 기능 요구 사항은 충족했으니, 프로그래밍 요구 사항을 충족시키고자 리팩토링을 시도했습니다. 예상은 하고 있었지만 리팩토링을 시도하자마자 코드를 몽땅 갈아엎을 뻔 했습니다. 동작만하는 쓰레기는 쓰레기일 뿐이었습니다.</p>
<p>첫번째 구현 코드는 클래스끼리 너무 서로를 많이 의존하고 있어 서로의 역할과 책임이 모호했고, 단일 책임 원칙을 비롯한 여러 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a> 원칙들을 위반하고 있었습니다. 객체지향 언어인 Java를 다루면서 전혀 객체지향답지 않은 코드를 작성했던 것입니다.</p>
<h3 id="두번째-구현-객체지향다운-클린-코드를-향해">두번째 구현, 객체지향다운 클린 코드를 향해.</h3>
<p>그래서 저는 클래스 설계부터 다시 시작했습니다. 그제서야 과제 진행 요구 사항에 <strong>기능을 구현하기 전</strong>, 구현 기능 목록을 <strong>먼저 작성하라</strong>는 항목이 있는 이유를 알게 됐습니다. 구현 기능 목록을 작성하면서 클래스 별로 맡을 역할과 책임을 먼저 생각해보고, 기존의 비대했던 클래스를 단일 책임만 가지는 작은 클래스들로 분리할 수 있었습니다. 역할과 책임을 가지는 객체들의 자율적인 협력 관계, 제가 아는 객체지향 프로그래밍이 설계된 순간이었습니다.</p>
<p><img src="https://github.com/hangillee/coderoad.kr/assets/14046092/ddfe5f6a-f852-46d7-a941-196f7234163b" alt="java-baseball"></p>
<div align="center"><I>다시 설계하고 구현한 숫자 야구 게임의 클래스 다이어그램</I></div>
<p>다시 설계한 구현 코드에서는 인스턴스 변수의 개수를 최대한 줄이고, 각 클래스들에게 하나의 역할만 부여했습니다. 또한, 우테코의 PR 체크 리스트를 참고해 코드 리팩토링에 집중했습니다. 리팩토링하면서 첫번째 구현 코드가 정말 지저분한 코드였다는 생각이 들자 리팩토링은 선택이 아닌 꼭 필요한 과정이라는 생각이 들었습니다. 처음 구현할 때는 꽤 멋진 코드라고 생각했던 제 자신이 조금 부끄러워졌습니다.</p>
<p>다음은 새로 설계하면서 클래스 별로 부여한 역할과 책임입니다.</p>
<ul>
<li><code>Application</code> : <code>main</code> 메소드가 있는 곳으로 <code>GameController</code> 클래스를 통해 숫자 야구 게임을 시작하는 곳입니다.</li>
<li><code>Command</code> : 게임의 재시작 혹은 종료를 결정하는 명령어를 열거형으로 선언한 클래스입니다.</li>
<li><code>Computer</code> : 숫자 야구 게임에서 <strong>상대방 역할</strong>을 담당합니다. 임의의 3자리 숫자를 생성하고 이를 보관하면서 본인이 보관한 숫자에 대한 정보를 제공합니다.</li>
<li><code>Game</code> : 숫자 야구 게임에서 <strong>게임 한판 역할</strong>을 담당합니다. 사용자와 상대방으로부터 숫자에 대한 정보를 얻어 게임의 결과를 판단하고 이를 반환하는 기능을 제공합니다.</li>
<li><code>GameController</code> : 숫자 야구 게임에서 <strong>게임 진행자 역할</strong>을 담당합니다. 게임 결과에 따라 힌트를 제공하거나, 게임의 재시작 혹은 종료를 제어합니다.</li>
<li><code>User</code> : 숫자 야구 게임에서 <strong>사용자 역할</strong>을 담당합니다. 사용자가 입력한 3자리 숫자를 보관하고 해당 숫자의 규칙 위반에 대한 검증 기능을 제공합니다.</li>
<li><code>GameView</code> : 숫자 야구 게임에서 <strong>게임 진행 과정 출력 역할</strong>을 담당합니다. 야구의 전광판이라 생각하면 쉽습니다. 사용자가 실질적으로 보게 되는 인터페이스를 출력합니다.</li>
</ul>
<p>회고하는 지금, 이 클래스 설계를 다시 읽어보니 더 세세하게 분리할 수 있었을 것 같아 아쉽지만 첫번째 구현보다는 확실히 객체지향다운 설계라고 생각합니다. 2주 차 미션에서는 이런 경험을 바탕으로 역할과 책임을 바탕으로한 클래스 설계부터 신중하게 할 예저입니다.</p>
<h2 id="1주-차를-마치고" class="heading">1주 차를 마치고</h2>
<p>1주 차 미션은 그동안 간과했던 코드 컨벤션, 클린 코드와 객체지향다운 코드를 위한 원칙을 꼭 지켜야 했던 미션이었습니다. 저에게는 과제 자체의 알고리즘을 구현하는 것은 크게 어렵지 않았지만, 잘못 들였던 개발 습관을 고치는게 더욱 어려웠습니다. 특히, 단순한 알고리즘 문제 풀이를 생각하고 구현에만 치중하는 방식은 우테코에선 아무런 의미가 없다는 점이 신선한 충격으로 다가왔습니다.</p>
<p>제가 1주 차에 경험한 우테코는 빠른 결과보다 느리더라도 좋은 코드를 추구하는 과정 자체를 중요시하는 것 같습니다. 프리코스에 함께하는 많은 분들과 더 나은 코드를 위해 계속해서 토론하고 지식을 공유하는 프리코스 커뮤니티가 있는 이유도 아마 우테코의 철학을 가장 잘 활용할 수 있는 공간이기 때문이라고 생각합니다.</p>
<p>앞으로의 프리코스 미션에서는 클래스 설계에 많은 시간을 들이고, 어떻게 하면 더 객체지향다울 수 있을지 고민하는 과정 자체에 중점을 두고자 합니다.</p>
<h2 id="repository" class="heading">Repository</h2>
<p><a href="https://github.com/hangillee/java-baseball-6/tree/hangillee" target="_blank" rel="noopener noreferer">숫자 야구 게임 - hangillee</a></p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[값 타입]]></title>
    <link>https://blog.hangilog.kr/value-type</link>
    <pubDate>2023-07-13</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/value-type</guid>
    <description>
    <![CDATA[JPA의 또 다른 데이터 타입]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 10 -->
<h2 id="엔티티-타입과-값-타입" class="heading">엔티티 타입과 값 타입</h2>
<h2 id="기본-값-타입" class="heading">기본 값 타입</h2>
<h2 id="임베디드-값-타입" class="heading">임베디드 값 타입</h2>
<h2 id="값-타입과-불변-객체" class="heading">값 타입과 불변 객체</h2>
<h2 id="값-타입의-비교" class="heading">값 타입의 비교</h2>
<h2 id="값-타입-컬렉션" class="heading">값 타입 컬렉션</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[영속성 전이]]></title>
    <link>https://blog.hangilog.kr/cascade</link>
    <pubDate>2023-07-11</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/cascade</guid>
    <description>
    <![CDATA[모든 엔티티를 일일히 영속화 해야 할까?]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 09 -->
<h2 id="영속성-전이" class="heading">영속성 전이</h2>
<h2 id="영속성-전이-주의점" class="heading">영속성 전이 주의점</h2>
<h2 id="고아-객체" class="heading">고아 객체</h2>
<h2 id="영속성-전이와-고아-객체-그리고-생명-주기" class="heading">영속성 전이와 고아 객체, 그리고 생명 주기</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[지연 로딩과 즉시 로딩]]></title>
    <link>https://blog.hangilog.kr/loading</link>
    <pubDate>2023-07-10</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/loading</guid>
    <description>
    <![CDATA[데이터베이스 조회는 항상 조심해야 한다]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 08 -->
<h2 id="지연-로딩-즉시-로딩" class="heading">지연 로딩? 즉시 로딩?</h2>
<h2 id="지연-로딩이-필요한-경우" class="heading">지연 로딩이 필요한 경우</h2>
<h2 id="즉시-로딩이-필요한-경우" class="heading">즉시 로딩이 필요한 경우</h2>
<h2 id="프록시와-즉시-로딩-주의점" class="heading">프록시와 즉시 로딩 주의점</h2>
<h2 id="로딩-활용법" class="heading">로딩 활용법</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[프록시]]></title>
    <link>https://blog.hangilog.kr/proxy</link>
    <pubDate>2023-07-09</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/proxy</guid>
    <description>
    <![CDATA[진짜 객체와 가짜 객체, 그리고 성능]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 07 -->
<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/ORM-JPA-Basic" target="_blank" rel="noopener noreferer">자바 ORM 표준 JPA 프로그래밍 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서에 포함된 코드, 이미지 등의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 강사님께 있습니다.</strong></p>
<h2 id="조회를-했는데-쿼리가-하나-더" class="heading">조회를 했는데 쿼리가 하나 더</h2>
<p>우리는 JPA를 통해 연관관계와 상속관계 같은 객체만의 구조를 데이터베이스의 테이블로도 표현할 수 있게 되었습니다. JPA 덕분에 객체와 데이터베이스가 정말 가까워졌지만, 여전히 고민거리가 하나 있습니다. 만약, 어떤 한 객체를 통해 테이블을 조회할 때, 그와 연관된 다른 객체의 테이블도 함께 조회해야 할까요?</p>
<img width="1111" alt="스크린샷 2023-07-13 오전 1 17 58" src="https://github.com/hangillee/coderoad.kr/assets/14046092/75311934-a3b9-4d80-88ea-28d9ec1f8302">
<div align="center"><I>Member를 조회할 때, Team까지 함께 조회할 필요가 있을까?</I></div>
<br>
<p>예를 들어, <code>Member</code> 엔티티에는 외래 키와 매핑된 <code>Team</code>이라는 참조 필드가 있습니다. 이는 곧, <code>Member</code> 테이블이 <code>Team</code> 테이블과 연관되어 있다는 뜻입니다. 따라서, <code>Member</code> 엔티티를 통해 테이블을 조회할 때, <code>Team</code> 테이블도 함께 조회해서 <code>Member</code>의 <code>Team</code>에 대한 여러 데이터를 가져올 수도 있고, <code>Member</code> 자체의 데이터만 필요해서 가져오지 않을 수도 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 회원의 이름만 필요한 로직에서도 굳이 Team 테이블을 조회해야 할까?</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> memberId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">Member</span> member <span class="token operator">=</span> em<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">Member</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">Team</span> team <span class="token operator">=</span> member<span class="token punctuation">.</span><span class="token function">getTeam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"회원 이름 : "</span> <span class="token operator">+</span> member<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>데이터베이스에 조회 쿼리가 하나 더 날아가는 것은 그렇지 않은 경우보다 당연히 성능 측면에서 손해가 발생할 수 밖에 없습니다. 간단한 예제 코드의 경우에는 성능 저하가 크게 체감될 정도는 아니지만, 이렇게 부수적인 쿼리가 발생하는 문제는 <strong>N+1 문제</strong>라고 하는 JPA를 통한 개발에서 꼭 피해야하는 중대한 성능 저하 문제입니다.</p>
<p>즉, 엔티티를 조회할 때, 그와 연관된 엔티티를 모두 조회하는 것은 N+1 문제를 야기하기 때문에 결코 좋은 방법이 아닙니다. 프로그래머는 결국 문제를 해결하는 사람이고, 서비스의 성능을 저하시키는 N+1 문제를 해결해야만 합니다. 놀랍게도 이런 문제들을 해결하는 방법은 간단합니다. 연관된 DB 테이블의 조회를 <strong>뒤로 미루면 간단하게 해결</strong>됩니다.</p>
<p>뒤로 미루는 방법을 공부하기 위해선 먼저, <strong>프록시</strong>를 알아야 합니다. 뒤로 미루는 방법에 대한 자세한 설명은 <a href="https://blog.coderoad.kr/loading" target="_blank" rel="noopener noreferer">지연 로딩과 즉시 로딩</a>에 정리해뒀습니다.</p>
<h2 id="프록시란" class="heading">프록시란?</h2>
<p><strong>프록시</strong>(Proxy)는 우리가 직접 다루는 실제 엔티티 클래스를 상속 받아서 생성되는 일종의 "<strong>가짜 객체</strong>"입니다. JPA의 구현체인 Hibernate의 내부 라이브러리가 자동으로 생성하며, 실제 엔티티 클래스를 상속받아서 만들어지기 때문에 당연하게도 실제 엔티티 클래스와 겉 모양이 같습니다. 이론상, 해당 엔티티를 사용하는 입장에서는 사용하는 객체가 진짜 객체인지 프록시 객체인지는 구분하지 않고 사용하면 됩니다.</p>
<p>프록시 객체는 실제 객체를 대신해서 호출됩니다. 이런 특징 덕분에 <strong>DB 테이블 조회를 뒤로 미룰 수 있는 것</strong>입니다. 그렇다면 프록시는 어떻게 실제 객체를 대체할 수 있는 것일까요? 바로, <strong>프록시 객체가 실제 객체의 참조를 보관</strong>하고 있기 때문입니다.</p>
<p>프록시 객체는 <a href="#%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%B4%88%EA%B8%B0%ED%99%94">프록시 초기화</a> 과정에서 실제 객체를 가리키는 참조를 가지게되고 이를 통해 실제 객체의 필드나 메소드를 호출합니다. 이 과정을 **위임(Delegate)**이라고 하며, 프록시 객체는 자신이 가리키는 객체의 구성 요소들을 호출할 때만 해당 객체의 DB 테이블을 조회하거나 메소드 바디 내용을 읽어옵니다.</p>
<p>객체지향 프로그래밍의 특징 중 하나인 "<strong>객체는 객체 그래프를 자유롭게 탐색할 수 있어야 한다.</strong>"를 생각해보면, 하나의 엔티티를 조회할 때, 이와 연관된 엔티티를 모두 함께 조회해 객체 그래프를 생성해야 한다는 것을 알 수 있습니다. 그런데, 실제 엔티티들로 이루어진 객체 그래프를 생성하려면 엔티티들의 DB 테이블을 모두 조회해야합니다. 이렇게 되면 위에서 설명한 <strong>N+1 문제</strong>가 발생하는 것입니다.</p>
<blockquote>
<p>객체 그래프를 완성하기 위해 연관관계를 가지는 모든 엔티티를 조회하면 <strong>1개의 DB 테이블 조회 쿼리에 부가적인 N개의 조회 쿼리가 발생</strong>합니다. 즉, N+1 문제입니다.</p>
</blockquote>
<p>그래서 프록시 객체를 실제 엔티티 객체 대신 객체 그래프에 넣어두어 마치 객체 그래프가 완성된 것처럼 생각하는 것입니다. <strong>즉, 객체 그래프에서 실제 값이나 메소드를 알고 있는 것은 처음 조회한 엔티티 뿐이며, 나머지는 모두 프록시로 대체</strong>해서 1개의 엔티티 조회 시에 부가적인 쿼리가 DB로 날아가지 않게 해 N+1 문제를 해결하는 것입니다.</p>
<blockquote>
<p>프록시로 객체 그래프가 대신 완성되었으니 어떤 한 엔티티를 조회할 때, 당장 데이터가 필요하지 않습니다. 즉, DB 테이블을 조회할 필요도 없는 것입니다.</p>
</blockquote>
<h2 id="프록시-초기화" class="heading">프록시 초기화</h2>
<h2 id="프록시의-여러-특징들" class="heading">프록시의 여러 특징들</h2>
<h2 id="프록시-확인법" class="heading">프록시 확인법</h2>
<h2 id="프록시의-진가" class="heading">프록시의 진가</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[고급 매핑]]></title>
    <link>https://blog.hangilog.kr/advanced-mapping</link>
    <pubDate>2023-07-08</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/advanced-mapping</guid>
    <description>
    <![CDATA[상속관계 매핑과 @MappedSuperClass]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 06 -->
<h2 id="상속관계-매핑" class="heading">상속관계 매핑</h2>
<p>객체와 관계형 데이터베이스의 차이가 또 하나 있습니다. 바로, <strong>데이터베이스에는 상속관계가 존재하지 않는다</strong>는 것입니다. 상속이 객체지향 프로그래밍에서 아주 중요한 개념임을 생각하면 데이터베이스에서도 테이블 간의 상속관계를 표현할 방법이 있어야 합니다. 다행히도 상속관계와 유사한 데이터베이스 모델링 기법이 있습니다. <strong>슈퍼타입 서브타입 관계</strong>라는 모델링 기법으로, 상속관계 매핑은 객체의 상속과 구조를 DB의 슈퍼타입 서브타입 관계를 매핑하는 것을 말합니다.</p>
<img width="1160" alt="supersubtype" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/b80d8291-ac2f-4260-9991-dd520c565e09">
<div align="center"><I>DB의 슈퍼타입 서브타입 관계와 객체의 상속관계 </I></div>
<br>
<p>슈퍼타입 서브타입 논리 모델을 물리 모델로 구현하는 방법에는 여러 전략들이 있습니다. 전략들을 살펴보기 전, 상속관계 매핑을 위해 꼭 알아둬야 하는 어노테이션이 있습니다.</p>
<ul>
<li><code>@Inheritance(strategy = InheritanceType.타입)</code>
<ul>
<li><code>JOINED</code> : 조인 전략</li>
<li><code>SINGLE_TABLE</code> : 단일 테이블 전략</li>
<li><code>TABLE_PER_CLASS</code> : 구현 클래스별 테이블 전략</li>
</ul>
</li>
<li><code>@DiscriminatorColumn(name = "DTYPE")</code></li>
<li><code>@DiscriminatorValue("구분자 이름")</code></li>
</ul>
<p>첫 번째 어노테이션 <code>@Inheritance</code>는 <code>JOINED</code>, <code>SINGLE_TABLE</code>과 같은 상속 전략 타입과 함께 <strong>부모 클래스에 입력</strong>해 상속관계 매핑 시, 원하는 전략을 사용할 수 있도록 해줍니다. <code>@Inheritance</code> 어노테이션의 기본 전략은 <code>SINGLE_TABLE</code>입니다.</p>
<p>다음은 각 자식 클래스를 데이터베이스 상에서 구분하기 위해 <strong>부모 클래스에 사용</strong>되는 <strong>구분자 컬럼 설정</strong>을 위한 <code>@DiscriminatorColumn</code> 어노테이션입니다. 컬럼명을 직접 정할 수도 있으며 기본 이름은 <code>DTYPE</code>입니다.</p>
<p>마지막 어노테이션인 <code>@DiscriminatorValue</code>는 <code>@DiscriminatorColumn</code>에 저장될 값을 지정하는 자식 클래스용 어노테이션입니다. 해당 어노테이션에 적어둔 값이 부모 테이블의 구분자 컬럼에 저장됩니다. 기본값은 자식 엔티티의 이름입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 부모 클래스(엔티티)</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token annotation punctuation">@Inheritance</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">InheritanceType</span><span class="token punctuation">.</span>JOINED<span class="token punctuation">)</span> <span class="token comment">// 조인 전략으로 상속관계 매핑</span>
</span><span class="code-line"><span class="token annotation punctuation">@DiscriminatorColumn</span> <span class="token comment">// 구분자 컬럼 DTYPE</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 자식 클래스(엔티티)</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token annotation punctuation">@DiscriminatorValue</span><span class="token punctuation">(</span><span class="token string">"MOVIE"</span><span class="token punctuation">)</span> <span class="token comment">// DTYPE MOVIE</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token keyword">extends</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> director<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> actor<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>위 코드가 상속관계 매핑을 완료한 코드입니다. 이렇게 JPA를 활용하면 간단하게 데이터베이스에서 상속관계를 표현할 수 있습니다. <code>Item</code> 엔티티의 테이블에는 <code>DTYPE</code>이라는 컬럼이 추가될 것이고, <strong>조인 전략</strong>이라는 것과, 구분자 값 <code>MOVIE</code>가 <code>Item</code>의 <code>DTYPE</code> 컬럼에 입력될 것이라는 것도 알 수 있습니다.</p>
<h2 id="조인-전략" class="heading">조인 전략</h2>
<p>위의 예제를 통해 잠깐 알아본 <strong>조인 전략</strong>에 대해서 더 자세히 알아보겠습니다. 조인 전략은 말 그대로 SQL <code>JOIN</code> 연산을 활용하는 전략으로, 슈퍼타입과 서브타입 테이블을 각각 만들고, 자식 테이블이 부모 테이블의 기본 키를 받아서 자신의 기본 키이자 외래 키로 사용합니다. 데이터 조회 시에는 <code>JOIN</code> 연산을 통해 두 테이블을 함께 조회합니다.</p>
<img width="1240" alt="joinstrategy" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/e0508c38-9cd5-445c-9078-8cdff7b03627">
<div align="center"><I>객체의 상속처럼 부모 테이블에 공통 속성을 두고 자식 클래스에 구체적인 속성을 둔다.</I></div>
<br>
<p>한 눈에 보기에도 객체와 테이블의 구조가 유사해보입니다. 실제로 조인 전략은 가장 정석적인 전략이라고 합니다.</p>
<p>이제 데이터베이스 테이블 구성도 완료했습니다. 조인 전략을 통해 모든 엔티티의 테이블들을 각각 생성했고, 자식 테이블들이 부모 테이블의 기본 키를 가져와 자신의 기본 키와 외래 키로 설정했습니다. 만약, 테이블에 엔티티를 저장할 때, 엔티티가 어떻게 저장되는지도 알아보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Movie</span> movie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Movie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">movie<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"JPA는 아름다워"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">movie<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token number">202307</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">movie<span class="token punctuation">.</span><span class="token function">setDirector</span><span class="token punctuation">(</span><span class="token string">"Hibernate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">movie<span class="token punctuation">.</span><span class="token function">setActor</span><span class="token punctuation">(</span><span class="token string">"CodeRoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>movie<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>위와 같이 <code>Movie</code> 엔티티를 영속화하면 JPA는 다음과 같은 SQL 쿼리를 작성합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line">    <span class="token comment">/* insert hellojpa.Movie
</span></span><span class="code-line"><span class="token comment">        */</span> insert
</span><span class="code-line">        into
</span><span class="code-line">            <span class="token class-name">Item</span>
</span><span class="code-line">            <span class="token punctuation">(</span>name<span class="token punctuation">,</span> price<span class="token punctuation">,</span> DTYPE<span class="token punctuation">,</span> id<span class="token punctuation">)</span>
</span><span class="code-line">        values
</span><span class="code-line">            <span class="token punctuation">(</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token char">'MOVIE'</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line">    <span class="token comment">/* insert hellojpa.Movie
</span></span><span class="code-line"><span class="token comment">        */</span> insert
</span><span class="code-line">        into
</span><span class="code-line">            <span class="token class-name">Movie</span>
</span><span class="code-line">            <span class="token punctuation">(</span>actor<span class="token punctuation">,</span> director<span class="token punctuation">,</span> id<span class="token punctuation">)</span>
</span><span class="code-line">        values
</span><span class="code-line">            <span class="token punctuation">(</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>
</span></code></pre>
<p>분명히 우리는 <code>Movie</code> 엔티티 하나만 저장했는데 <code>INSERT</code> 쿼리가 2개 작성되어 데이터베이스로 향했습니다. 부모 테이블 <code>Item</code>과 자식 테이블 <code>Movie</code>에 하나씩 전송된 쿼리는 각각 테이블 컬럼에 맞게 데이터를 저장했습니다. 사실, 이 쿼리는 정확하게 잘 작성된 쿼리입니다. 그 이유는, 객체 입장에서는 <code>Item</code>을 상속한 <code>Movie</code>가 <code>Item</code>의 필드와 메소드들을 알고 있고 활용할 수 있지만, 데이터베이스 테이블 입장에서는 두 클래스의 속성들은 완전히 별개이기 때문입니다.</p>
<p>데이터베이스에서는 우리가 아무리 상속관계 매핑을 해준다고 하더라도 객체와 같이 자식인 <code>Movie</code> 테이블이 부모 테이블 <code>Item</code>의 컬럼을 상속 받아 자유자재로 다룰 수 있는 것은 아닙니다. 부모 테이블에는 다른 자식 테이블들과 공유되는 공통 속성만 있고, 각 자식 테이블은 자신 고유의 속성들만 가지고 있습니다. 이후, 자식 엔티티 <code>Movie</code>를 조회할 때, 부모와 자식 테이블을 <code>JOIN</code> 연산을 통해 합친 후, 온전한 <code>Movie</code>의 데이터를 반환하는 것입니다.</p>
<p><code>Movie</code> 엔티티를 조회할 때 <code>Item</code> 테이블과 <code>Movie</code> 테이블을 <code>JOIN</code>한 후, <code>Item</code> 테이블의 <code>id</code>, <code>name</code>, <code>price</code>와 <code>Movie</code> 테이블의 <code>actor</code>, <code>director</code> 속성들을 하나로 모아 <code>Movie</code> 엔티티에 대한 정보로 반환하는 것을 볼 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line">    select
</span><span class="code-line">        movie0_<span class="token punctuation">.</span>id as id2_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        movie0_1_<span class="token punctuation">.</span>name as name3_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        movie0_1_<span class="token punctuation">.</span>price as price4_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        movie0_<span class="token punctuation">.</span>actor as actor1_7_0_<span class="token punctuation">,</span>
</span><span class="code-line">        movie0_<span class="token punctuation">.</span>director as director2_7_0_
</span><span class="code-line">    from
</span><span class="code-line">        <span class="token class-name">Movie</span> movie0_
</span><span class="code-line">    inner join
</span><span class="code-line">        <span class="token class-name">Item</span> movie0_1_
</span><span class="code-line">            on movie0_<span class="token punctuation">.</span>id<span class="token operator">=</span>movie0_1_<span class="token punctuation">.</span>id
</span><span class="code-line">    where
</span><span class="code-line">        movie0_<span class="token punctuation">.</span>id<span class="token operator">=</span><span class="token operator">?</span>
</span></code></pre>
<p>즉, <strong>부모 클래스의 속성은 부모 테이블에만, 자식 클래스의 속성은 자식 테이블에만 저장</strong>하고 <strong>조회할 때 <code>JOIN</code> 연산으로 합쳐 하나로</strong> 보이게 하는 것이 이 조인 전략의 동작 방법입니다.</p>
<p>조인 전략의 장점은 각 테이블에 중복되는 컬럼이 없기 때문에(공통 속성을 부모 테이블이 가지고 있기 때문에), 잘 <strong>정규화</strong>되어 있고 <strong>외래 키 무결성 제약 조건을 활용</strong>할 수 있습니다. 또한, 각 테이블의 모든 행이 <strong>저장 공간을 효율적으로 사용</strong>할 수 있습니다.</p>
<p>단점은 아무래도 매 조회마다 <code>JOIN</code> 연산을 사용하기 때문에 성능 저하가 있을 수 있다는 것과 조회 쿼리가 단순히 <code>SELECT</code> 연산만 사용하는 것이 아니기 때문에 복잡하다는 것입니다. 거기다, 한 엔티티를 저장할 때, 부모와 자식 테이블에 각각 데이터를 나눠서 저장해야하기 때문에 <code>INSERT</code> 쿼리가 두 번 나간다는 것도 단점입니다.</p>
<h2 id="단일-테이블-전략" class="heading">단일 테이블 전략</h2>
<p>다음은 단일 테이블 전략으로, 이름 그대로 상속관계를 하나의 테이블만 가지고 표현하는 전략입니다. 부모와 자식 엔티티의 속성들을 한 테이블에 모두 포함한 후, <code>DTYPE</code> 컬럼을 통해 각 데이터가 어떤 엔티티의 데이터인지 구분합니다.</p>
<img width="1050" alt="singletable" src="https://github.com/hangillee/coderoad.kr/assets/14046092/d107c246-42d7-48b8-8909-2b2d9c5a7945">
<div align="center"><I>부모와 자식 엔티티의 속성을 모두 모아 단 하나의 테이블만 생성한다.</I></div>
<br>
<p>단일 테이블 전략을 설정할 때는 <code>@Inhertance</code> 어노테이션의 속성으로 <code>SINGLE_TABLE</code>을 입력하면 됩니다. 또한, <code>DTYPE</code> 컬럼이 필수이기 때문에 <code>@DiscriminatorColumn</code>을 작성하지 않아도 자동으로 생성됩니다. 물론, 직접 어노테이션을 통해서 명시해주는 편이 코드를 좀 더 직관적으로 만들어주기 때문에 빼놓지 않는 것이 좋습니다. 다음은 단일 테이블 전략을 사용한 예제 코드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 부모 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token annotation punctuation">@Inheritance</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">InheritanceType</span><span class="token punctuation">.</span>SINGLE_TABLE<span class="token punctuation">)</span> <span class="token comment">// 단일 테이블 전략</span>
</span><span class="code-line"><span class="token annotation punctuation">@DiscriminatorColumn</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 자식 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token keyword">extends</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> author<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> isbn<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>단일 테이블 전략으로 변경하기 위해 수정한 어노테이션을 제외하면 조인 전략에서 작성했던 예제 코드와 크게 다른 점은 없습니다. 이것이 JPA의 큰 장점 중 하나인데, 기존에 작성한 코드를 거의 수정하지 않고 어노테이션만 바꿔도 데이터베이스의 구조가 완전히 바뀌었습니다. 만약, JPA를 사용하지 않았다면 쿼리를 비롯한 수많은 코드를 직접 수정했어야 합니다.</p>
<p>코드는 수정한 것이 거의 없지만, 데이터를 조회할 때는 조인 전략을 사용할 때와 전혀 다른 형태의 쿼리가 데이터베이스로 향한다는 것을 확인할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// em.find(Book.class, book.getId()); 수행 시 작성되는 쿼리</span>
</span><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line">    select
</span><span class="code-line">        book0_<span class="token punctuation">.</span>ITEM_ID as ITEM_ID2_3_0_<span class="token punctuation">,</span>
</span><span class="code-line">        book0_<span class="token punctuation">.</span>name as name3_3_0_<span class="token punctuation">,</span>
</span><span class="code-line">        book0_<span class="token punctuation">.</span>price as price4_3_0_<span class="token punctuation">,</span>
</span><span class="code-line">        book0_<span class="token punctuation">.</span>stockQuantity as stockQua5_3_0_<span class="token punctuation">,</span>
</span><span class="code-line">        book0_<span class="token punctuation">.</span>author as author8_3_0_<span class="token punctuation">,</span>
</span><span class="code-line">        book0_<span class="token punctuation">.</span>isbn as isbn9_3_0_
</span><span class="code-line">    from
</span><span class="code-line">        <span class="token class-name">Item</span> book0_
</span><span class="code-line">    where
</span><span class="code-line">        book0_<span class="token punctuation">.</span>ITEM_ID<span class="token operator">=</span><span class="token operator">?</span>
</span><span class="code-line">        and book0_<span class="token punctuation">.</span>DTYPE<span class="token operator">=</span><span class="token char">'Book'</span>
</span></code></pre>
<p>위의 쿼리에서 볼 수 있듯, 단일 테이블 전략은 <code>JOIN</code> 연산이 사용되지 않아 <strong>조인 전략에 비해 훨씬 쿼리가 간단해지는 장점</strong>이 있습니다. 당연히 <code>JOIN</code> 연산이 필요하지 않으니 <strong>조회 성능이 일반적으로 빠릅니다</strong>. 그러나, 훨씬 간단하고 효율적인 것처럼 보이는 단일 테이블 전략에는 정말 큰 단점이 있습니다.</p>
<p>바로, <strong>자식 엔티티들이 매핑한 컬럼들은 모두 <code>NULL</code>을 허용</strong>해야 한다는 것입니다. 모든 자식 엔티티들의 속성들이 한 테이블에 있다보니 어떤 자식 엔티티는 사용하지 않는 컬럼도 같은 테이블에 있게 되고, 해당 컬럼은 아무런 값도 가지지 않게 됩니다. 이는 저장 공간의 낭비이며, 데이터 무결성 측면에서 <code>NULL</code>로 인해 예기치 못한 버그가 터질 수도 있습니다.</p>
<p>또한, 한 테이블에 모든 속성들을 저장해야 하는 특성 때문에 테이블이 지나치게 비대해져서 오히려 조회 성능이 낮아질 수도 있습니다. 따라서, 단일 테이블 전략은 정말 단순한 상속관계이며, 저장하는 데이터도 얼마 없는 간단한 엔티티인 경우에 선택하는 것이 좋습니다.</p>
<h2 id="구현-클래스별-테이블-전략" class="heading">구현 클래스별 테이블 전략</h2>
<p>다음은 구현 클래스별 테이블 전략입니다. 결론부터 말하자면 해당 전략은 사용하지 않는 것이 좋습니다. 이 전략은 ORM 전문가와 데이터베이스 설계자 모두가 추천하지 않는 전략이라고 합니다. 간단하게 설명하자면, 상속관계에서 부모 클래스를 제외한 모든 구현 클래스의 테이블을 각각 만드는 전략입니다.</p>
<img width="1245" alt="tableperclass" src="https://github.com/hangillee/coderoad.kr/assets/14046092/489f628e-536b-427f-8e60-b2ed1d89451e">
<div align="center"><I>부모 클래스를 제외한 모든 구현 클래스들이 각자 자신의 테이블을 가진다.</I></div>
<br>
<p>그림과 같이 자식 엔티티, 즉, 서브 타입을 명확하게 구분해서 사용할 때는 효율적이며, <code>NOT NULL</code> 제약 조건을 사용할 수 있어 <code>NULL</code>로 부터 자유롭다는 장점이 있지만, 단점이 이 모든 장점을 상쇄합니다.</p>
<p>바로, 데이터베이스에서 <strong>여러 자식 테이블을 함께 조회</strong>할 때, <code>UNION</code> 연산을 사용하기 때문에 <strong>조회 성능이 느리다</strong>는 것입니다. 코드 상에서 부모 클래스(슈퍼 타입)로 어떤 엔티티를 데이터베이스에서 조회하면 <code>UNION ALL</code>로 <strong>모든 자식 테이블</strong>을 합친 후 조회합니다.</p>
<p>조회 성능도 느린데, 자식 테이블을 통합해서 쿼리하기도 어렵습니다. 성능이 좋지도 않고 쿼리하기도 어렵다면 이 상속관계 매핑 전략은 굳이 활용할 이유가 없습니다.</p>
<blockquote>
<p>문제 해결을 위한 더 좋은 방법들이 있는데 굳이 어려운 방법을 사용해야 할까?</p>
</blockquote>
<p>해당 전략을 적용하기 위해서는 부모 클래스를 <strong>추상 클래스</strong>로 만들어 부모 클래스를 단독으로 사용할 수 없게 해야 합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 부모 클래스가 무조건 추상 클래스여야 한다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token annotation punctuation">@Inheritance</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">InheritanceType</span><span class="token punctuation">.</span>TABLE_PER_CLASS<span class="token punctuation">)</span>
</span><span class="code-line"><span class="token annotation punctuation">@DiscriminatorColumn</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ITEM_ID"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> stockQuantity<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 코드를 작성하면 구현 클래스별 테이블 전략을 적용할 수 있습니다. 코드 수정은 정말 간단하지만 조회 쿼리는 알아보기 힘들 정도로 복잡합니다. 아래의 쿼리는 부모 클래스인 <code>Item</code>을 기준으로 자식 클래스 <code>Movie</code>를 조회하는 코드인 <code>em.find(Item.class, movie.getId());</code>를 수행한 결과입니다.</p>
<blockquote>
<p>만약, 모든 자식 엔티티들의 남은 재고를 조사한다거나 판매한 상품에 대한 정산 등, 부모 엔티티에 있는 공통 속성을 활용하는 로직이 필요한 경우, 부모 엔티티인 <code>Item</code>을 기준으로 조회하면 JPA의 상속관계 매핑 덕분에 자식 테이블들을 한번에 모두 조회할 수 있습니다.</p>
</blockquote>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// em.find(Item.class, movie.getId());의 결과</span>
</span><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line">    select
</span><span class="code-line">        item0_<span class="token punctuation">.</span>ITEM_ID as ITEM_ID1_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>name as name2_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>price as price3_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>stockQuantity as stockQua4_5_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>actor as actor1_7_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>director as director2_7_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>author as author1_1_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>isbn as isbn2_1_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>artist as artist1_0_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>etc as etc2_0_0_<span class="token punctuation">,</span>
</span><span class="code-line">        item0_<span class="token punctuation">.</span>clazz_ as clazz_0_
</span><span class="code-line">    from
</span><span class="code-line">        <span class="token punctuation">(</span> select
</span><span class="code-line">            ITEM_ID<span class="token punctuation">,</span>
</span><span class="code-line">            name<span class="token punctuation">,</span>
</span><span class="code-line">            price<span class="token punctuation">,</span>
</span><span class="code-line">            stockQuantity<span class="token punctuation">,</span>
</span><span class="code-line">            actor<span class="token punctuation">,</span>
</span><span class="code-line">            director<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as author<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as isbn<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as artist<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as etc<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token number">1</span> as clazz_
</span><span class="code-line">        from
</span><span class="code-line">            <span class="token class-name">Movie</span>
</span><span class="code-line">        union
</span><span class="code-line">        all select
</span><span class="code-line">            ITEM_ID<span class="token punctuation">,</span>
</span><span class="code-line">            name<span class="token punctuation">,</span>
</span><span class="code-line">            price<span class="token punctuation">,</span>
</span><span class="code-line">            stockQuantity<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as actor<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as director<span class="token punctuation">,</span>
</span><span class="code-line">            author<span class="token punctuation">,</span>
</span><span class="code-line">            isbn<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as artist<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as etc<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token number">2</span> as clazz_
</span><span class="code-line">        from
</span><span class="code-line">            <span class="token class-name">Book</span>
</span><span class="code-line">        union
</span><span class="code-line">        all select
</span><span class="code-line">            ITEM_ID<span class="token punctuation">,</span>
</span><span class="code-line">            name<span class="token punctuation">,</span>
</span><span class="code-line">            price<span class="token punctuation">,</span>
</span><span class="code-line">            stockQuantity<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as actor<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as director<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as author<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token keyword">null</span> as isbn<span class="token punctuation">,</span>
</span><span class="code-line">            artist<span class="token punctuation">,</span>
</span><span class="code-line">            etc<span class="token punctuation">,</span>
</span><span class="code-line">            <span class="token number">3</span> as clazz_
</span><span class="code-line">        from
</span><span class="code-line">            <span class="token class-name">Album</span>
</span><span class="code-line">    <span class="token punctuation">)</span> item0_
</span><span class="code-line">where
</span><span class="code-line">    item0_<span class="token punctuation">.</span>ITEM_ID<span class="token operator">=</span><span class="token operator">?</span>
</span></code></pre>
<p>다른 전략들에 비해 훨씬 복잡하고 긴 쿼리가 작성된 것을 볼 수 있습니다. 여러 테이블을 조회하는 작업은 꽤 빈번하게 이루어진다는 것을 생각한다면 구현 클래스별 테이블 전략을 다른 전략 대신 선택할 이유가 전혀 없습니다.</p>
<h2 id="부록--mappedsuperclass" class="heading">부록 : @MappedSuperClass</h2>
<p>상속관계 매핑과는 전혀 상관 없지만 유사하게 활용할 수 있는 것이 있습니다. 상속관계에서의 부모 엔티티처럼 여러 엔티티들의 공통 매핑 정보(공통 속성)를 한 곳에 모아두는 클래스를 만들고 <code>@MappedSuperClass</code> 어노테이션을 추가해주면 해당 클래스를 상속 받는 자식 클래스에 매핑 정보를 제공해줍니다.</p>
<img width="1018" alt="baseentity" src="https://github.com/hangillee/coderoad.kr/assets/14046092/da2f61f0-0c30-4a39-b05f-67d3b8e26fc2">
<div align="center"><I>공통 속성들을 하나의 클래스로 모아두고 상속해서 사용한다.</I></div>
<br>
<img width="778" alt="baseentitydb" src="https://github.com/hangillee/coderoad.kr/assets/14046092/1701a2a5-de51-4d0e-aeb0-7e7f50cda9ef">
<div align="center"><I>그러나 DB에는 공통 속성들이 모든 테이블에 각각 들어가 있다.</I></div>
<br>
<p><code>@MappedSuperClass</code>는 상속관계 매핑이 아니기 때문에 상속해서 사용하더라도 공통 속성 클래스(부모 클래스)의 테이블이 생성되지 않습니다. 테이블이 생성되지도 않을 뿐더러, 엔티티도 아니기 때문에 <code>EntityManager</code>를 통해 조회도 불가능합니다. 또한, 공통 속성 클래스를 직접 사용할 일도 없기 때문에 <strong>추상 클래스</strong>로 작성할 것을 권장합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 공통 속성 클래스</span>
</span><span class="code-line"><span class="token annotation punctuation">@MappedSuperclass</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseEntity</span> <span class="token punctuation">{</span> <span class="token comment">// 추상 클래스로 작성</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> createDate<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> lastModifiedBy<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> lastModifiedDate<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@MappedSuperClass</code>를 활용해 공통 속성 클래스를 작성하고 상속해서 사용하면 이 클래스를 상속 받은 엔티티의 테이블에 자동으로 공통 속성들이 추가됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Hibernate</span><span class="token operator">:</span>
</span><span class="code-line"><span class="token comment">// BaseEntity를 상속 받은 Item 엔티티의 테이블</span>
</span><span class="code-line">    create table <span class="token class-name">Item</span> <span class="token punctuation">(</span>
</span><span class="code-line">       <span class="token class-name">DTYPE</span> <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span> not <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">        ITEM_ID bigint not <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">        createDate timestamp<span class="token punctuation">,</span>
</span><span class="code-line">        createdBy <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">        lastModifiedBy <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">        lastModifiedDate timestamp<span class="token punctuation">,</span>
</span><span class="code-line">        name <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">        price integer not <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">        stockQuantity integer not <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">        primary key <span class="token punctuation">(</span>ITEM_ID<span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>즉, <code>@MappedSuperClass</code>는 테이블 생성과는 아무런 관련도 없고, 단순히 여러 엔티티가 공통으로 사용하는 매핑 정보를 제공하는 역할을 하는 것입니다. 주로, 엔티티의 등록일, 수정일, 등록자, 수정자 등, 전체 엔티티에서 공통적으로 사용할 데이터를 모을 때 사용합니다.</p>
<p>참고로, <code>@Entity</code> 어노테이션을 사용한 클래스(엔티티)는 엔티티나 <code>@MappedSuperClass</code> 어노테이션을 사용한 클래스만 상속받을 수 있습니다.</p>
<h2 id="요약" class="heading">요약</h2>
<ul>
<li>데이터베이스에는 상속관계가 존재하지 않는다.</li>
<li>객체의 상속관계를 데이터베이스에서도 표현하기 위해 사용하는 것이 상속관계 매핑이다.</li>
<li>상속관계 매핑 전략에는 3가지가 있다.
<ul>
<li>조인 전략 : 부모 테이블에는 공통 속성, 자식 테이블에는 각자 고유의 속성.</li>
<li>단일 테이블 전략 : 부모와 자식 모두 한 테이블에.</li>
<li>구현 클래스별 테이블 전략 : 부모 테이블 제외 모든 엔티티의 테이블 각각 생성.</li>
</ul>
</li>
<li>핵심 엔티티에는 조인 전략, 정말 단순한 엔티티엔 단일 테이블 전략을 사용한다.
<ul>
<li>구현 클래스별 테이블 전략은 사용하지 않는다.</li>
</ul>
</li>
<li><code>@MappedSuperClass</code>는 단순히 공통 속성을 공유하기 위해 사용한다.
<ul>
<li>엔티티도 아니고 테이블과도 관련 없다.</li>
</ul>
</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[다양한 연관관계 매핑]]></title>
    <link>https://blog.hangilog.kr/relational-mapping-types</link>
    <pubDate>2023-07-07</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/relational-mapping-types</guid>
    <description>
    <![CDATA[연관관계 매핑의 종류와 방향]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 05 -->
<h2 id="연관관계-매핑-시-고려해야할-사항" class="heading">연관관계 매핑 시 고려해야할 사항</h2>
<p>JPA에서 연관관계를 매핑할 때, 고려할 사항은 3가지가 있습니다.</p>
<ol>
<li>다중성</li>
<li>방향성</li>
<li>연관관계의 주인</li>
</ol>
<p>이 중, 방향성과 연관관계의 주인에 대해서는 <a href="https://blog.coderoad.kr/relational-mapping-basic" target="_blank" rel="noopener noreferer">연관관계 매핑이란?</a>에서 <strong>연관관계 매핑에는 단방향과 양방향 연관관계 매핑</strong>이 있으며, 양방향 연관관계에서는 <strong>연관관계의 주인은 외래 키가 있는 곳으로 정해야 한다</strong>는 것을 알게 됐습니다. 고려해야하는 3가지 요소들 중 2가지는 이미 잘 알고 있으니 남은 하나인 다중성에 대해 공부하려고 합니다.</p>
<p>다중성 모델에는 총 4가지의 모델이 있습니다. 그리고 각 모델은 어노테이션을 통해 설정할 수 있습니다.</p>
<ul>
<li>다대일(N:1) - <code>@ManyToOne</code></li>
<li>일대다(1:N) - <code>@OneToMany</code></li>
<li>일대일(1:1) - <code>@OneToOne</code></li>
<li>다대다(N:M) - <code>@ManyToMany</code></li>
</ul>
<h2 id="다대일-n1" class="heading">다대일 (N:1)</h2>
<p>첫 번째 다중성은 가장 많이 사용되는 <strong>다대일</strong>(N:1)이며, N쪽에 외래 키(연관관계의 주인)가 있어야 합니다. 다대일의 반대는 일대다(1:N)입니다. 자세하게는 방향성까지 포함한 <strong>다대일 단방향</strong>과 <strong>다대일 양방향</strong> 연관관계 매핑이 있습니다. 먼저, 다대일 단방향에 대해 알아보겠습니다.</p>
<img width="921" alt="monon1" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/49d0d991-db67-48b1-86f7-ea2d1eab4320">
<div align="center"><I>다대일 단방향 연관관계 매핑</I></div>
<br>
<p>다대일 단방향 연관관계는 엔티티의 참조 필드에 <code>@ManyToOne</code> 어노테이션을 이용해 설정할 수 있습니다. 또한, <code>@JoinColumn</code>을 이용해 테이블에 있는 외래키와 연관관계 매핑을 하면 비로소 다대일 단방향 연관관계 매핑이 완료됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@ManyToOne</span> <span class="token comment">// 다대일 연관관계 매핑</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">)</span> <span class="token comment">// Member 테이블의 외래 키인 TEAM_ID 컬럼과 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Team</span> team<span class="token punctuation">;</span> <span class="token comment">// 참조 필드</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>반대편 엔티티인 <code>Team</code>에서는 양방향 연관관계가 아니기 때문에 별도로 설정할 것은 없습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이때, <code>Team</code> 엔티티 코드에 연관관계의 주인인 '다'쪽, 그러니까 <code>Member</code> 엔티티 쪽을 향한 참조 필드(보통 List)를 만들고 <code>@OneToMany</code> 어노테이션과 <code>mappedBy</code> 속성에 자신을 가리키고 있는 <code>Member</code> 엔티티의 <code>team</code> 필드를 적어주면 <strong>다대일 양방향 연관관계 매핑</strong>이 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"team"</span><span class="token punctuation">)</span> <span class="token comment">// 양방향 연관관계</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> members <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><a href="https://blog.coderoad.kr/relational-mapping-basic" target="_blank" rel="noopener noreferer">연관관계 매핑이란?</a> 포스트에서도 정리했지만 양방향 연관관계 매핑에서 연관관계의 주인이 아닌 엔티티는 데이터베이스 테이블에 아무런 영향을 주지 못합니다.</p>
<p>즉, 주인이 아닌 엔티티의 주인을 향한 참조 필드는 단순하게 Java 코드에서 역방향 조회를 편하게 하기 위해 만드는 조회용 필드일 뿐입니다. 조회용 필드를 수정해도 해당 데이터는 데이터베이스에 저장되지 않기 때문에 꼭 주의해야합니다.</p>
<h2 id="일대다-1n" class="heading">일대다 (1:N)</h2>
<p>다음은 다대일의 반대인 <strong>일대다</strong>(1:N) 다중성입니다. 이 다중성은 실무에서는 거의 사용하지 않는다고 합니다. 그 이유는 일대다 다중성을 통해 연관관계 매핑을 하면 객체와 테이블 사이의 차이를 줄이지 못하고 오히려 혼란을 일으킬 수 있기 때문입니다.</p>
<p>일대다 다중성에서는 연관관계의 주인이 '일'쪽이 되는데, 지금까지 작성한 예제 코드로는 <code>Team</code> 엔티티가 연관관계의 주인이 되는 것입니다. 문제는, 데이터베이스에서는 외래 키를 가지고 있는 테이블이 <code>Team</code>이 아니라 <code>Member</code>라는 것입니다.</p>
<img width="935" alt="onetomany_diagram" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/a5eecee8-73d7-4d33-86e1-2c3e432825ac">
<div align="center"><I>연관관계의 주인 엔티티와 외래 키가 있는 테이블이 서로 다르다</I></div>
<br>
<p>연관관계의 주인은 외래 키를 관리해야 되는데, 외래 키가 반대편 테이블에 있기 때문에 연관관계 관리를 위해 추가적인 <code>UPDATE</code> 쿼리가 발생합니다. <code>Team</code> 엔티티를 추가로 생성하거나 수정하면 어쩔 수 없이 <code>Member</code> 테이블도 수정이 필요한 것입니다.</p>
<p>테이블의 수가 적으면 큰 문제가 없을 수도 있지만, 규모가 큰 데이터베이스, 여러 테이블이 서로 맞물려 있는 상황에서는 예기치 못한 오류가 발생할 가능성이 높습니다. 그러나, 객체 입장에서는 충분히 <code>Team</code>만 <code>Member</code>를 참조할 수 있도록 설계할 수도 있기 때문에, JPA가 공식적으로 해당 다중성 모델을 지원하는 것입니다.</p>
<p>따라서, 우리는 객체지향 관점에서 조금 손해 보더라도 다대일 단방향 연관관계를 기준으로 매핑을 설계하고 필요한 경우에만 다대일 양방향 연관관계를 추가하는 방식으로 역방향 조회 기능을 추가하는 것이 좋습니다.</p>
<p>그래도 일대다 역시 JPA가 공식 지원하는 모델이기 때문에 방법을 알아보겠습니다. 일대다 단방향 연관관계 매핑은 다음과 같이 설정할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToMany</span> <span class="token comment">// 일대다 연관관계 매핑</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">)</span> <span class="token comment">// 외래 키와 연관관계의 주인 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> members <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이미 눈치채신 분들도 계시겠지만 연관관계의 주인 쪽에 작성하게 되는 다중성 모델 어노테이션(여기서는 <code>@OneToMany</code>)에는 <code>mappedBy</code> 속성을 작성하지 않습니다. <code>mappedBy</code>가 연관관계의 주인의 반대편에서 주인 쪽을 가리키는 속성인 것을 생각하면 당연한 일입니다.</p>
<p><code>mappedBy</code>에 한가지 숨겨진 비밀이 더 있습니다. 바로, <code>@ManyToOne</code>에는 <code>mappedBy</code> 속성이 존재하지 않는다는 것입니다. 즉, <code>@ManyToOne</code>은 <code>mappedBy</code> 속성 자체를 지원하지 않으며, 이는 곧, <strong><code>@ManyToOne</code>이 연관관계의 주인에서만 사용된다</strong>는 것을 말합니다.</p>
<img width="840" alt="ManyToOne" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/2342b297-e753-451e-b9db-028c7d6fbf80">
<div align="center"><I>@ManyToOne 어노테이션</I></div>
<br>
<img width="840" alt="OneToMany" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/51142e30-a374-4a73-a55a-ca26487ace35">
<div align="center"><I>@OneToMany 어노테이션</I></div>
<br>
<p>두 어노테이션의 공식 문서를 확인해보면 실제로 <code>@ManyToOne</code>에는 <code>@OneToMany</code>에는 있는 <code>mappedBy</code> 속성이 없다는 것을 확인할 수 있습니다.</p>
<blockquote>
<p><strong>연관관계의 주인은 외래 키와 매핑된다</strong>는 것을 생각하면 <code>@ManyToOne</code>에 <code>mappedBy</code> 속성이 없는 것과 실무에서 자주 사용되는 것이 어쩌면 당연한 결과인 것 같습니다. 데이터베이스 테이블은 '다'쪽에 항상 외래 키가 있고, 해당 테이블과 매핑한 엔티티 쪽이 연관관계의 주인이 되는 것이 가장 자연스럽고 이해하기 쉬운 설계이니 <code>@ManyToOne</code>을 기본으로 설계하는 것이라고 생각합니다.</p>
</blockquote>
<p>추가로 일대다 연관관계 매핑 시, <code>@JoinColumn</code>을 꼭 같이 작성해줘야 합니다. 만약, <code>@JoinColumn</code>을 사용하지 않으면 외래 키가 있는 테이블과 그 반대 테이블 간의 중간 테이블이 생성됩니다.</p>
<p>일대다 양방향 연관관계 매핑도 가능은 하지만 공식적으로 존재하는 매핑 모델도 아니며, 연관관계의 주인 반대편에 있는 참조 필드를 읽기 전용을 바꾸는 추가 작업이 필요합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@ManyToOne</span> <span class="token comment">// 양방향 연관관계</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">,</span> insertable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 읽기 전용이 된다</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Team</span> team<span class="token punctuation">;</span> <span class="token comment">// 원래는 연관관계의 주인이 되어야 하지만...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="일대일-11" class="heading">일대일 (1:1)</h2>
<p><strong>일대일</strong>(1:1) 모델은 반대도 일대일입니다. 일대일 모델에서는 주 테이블(<code>Member</code>)과 대상 테이블(<code>Locker</code>), 둘 중 외래 키를 둘 곳을 결정해야 합니다. 또한, 외래 키에 <code>UNIQUE</code> 제약 조건을 걸어야 합니다.</p>
<p>먼저, 주 테이블에 외래 키를 두고 단방향 연관관계 매핑 하는 방법입니다. <code>@OneToOne</code> 어노테이션을 활용합니다.</p>
<img width="870" alt="onetoone" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/d203a0e6-0c4c-4528-8e6d-016d566dba14">
<div align="center"><I>일대일 단방향 연관관계 매핑</I></div>
<br>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 주 테이블 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToOne</span> <span class="token comment">// 일대일 연관관계 매핑</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"LOCKER_ID"</span><span class="token punctuation">)</span> <span class="token comment">// 외래 키 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Locker</span> locker<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 대상 테이블 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Locker</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"NAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>구현 방법 자체는 다대일 단방향 연관관계와 별반 다를게 없습니다. 만약 일대일 양방향으로 만들고 싶다면 다음과 같이 <strong>대상 테이블 엔티티를 수정</strong>해주면 됩니다.</p>
<img width="868" alt="onetoone_bidirect" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/6468744f-99cb-4939-a358-b6341fc528a9">
<div align="center"><I>일대일 양방향 연관관계 매핑</I></div>
<br>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 대상 테이블 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Locker</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"NAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToOne</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"locker"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Member</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>일대일 양방향 역시 다대일 양방향 연관관계 매핑과 어노테이션을 제외하면 매우 유사합니다. 다음은 대상 테이블에 연관관계를 두고 연관관계 매핑하는 방법입니다.</p>
<p>대상 테이블에 외래 키를 두는 방식에는 단방향 연관관계 자체가 존재하지 않습니다.</p>
<img width="875" alt="onetoone_no" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/7a349be5-f464-4e2d-9008-6b83ca4a880b">
<div align="center"><I>대상 테이블에 외래 키를 둔 단방향 연관관계 매핑 모델은 존재하지 않는다.</I></div>
<br>
<p>양방향 연관관계 매핑은 가능한데, 연관관계의 주인이 외래 키를 가진 테이블이 됩니다. 사실, 주 테이블에 외래 키를 둔 연관관계 매핑과 구현 방법 자체는 전혀 다를게 없습니다.</p>
<img width="875" alt="onetoone_bidirect_target" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/a3f17de8-bbe3-4f6d-a8d3-ed7023a42780">
<div align="center"><I>주 테이블에 외래 키를 둔 양방향 연관관계 매핑과 연관관계의 주인 위치만 다르다.</I></div>
<br>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 주 테이블 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 연관관계의 주인을 가리킨다</span>
</span><span class="code-line">    <span class="token annotation punctuation">@OneToOne</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"member"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Locker</span> locker<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 대상 테이블 엔티티</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Locker</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"NAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToOne</span> <span class="token comment">// 일대일 양방향 연관관계</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"MEMBER_ID"</span><span class="token punctuation">)</span> <span class="token comment">// 외래 키와 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Member</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>일대일 연관관계 매핑을 정리하자면 다음과 같습니다.</p>
<p><strong>주 테이블 외래 키 방식</strong></p>
<ul>
<li>주 테이블에 외래 키를 두고 대상 테이블 탐색</li>
<li>객체지향 개발자가 선호</li>
<li>JPA 매핑 관리</li>
<li>주 테이블만 조회해도 대상 테이블에 데이터가 존재하는지 확인 가능</li>
<li>값이 없으면 외래키에 <code>NULL</code> 허용</li>
</ul>
<p><strong>대상 테이블 외래 키</strong></p>
<ul>
<li>전통적인 데이터베이스 개발자가 선호</li>
<li>주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지</li>
<li><strong>프록시</strong> 기능의 한계로 <strong>지연 로딩</strong>으로 설정해도 항상 즉시 로딩됨</li>
</ul>
<p>여기서 프록시와 지연 로딩은 좀 더 공부하고 추후에 정리하려고 합니다. 결국 객체지향 개발자인 우리는 주 테이블에 외래 키를 두는 방식을 사용하는 것이 더 편리할 수 있습니다. 물론, 연관관계 매핑 방식을 결정하기 전에 함께 작업하는 팀의 DBA와의 적절한 합의가 이뤄져야 합니다.</p>
<h2 id="다대다-nm" class="heading">다대다 (N:M)</h2>
<p>다음은 다대다 다중성 모델입니다. 결론부터 말하자면, <strong>관계형 데이터베이스는 정규화 된 테이블 2개를 다대다 관계로 표현할 수 없습니다</strong>. 이 모델이 JPA가 지원은 하지만 애초에 RDB에서 표현할 수 없기 때문에 당연히 실무에서도 사용하지 않는다고 합니다.</p>
<img width="920" alt="manytomany" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/7d291384-ca4c-4ac6-956a-14517662f66b">
<div align="center"><I>관계형 데이터베이스에서는 다대다가 존재할 수 없다.<br>중간 테이블을 통해 연결해야만 한다.</I></div>
<br>
<p>그러나, 객체는 다대다 관계가 성립할 수 있기 때문에 객체와 관계형 데이터베이스를 매핑하기 위해선 JPA가 다대다 관계를 어떻게든 표현해야합니다. 방법은, 두 테이블의 다대다 연관관계를 일대다, 다대일 관계로 풀어서 표현하는 것입니다.</p>
<p>자세하게는 연관관계를 가져야 하는 두 테이블 사이에 중간 <code>JOIN</code> 테이블을 만들고, 중간 테이블과 1:N, N:1 관계로 각각 설정해 N:M처럼 동작하게 하면 됩니다. 코드로는 앞서 살펴본 여러 예제 코드들처럼 <code>@ManyToMany</code> 어노테이션을 활용해 다대다 연관관계를 설정하고, <code>@JoinTable</code>을 통해 중간 테이블을 만들면 구현할 수 있습니다.</p>
<p>그런데 이 방식을 사용하지 않는 이유가 또 있습니다. 두 테이블의 가교 역할을 하는 중간 테이블이 둘을 연결해주는 역할 뿐만 아니라 값을 가져야 하는 상황이 발생하면 이를 테이블에 추가할 방법이 없다는 것입니다.</p>
<img width="1140" alt="jointable_value" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/5b791115-45f4-43da-825d-fe6e6999dd9f">
<div align="center"><I>중간 테이블이 값을 가져야 한다면...</I></div>
<br>
<p>따라서, 다대다 관계를 사용하기 위해서는 중간 테이블을 엔티티로 승격시켜야 합니다. 이렇게 되면, 엔티티로 승격된 중간 테이블은 원래의 양쪽 엔티티와 <code>@OneToMany</code>를 통한 일대다, <code>@ManyToOne</code>을 통한 다대일 관계가 만들어지는 것이고 다대다라고 할 수 없게 됩니다.</p>
<img width="1018" alt="jointabletoentity" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/03354169-1917-4bd6-8daf-eaa1cda21d2e">
<div align="center"><I>중간 테이블을 Order 엔티티로 승격</I></div>
<br>
<p>즉, <code>@ManyToMany</code>를 사용해 다대다 관계를 만들려고 해도 결국에는 일대다, 다대일 관계로 변화하게 되고 억지로 사용하더라도 여러 문제를 발생시키며, 데이터베이스에는 애초에 존재하지 않는 모델이기 때문에 사용하지 않는 것이 좋다고 생각합니다.</p>
<h2 id="요약" class="heading">요약</h2>
<ul>
<li>연관관계 매핑에서는 다중성도 고려해야 한다.</li>
<li>다중성 모델로는 다대일, 일대다, 일대일, 다대다가 있다.</li>
<li>가장 많이 사용하는 방식은 다대일 단방향 연관관계 매핑이다.</li>
<li>일대다와 다대다가 실무에서 잘 사용되지 않는 이유는 불필요한 작업이 필요하기 때문이다.</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[연관관계 매핑이란?]]></title>
    <link>https://blog.hangilog.kr/relational-mapping-basic</link>
    <pubDate>2023-07-06</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/relational-mapping-basic</guid>
    <description>
    <![CDATA[연관관계의 방향과 연관관계의 주인]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 04 -->
<h2 id="연관관계" class="heading">연관관계?</h2>
<p>JPA와 같은 ORM 기술을 공부하다 보면, '<strong>연관관계</strong>'라는 단어를 자주 마주칠 수 있습니다. 이 단어는 먼저 객체지향 설계의 목표를 알아야 완벽하게 이해할 수 있습니다. <a href="https://blog.coderoad.kr/essence-oop" target="_blank" rel="noopener noreferer">객체지향의 사실과 오해</a>라는 책에선 객체지향 설계의 목표를 다음과 같이 설명합니다.</p>
<blockquote>
<p><strong>객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.</strong></p>
</blockquote>
<p>만약 우리가 객체지향 설계 목표를 잘 지키며 서비스를 만들고자 한다면 <strong>자율적인 객체</strong>들의 <strong>협력</strong>을 통해 사용자가 원하는 결과를 도출해내야합니다. 당연하게도 우리가 데이터베이스 테이블과 매핑한 엔티티들 역시 객체이며, 협력을 통해 우리가 원하는 결과를 만들어내도록 해야합니다. 즉, 객체지향 설계를 위해서 우리는 엔티티들에게 적절한 연관관계를 부여하여 엔티티들끼리 협력하게 해야 합니다. 그런데, 우리가 데이터베이스 <strong>테이블에 맞춰서 매핑한 엔티티</strong>들 간에는 <strong>연관관계가 전혀 없습니다</strong>. 아래는 연관관계가 없이 설계한 테이블 스키마와 엔티티입니다.</p>
<img width="970" alt="object" src="https://github.com/SKHUMEET/skhumeet-backend/assets/14046092/fb8b2fc1-f023-4b1c-b0fa-25d940a086f6">
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> teamId<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<div align="center"><I>데이터베이스 테이블에 맞춰서 설계한 Member 엔티티</I></div>
<br>
<img width="975" alt="table" src="https://github.com/GDSC-SKHU/moida-backend/assets/14046092/316a2087-d942-4b74-a5cd-71d56e5f85aa">
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<div align="center"><I>데이터베이스 테이블에 맞춰서 설계한 Team 엔티티</I></div>
<p>얼핏 보면 <code>Member</code> 엔티티에 있는 외래키 속성 덕분에 연관관계가 있는 것처럼 보일 수도 있지만 두 엔티티 객체 사이에는 아무런 연관관계도 없습니다. <code>Member</code>에서 <code>Team</code>을 바로 참조할 방법도, <code>Team</code>에서 <code>Member</code>를 바로 참조할 방법도 없습니다. 유일하게 두 엔티티가 연관될 수 있는 방법은 <code>Member</code>의 <code>teamId</code> 값을 통해 데이터베이스에서 <code>Team</code>을 찾는 것입니다. 데이터베이스 테이블 스키마대로 엔티티를 설계했기 때문에 데이터 저장에는 문제가 없지만 이 방법은 두 객체가 협력할 방법이 전혀 없는 <strong>객체지향스럽지 않은 설계</strong>입니다. 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것인데, 협력은 커녕 불필요한 추가 작업만 늘어나는 설계가 되어버렸습니다. 즉, 객체를 테이블에 맞춰서 데이터를 중심으로 설계하면 객체 간의 협력 관계를 구축할 수 없습니다. 이러한 문제가 발생한 이유는 객체와 테이블이 서로 자신과 연관된 요소를 찾는 방법에 큰 차이가 있기 때문입니다.</p>
<h2 id="단방향-연관관계" class="heading">단방향 연관관계</h2>
<p>따라서, 테이블과 객체 사이의 차이를 줄이기 위해 우리는 객체에도 연관관계를 부여하고 이 <strong>연관관계를 테이블과 매핑</strong>해야합니다. 즉, <strong>연관관계 매핑</strong>이 이뤄져야 합니다.</p>
<blockquote>
<p>연관관계 매핑에서 매핑(Mapping)은 한자로 사상(寫像)이라고 합니다. 단어만 보면 이해하기 어려울 수 있지만, 매핑은 어떠한 값에 다른 값을 대응시키는 모든 과정을 말합니다.</p>
</blockquote>
<p>연관관계 매핑은 <strong>참조 필드</strong>(Reference Field)를 통해 객체에 <strong>연관관계를 부여</strong>하고 이 <strong>참조 필드를 테이블의 외래 키(Foreign Key)에 매핑</strong>하는 것입니다. 아래 코드는 객체와 테이블의 연관관계를 매핑한 후, 다시 설계한 엔티티입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"USERNAME"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// @Column(name = "TEAM_ID")</span>
</span><span class="code-line">    <span class="token comment">// private Long teamId;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@ManyToOne</span> <span class="token comment">// 다대일 연관관계 매핑</span>
</span><span class="code-line">    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">)</span> <span class="token comment">// Member 테이블의 외래 키인 TEAM_ID 컬럼과 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Team</span> team<span class="token punctuation">;</span> <span class="token comment">// 참조 필드</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이전에 테이블에 맞춰 설계한 엔티티는 <code>Team</code>의 ID만 가지고 있어 바로 <code>Team</code>의 여러 정보들을 접근할 수 없었습니다. 즉, 두 객체는 협력하는 객체가 아니었습니다. 그러나, 연관관계 매핑 이후에는 참조 필드를 통해 바로 원하는 데이터를 얻을 수 있게 되었고 비로소 협력 관계를 갖게 되었습니다. 데이터베이스 테이블이 외래 키를 활용한 <code>JOIN</code> 연산을 통해 자신과 연관된 다른 테이블을 바로 조회하는 것처럼, 객체도 자신과 연관된 다른 객체를 바로 참조할 수 있게 된 것입니다. 우리는 연관관계 매핑을 통해 객체와 테이블 사이의 차이를 좁혔습니다!</p>
<p>사실, <strong>ORM 기술의 핵심</strong>이 바로 이 <strong>연관관계 매핑</strong>입니다. ORM(Object-Relational Mapping)이라는 이름에서부터 알 수 있듯이, ORM은 객체와 관계형 데이터베이스를 매핑하여 둘 사이의 차이로 발생하는 여러 문제를 해결하는 것이 목표입니다. 그러니 연관관계 매핑에 대해 제대로 이해하고 JPA를 사용하는 것과 이해하지 못하고 사용하는 것에는 객체와 테이블과 같이 큰 차이가 있습니다.</p>
<p>그렇다면 연관관계에는 어떤 것들이 있을까요? 먼저 알아볼 연관관계는 <strong>단방향 연관관계</strong>입니다. 위의 <code>Member</code> 엔티티가 바로 단방향 연관관계를 설정한 엔티티입니다. 단방향 연관관계는 참조 필드를 통해 연관관계를 설정한 엔티티에서만 반대편 엔티티를 조회할 수 있는 연관관계를 말합니다. '단방향'이기 때문에 반대편 엔티티인 <code>Test</code>에는 <code>Member</code>를 향한 참조 필드가 존재하지 않습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// Test에서는 Member를 참조할 방법이 없다...</span>
</span><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>하지만 데이터베이스 테이블은 외래 키와 <code>JOIN</code> 연산을 통해 어느 쪽에서든 조회가 가능합니다.</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
</span><span class="code-line"><span class="token keyword">FROM</span> MEMBER M
</span><span class="code-line"><span class="token keyword">JOIN</span> TEAM T <span class="token keyword">ON</span> M<span class="token punctuation">.</span>TEAM_ID <span class="token operator">=</span> T<span class="token punctuation">.</span>TEAM_ID
</span></code></pre>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
</span><span class="code-line"><span class="token keyword">FROM</span> TEAM T
</span><span class="code-line"><span class="token keyword">JOIN</span> MEMBER M <span class="token keyword">ON</span> T<span class="token punctuation">.</span>TEAM_ID <span class="token operator">=</span> M<span class="token punctuation">.</span>TEAM_ID
</span></code></pre>
<div align="center"><I>두 SQL 쿼리 모두 JOIN 연산을 수행하고 같은 결과를 얻을 수 있습니다.</I></div>
<p>다시 객체와 데이터베이스 간의 차이가 나타났습니다. 그러나 외래 키 하나로 두 테이블의 연관관계를 간단하게 관리하는 데이터베이스처럼 객체도 양쪽 모두 연관관계를 가지게 할 수 있습니다.</p>
<h2 id="양방향-연관관계" class="heading">양방향 연관관계</h2>
<p>두 엔티티가 서로를 참조할 수 있게 하려면 <strong>양방향 연관관계</strong>를 객체에 설정하면 됩니다. 반대편 엔티티에도 참조 필드를 통해 연관관계를 설정해주면 간단하게 양방향 연관관계를 가질 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Entity</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Team</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Id</span> <span class="token annotation punctuation">@GeneratedValue</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"team"</span><span class="token punctuation">)</span> <span class="token comment">// 일대다 연관관계 매핑</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> members <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 한 팀에는 여러 멤버가 속한다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 엔티티를 설계하면 <code>Team</code>에서도 <code>Member</code>들의 정보를 조회할 수 있습니다. 양방향 연관관계가 완성된 것입니다. 그러나 엄밀히 말하자면 '양방향' 연관관계가 아니라 <strong>2개의 '단방향' 연관관계</strong>가 만들어진 것입니다. 잘 생각해보면 양방향 연관관계를 위해 <strong>2개의 서로 다른 참조 필드</strong>가 필요하다는 것을 알 수 있습니다. 1개의 외래 키를 통해 두 연관된 테이블의 양방향 연관관계를 설정할 수 있었던 데이터베이스와 달리 객체는 2개의 단방향 연관관계로 양방향 연관관계처럼 만든 것입니다.</p>
<p>그런데, 앞서 연관관계 매핑은 객체의 참조 필드를 테이블의 외래 키에 매핑하는 것이라고 설명했습니다. 여기서 정말 너무나 중요한 개념이 등장하게 됩니다. 도대체 외래 키는 어느 참조 필드가 관리해야할까요?</p>
<h2 id="연관관계의-주인" class="heading">연관관계의 주인</h2>
<p>우리는 두 개의 참조 필드 중 하나를 선택해서 외래 키와 매핑해야합니다. 이때, <strong>외래 키를 관리하는 참조 필드를 가진 엔티티</strong>를 <strong>연관관계의 주인</strong>이라고 합니다. 연관관계의 주인만이 외래 키를 관리하고 연관관계의 주인이 아닌 엔티티는 참조 필드를 통해 데이터의 조회만 가능합니다. 이런 이유로 연관관계의 주인의 매핑을 <strong>진짜 매핑</strong>이라 하고, 주인의 반대 쪽의 매핑을 <strong>가짜 매핑</strong>이라고 합니다.</p>
<p>우리는 데이터베이스 테이블을 보면 외래 키가 존재하는 테이블을 알 수 있습니다. 해당 테이블을 객체로 나타낸 엔티티가 연관관계의 주인이 됩니다. 즉, <strong>외래 키의 위치</strong>가 연관관계의 주인을 결정합니다. 우리가 작성한 코드에서는 <code>Member</code>가 연관관계의 주인인 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// Member 테이블의 외래 키 TEAM_ID와 매핑한 참조 필드</span>
</span><span class="code-line"><span class="token comment">// 외래 키를 가지고 있으므로 Member 엔티티가 연관관계의 주인이 된다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@ManyToOne</span>
</span><span class="code-line"><span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"TEAM_ID"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Team</span> team<span class="token punctuation">;</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 연관관계의 주인 반대편은 mappedBy 속성을 통해 자신을 참조하는 필드의 이름을 지정해야한다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"team"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> members <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 이 필드는 오직 조회만 가능하다.</span>
</span></code></pre>
<p><code>@OneToMany</code> 어노테이션의 <code>mappedBy</code>가 바로 연관관계의 주인을 지정하는 속성이었습니다. 따라서 연관관계의 주인 쪽에는 <code>mappedBy</code> 사용할 일도 없고 사용해서도 안됩니다.</p>
<blockquote>
<p><code>@ManyToOne</code>과 <code>@OneToMany</code>는 연관관계의 다중성을 나타내는 어노테이션입니다. <a href="https://blog.coderoad.kr/relational-mapping-types" target="_blank" rel="noopener noreferer">다양한 연관관계 매핑</a>에 정리했습니다.</p>
</blockquote>
<p>이렇게 양방향 연관관계의 연관관계의 주인도 지정하며 참조 필드와 외래 키와의 매핑도 잘되었습니다. 이제 몇가지 실수하기 쉬운 상황만 유의한다면 객체와 테이블 간의 차이는 거의 없다시피 할 수 있습니다. 첫번째 상황은 연관관계의 주인에 아무런 값도 입력하지 않는 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Team</span> team <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Team</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">team<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Team CodeRoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>team<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"CodeRoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token comment">// 주인이 아닌 방향만 연관관계 설정</span>
</span><span class="code-line">team<span class="token punctuation">.</span><span class="token function">getMembers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>위의 코드와 같이 객체들을 생성하고 데이터베이스에 저장하게 되면 <code>CodeRoad</code> 멤버는 어떠한 팀에도 속하지 않는 상황이 발생합니다. 위 코드의 어느 곳에도 연관관계의 주인에 값을 넣어주는 부분이 없습니다. 연관관계 매핑은 객체와 테이블을 매핑해줄 뿐이지 값을 자동으로 입력해주는 것이 아닙니다!</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"CodeRoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">team<span class="token punctuation">.</span><span class="token function">getMembers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token comment">// 연관관계의 주인에 값 입력</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setTeam</span><span class="token punctuation">(</span>team<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>이렇게 연관관계의 주인에도 값을 입력해주면 <code>CodeRoad</code> 멤버가 속한 팀의 <code>TEAM_ID</code>가 데이터베이스에 제대로 저장됩니다. 양방향 연관관계에서는 양쪽 객체가 순수한 객체 상태에서 서로를 제대로 참조할 수 있도록 양쪽 모두에 값을 입력해줘야 합니다. 만약, 어느 한 쪽을 깜빡 잊고 입력하지 않는 상황을 피하고 싶다면 <strong>연관관계 편의 메소드</strong>를 작성해 한 쪽이 저장될 때 다른 쪽도 자동으로 저장될 수 있도록 할 수 있습니다.</p>
<p>또한, 양방향 매핑 시에는 <strong>무한 루프를 주의</strong>해야 합니다. 예를 들어, <code>toString()</code>을 사용하거나 <code>JSON</code> 생성 시에 엔티티의 필드들을 모두 읽는데 이때, 참조 필드를 타고 들어가 반대편 엔티티의 필드도 모두 읽게 됩니다. 그런데, 반대편에서도 원래의 엔티티를 참조할 수 있기 때문에 또 다시 같은 작업을 무한히 반복하는 대참사가 발생할 수도 있습니다.</p>
<blockquote>
<p>저는 REST API 서버를 구축할 때, 사용자가 요구하는 내용을 DTO를 통해 전달하는 과정에서 엔티티의 참조 필드가 가리키는 객체의 내용까지 모두 JSON String으로 변환되어 불필요하거나 감춰야 하는 정보가 외부로 노출되었던 경험이 있습니다. 양방향 연관관계를 사용했을 때는 너무 많은 참조로 인해 <code>StackOverFlow</code>가 발생하기도 했습니다.</p>
</blockquote>
<p>정리하자면, <strong>단방향 연관관계 매핑만으로</strong>도 충분히 <strong>연관관계 매핑을 완료</strong>할 수 있습니다. 양방향 연관관계는 반대 방향으로(연관관의 주인의 반대편에서) 참조하는 로직이 자주 필요한 상황이 아니면 굳이 사용할 이유가 없습니다.</p>
<p>거기다 연관관계의 주인의 반대편은 조회만 가능하기 때문에 데이터베이스에 영향도 주지 않습니다. 반대편의 엔티티의 참조 필드와 매핑 되는 컬럼이 테이블에 존재하지도 않을 뿐더러, 엔티티에서 해당 참조 필드의 값을 수정해도 테이블에는 아무런 변화가 없습니다.</p>
<p>이 말은 곧, 서비스 로직에서 <strong>양방향 연관관계를 위해 작성한 반대편 참조 필드의 값만 수정하고 정작 연관관계의 주인의 값을 변경하지 않게 되면 예기치 못한 문제가 발생</strong>할 수 있다는 것입니다. 양방향 연관관계는 객체 그래프 탐색을 위해 반대 방향 조회 기능만 추가하는 용도로 사용하는 것이 좋습니다.</p>
<p>실제로 제가 프로젝트를 진행할 때, 연관관계의 주인 쪽에 단방향 연관관계만 설정하고 데이터베이스 테이블의 <code>JOIN</code> 연산처럼 연관관계의 주인만으로 여러 조회 기능을 설계했던 것을 생각해보면 단방향 연관관계로 엔티티를 설계하고 필요할 때만 양방향 연관관계를 추가하는 방식이 훨씬 코드를 이해하기 쉽고 데이터베이스와의 괴리감도 적었던 것 같습니다.</p>
<h2 id="요약" class="heading">요약</h2>
<ul>
<li>연관관계 매핑에는 단방향 연관관계 매핑과 양방향 연관관계 매핑이 있다.</li>
<li>양방향 연관관계 매핑은 사실 2개의 단방향 연관관계 매핑을 활용한 것이다.</li>
<li>연관관계의 주인은 외래 키 보유 여부 즉, 외래 키의 위치를 기준으로 결정한다.</li>
<li>연관관계 매핑은 단방향 연관관계 매핑만으로도 충분히 완료할 수 있다.</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[엔티티 매핑]]></title>
    <link>https://blog.hangilog.kr/entity-mapping</link>
    <pubDate>2023-07-05</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/entity-mapping</guid>
    <description>
    <![CDATA[JPA가 객체를 다루는 여러 방법들]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 03 -->
<h2 id="객체와-테이블을-매핑하기" class="heading">객체와 테이블을 매핑하기</h2>
<h2 id="데이터베이스-스키마-자동-생성" class="heading">데이터베이스 스키마 자동 생성</h2>
<h2 id="다양한-매핑" class="heading">다양한 매핑</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[영속성 관리]]></title>
    <link>https://blog.hangilog.kr/persistence-management</link>
    <pubDate>2023-07-04</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/persistence-management</guid>
    <description>
    <![CDATA[객체를 관계형 DB에 저장하는 기법]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 02 -->
<h2 id="영속성" class="heading">영속성</h2>
<p>JPA에서 가장 중요한 두 가지를 꼽자면 객체와 관계형 데이터베이스를 매핑하는 <strong>Object Relational Mapping</strong>(ORM), 그리고 <strong>영속성 컨텍스트</strong>(Persistence Context)입니다. JPA가 Java 진영의 ORM 기술이기 때문에 ORM이 중요한 것은 당연하겠지만, 영속성 컨텍스트는 도대체 무엇이길래 중요하다고 하는 것일까요? 우선, 영속성 컨텍스트가 무엇인지 알기 위해서는 <strong>영속성</strong>(Persistence)이라는 개념을 알아야 합니다.</p>
<p>위키백과에서 찾은 <a href="https://en.wikipedia.org/wiki/Persistence_(computer_science)" target="_blank" rel="noopener noreferer">영속성</a>에 대한 문서의 내용과 해당 문서의 참고문헌에 따르면 제가 이해한 영속성의 정의는 다음과 같습니다.</p>
<blockquote>
<p>어떤 객체나 상태가 그것을 생성한 프로그램(프로세스)의 종료 후에도 생존(오래 지속)하는 것. 쉽게 말해서, 데이터를 저장소에 영구히 저장하는 것을 의미함.</p>
</blockquote>
<p>즉, 우리가 다루는 JPA에서 영속성은 <strong>데이터베이스에 Java 객체를 영구히 저장하는 것, 영속 상태로 만드는 것</strong>을 의미합니다.</p>
<h2 id="entitymanager와-영속성-컨텍스트" class="heading">EntityManager와 영속성 컨텍스트</h2>
<p>그렇다면 영속성 컨텍스트는 무엇일까요? JPA의 영속성 컨텍스트는 이름에서부터 알 수 있듯, <strong>Java 객체들을 영구 저장하는 환경</strong>, 또는 <strong>영속 상태가 된 객체를 관리하는 환경</strong>이라고 생각하면 됩니다.</p>
<blockquote>
<p>다만, 한가지 오해하면 안되는 것은 <strong>영속성 컨텍스트는 논리적인 개념이지, 물리적 실체가 있는 저장소 같은 것이 아닙니다</strong>. DB처럼 개발자가 내부를 직접 확인하며 작업하는 것은 불가능합니다.</p>
</blockquote>
<p>Server가 Entity를 생성하고 저장(영속화)하면 <strong>영속성 컨텍스트에 먼저 보관</strong>되고, DB에 저장된 Entity를 조회해도 일단 <strong>영속성 컨텍스트를 확인하게</strong>됩니다. 다시 말해서 JPA를 사용하면, Server와 DB 사이의 대부분의 작업은 영속성 컨텍스트를 거쳐야 합니다!</p>
<blockquote>
<p>Entity는 '개체'라는 뜻을 가진 영단어로, 데이터베이스 엔티티라고 불리기도 합니다. <a href="https://docs.oracle.com/html/E79061_01/Content/Data%20model/Define_an_entity.htm" target="_blank" rel="noopener noreferer">Oracle</a>에 따르면 Entity는 '공통된 규칙이나 데이터를 가진 항목을 그룹화한 것'입니다. 쉽게 설명하자면 DB 테이블을 모델링하는 객체라고 봐도 무방합니다.</p>
</blockquote>
<p>그럼, 눈에 보이지 않는 논리적인 개념이머, 개발자가 내부를 확인할 수도 없는 영속성 컨텍스트는 어떻게 접근하고 활용할까요? JPA를 사용하면 영속성 컨텍스트를 거쳐야 한다는데 방법이 있어야 하지 않을까요? 당연하게도 JPA는 영속성 컨텍스트를 다루는 객체를 제공합니다.</p>
<p>바로, <code>EntityManager</code>입니다. <code>EntityManager</code>는 <code>EntityManagerFactory</code>를 통해 생성되며, 영속성 컨텍스트와 1:1 혹은 N:1의 관계를 가질 수 있습니다. Spring Framework에서는 여러 <code>EntityManager</code>가 하나의 영속성 컨텍스트를 공유하는 N:1 관계를 가집니다.</p>
<img width="542" alt="entitymanager" src="https://github.com/hangillee/coderoad.kr/assets/14046092/bf565160-42ff-41f0-bdd6-3df485414689">
<div align="center"><I>EntityManagerFactory에서 사용자 요청에 따라 생성되는 EntityManager들</I></div>
<br>
<p><code>EntityManagerFactory</code>를 생성하는 비용은 상당히 큽니다. 반면에, <code>EntityManager</code>를 생성하는 비용은 거의 없다시피 합니다. 이런 이유로 <code>EntityManagerFactory</code>는 하나만 만들어서 애플리케이션 전체가 공유하도록 설계되어 있습니다.</p>
<p>즉, <code>EntityManagerFactory</code>는 여러 스레드가 동시에 접근해도 안전합니다. 그러나 <code>EntityManager</code>는 여러 스레드가 동시에 접근하면 <strong>동시성 문제</strong>가 발생하므로 절대 스레드 간 공유가 일어나서는 안됩니다!</p>
<img width="758" alt="emrelation" src="https://github.com/hangillee/coderoad.kr/assets/14046092/b773900d-ebd5-4985-97de-04ceb4c69949">
<div align="center"><I>EntityManager와 영속성 컨텍스트의 관계</I></div>
<br>
<p>영속성 컨텍스트가 무엇이고, <code>EntityManager</code>를 통해 접근할 수 있다는 것도 알아봤습니다. 여기까지 공부하면서 들었던 생각은, '<strong>영속성 컨텍스트가 꼭 있어야 하는 이유가 있는가?</strong>'였습니다. 객체를 테이블로 매핑만 잘 해주면 되지 왜 Entity를 보관하고 관리하는 부가적인 계층이 필요했을까라는 생각이 들던 차에 영속성 컨텍스트의 장점을 공부하고 그 생각이 완전히 바뀌었습니다.</p>
<h2 id="entity의-생명주기" class="heading">Entity의 생명주기</h2>
<p>영속성 컨텍스트의 장점들을 살펴보기 전에, 정말 중요한 개념인 Entity의 생명주기에 대해서 먼저 알아보겠습니다. 여느 객체들과 마찬가지로 Entity 역시 생명주기가 있습니다. JPA에서의 Entity 생명주기는 다음과 같습니다.</p>
<img width="740" alt="entitylifecycle" src="https://github.com/hangillee/coderoad.kr/assets/14046092/c5f40fdf-a9bc-4c90-aad3-9e8b4d2562aa">
<div align="center"><I>Entity의 생명주기</I></div>
<br>
<p>생명주기에는 New, Managed, Detached, Removed의 총 4가지 상태가 있습니다. 각각 한국어로 <strong>비영속, 영속, 준영속, 삭제</strong>입니다. 생명주기의 상태들을 하나씩 자세하게 알아보겠습니다.</p>
<h3 id="비영속-new--transient">비영속 (New / Transient)</h3>
<p>가장 처음 만나게되는 Entity의 상태는 <strong>비영속</strong>(New)입니다. 객체를 단순히 생성만 한 상태로, DB나 영속성 컨텍스트와는 어떤 관련도 없는 순수한 Java 객체일 때를 말합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 비영속 (New)</span>
</span><span class="code-line"><span class="token comment">// 객체를 생성한 상태로 DB 관련 작업은 어떤 것도 하지 않았음.</span>
</span><span class="code-line"><span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"member1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"회원1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<h3 id="영속-managed">영속 (Managed)</h3>
<p>비영속 상태에서 <code>EntityManager</code>를 통해 <strong>영속성 컨텍스트에 Entity(객체)를 저장</strong>하면 Entity는 <strong>영속 상태</strong>가 됩니다. 객체를 영속성 컨텍스트에 저장할 때는 <code>EntityManager</code>의 <code>persist()</code> 메소드를 사용합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// em은 EntityManager 인스턴스</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 객체를 저장한 상태, 영속화.</span>
</span></code></pre>
<h3 id="준영속-detached">준영속 (Detached)</h3>
<p>영속 상태인 Entity를 <code>detach()</code> 메소드를 통해 영속성 컨텍스트로부터 분리하면 <strong>준영속</strong> 상태가 됩니다. 준영속 상태가 된 Entity는 더 이상 영속성 컨텍스트에 존재하지도 않고 <code>EntityManager</code>가 관리하지도 않습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">em<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 영속성 컨텍스트로부터 member 분리</span>
</span></code></pre>
<p>영속성 컨텍스트에 있는 Entity들이 준영속 상태가 되는 경우가 2가지 더 있습니다. <code>clear()</code>를 통해 영속성 컨텍스트를 완전히 비우거나, <code>close()</code>를 통해 <code>EntityManager</code> 자체를 종료해 영속성 컨텍스트를 제거하는 경우입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">em<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 영속성 컨텍스트를 완전히 초기화</span>
</span><span class="code-line">em<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 영속성 컨텍스트 종료</span>
</span></code></pre>
<p>위의 두 메소드를 사용하면 영속성 컨텍스트에 있던 영속 상태 Entity들은 모두 자동으로 준영속 상태가 됩니다. 준영속 상태는 당연히 <strong>영속성 컨텍스트로부터 분리된 상태이기 때문에 영속성 컨텍스트가 제공하는 기능을 사용하지 못합니다.</strong> (영속성 컨텍스트의 여러 기능은 아래에서 설명합니다.)</p>
<h3 id="삭제-remove">삭제 (Remove)</h3>
<p>마지막은 <code>remove()</code> 메소드를 통해 영속성 컨텍스트와 DB에서 Entity를 제거한 상태인 <strong>삭제</strong>입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">em<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>Entity는 위의 4개 상태를 가지며 <code>EntityManager</code>의 여러 메소드를 통해 상태가 변경됩니다.</p>
<h2 id="영속성-컨텍스트를-사용해야-하는-이유" class="heading">영속성 컨텍스트를 사용해야 하는 이유</h2>
<p>드디어, Entity와 <code>EntityManager</code>, 영속성 컨텍스트의 여러 특징을 끝으로 영속성 컨텍스트를 왜 사용해야 하는지 그 이유를 설명하고자 합니다. 영속성 컨텍스트의 여러 기능을 살펴보기에 앞서, 영속성 컨텍스트가 자신이 관리하는 영속 상태 Entity를 어떻게 다루는지 알아보겠습니다.</p>
<p>영속성 컨텍스트는 기본적으로 <code>@Id</code> 어노테이션으로 지정한 <strong>식별자</strong>를 통해 Entity를 구분합니다. 따라서, 영속 상태로 만들 객체(Entity)는 식별자 값을 지정해주지 없으면 에러가 발생합니다. 그럼, 영속성 컨텍스트는 왜 식별자를 사용해서 Entity를 구분하는 걸까요?</p>
<blockquote>
<p>사실 Entity를 식별자로 구분하는 것은 당연한 일입니다. DB는 고유한 Primary Key(기본키)를 통해 각 튜플을 구분합니다. 즉, 객체를 DB의 테이블과 매핑하는 기술인 JPA는 DB의 PK와 매핑될 값을 객체가 갖도록 강제해야 합니다. 이때, PK와 매핑되는 값이 바로 <code>@Id</code>를 통해 지정한 <strong>식별자</strong>인 것입니다.</p>
</blockquote>
<p>바로, 아래서 설명할 <strong>1차 캐시</strong>가 <code>Map</code> 자료구조와 같이 영속 상태가 된 Entity를 <strong>Key-Value</strong> 형태로 저장하기 때문입니다. 1차 캐시는 영속성 컨텍스트의 알파이자 오메가라 할 수 있는데, 1차 캐시의 존재 덕분에 우리가 아래의 여러 장점들을 누릴 수 있습니다. 만약, 1차 캐시라는 개념 자체가 없었다면 JPA를 사용할 이유가 없었을지도 모릅니다.</p>
<h3 id="1차-캐시">1차 캐시</h3>
<p>영속성 컨텍스트가 Entity를 구분하기 위해 식별자를 사용하고, 1차 캐시가 Entity를 다루는 방식 때문에 꼭 식별자가 필요하다는 것도 알았습니다. 이제 1차 캐시가 정확히 무슨 역할을 담당하는지 알아보겠습니다.</p>
<h3 id="동일성-보장">동일성 보장</h3>
<h3 id="트랜잭션-지원-쓰기-지연">트랜잭션 지원 쓰기 지연</h3>
<h3 id="변경-감지-dirty-checking">변경 감지 (Dirty Checking)</h3>
<h3 id="지연-로딩-lazy-loading">지연 로딩 (Lazy Loading)</h3>
<h2 id="플러시" class="heading">플러시</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[정적 팩토리 메소드]]></title>
    <link>https://blog.hangilog.kr/static-factory-method</link>
    <pubDate>2023-07-04</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/static-factory-method</guid>
    <description>
    <![CDATA[Effective Java 3/E 정리 01]]>
    </description>
    <content:encoded>
      <![CDATA[<blockquote>
<p>생성자 대신 정적 팩토리 메소드를 고려하라 - Joshua Bloch (Effective Java 3/E, 8p)</p>
</blockquote>
<h2 id="생성자와-정적-팩토리-메소드" class="heading">생성자와 정적 팩토리 메소드</h2>
<p>Java에서 클래스의 인스턴스를 생성하는 방법 중 가장 기초적이고 자연스러운 방법은 <code>public 생성자</code>를 이용하는 방법입니다. Java를 공부하는 모두가 <code>new</code> 키워드를 통해 무의식적으로 사용하고 있거나 사용해봤던 public 생성자는 매우 편리하고 직관적입니다. 심지어 생성자는 <a href="https://blog.coderoad.kr/ioc-di#%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85-di" target="_blank" rel="noopener noreferer">의존관계 주입</a>에서도 사용할 수 있습니다. 즉, public 생성자만 사용해도 Java 개발에 있어서는 큰 문제가 없다는 말입니다.</p>
<p>그러나, 모든 Java 프로그래머라면 클래스의 인스턴스를 얻을 수 있는 방법을 하나 더 알아야 합니다. 바로, <code>정적 팩토리 메소드(static factory method)</code>입니다. 그럼, 왜 정적 팩토리 메소드 방법을 알아야 할까요? 정적 팩토리 메소드의 장단점을 살펴보며 생성자 대신 정적 팩토리 메소드를 고려해봐야 하는 이유와 주의해야할 점을 알아보겠습니다.</p>
<blockquote>
<p>정적 팩토리 메소드는 디자인 패턴의 팩토리 메소드(Factory Method)와는 다릅니다!</p>
</blockquote>
<h2 id="정적-팩토리-메소드의-장점" class="heading">정적 팩토리 메소드의 장점</h2>
<p><strong>첫 번째</strong>, 정적 팩토리 메소드는 <strong>고유의 이름을 가질 수 있습니다</strong>. 이름을 가진다는게 왜 장점인지 와닿지 않을 수 있습니다. 예제 코드를 통해 알아보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> isAdmin<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> isAdmin<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>위 코드의 <code>User</code> 클래스는 생성자를 통해서 다음과 같이 인스턴스를 생성할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"normaluser"</span><span class="token punctuation">,</span> <span class="token string">"good1234"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token class-name">User</span> admin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"coderoad"</span><span class="token punctuation">,</span> <span class="token string">"hello1234"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>username</code>과 <code>password</code>, 관리자 여부를 생성자로 넘겨 일반 사용자와 관리자 인스턴스를 생성했습니다. Java로 개발 하는 프로그래머에겐 너무나 쉽고 익숙한 방식이며, 오류가 발생하는 잘못된 코드도 아닙니다. 하지만, 다음과 같이 정적 팩토리 메소드를 작성하고 사용하면, 생성자를 사용할 때보다 <strong>반환될 인스턴스의 특징을 쉽게 파악</strong>할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> isAdmin<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> isAdmin<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 정적 팩토리 메소드</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">User</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 정적 팩토리 메소드</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">User</span> <span class="token function">createAdmin</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 생성자를 사용할 때와 다르게 어떤 인스턴스가 반환될지 직관적으로 알 수 있다!</span>
</span><span class="code-line">        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token string">"normaluser"</span><span class="token punctuation">,</span> <span class="token string">"good1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token class-name">User</span> admin <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">createAdmin</span><span class="token punctuation">(</span><span class="token string">"coderoad"</span><span class="token punctuation">,</span> <span class="token string">"hello1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>코드에서 볼 수 있듯, 생성자와 다르게 정적 팩토리 메소드는 <code>createUser</code>, <code>createAdmin</code>이라는 고유의 이름을 가질 수 있습니다. 이 정적 팩토리 메소드들을 이용해 인스턴스를 생성하면 어떤 인스턴스가 반환될지 직관적으로 알 수 있습니다. (프로그래머가 제대로 작성했다는 가정하에.) 물론, 생성자도 입력 매개변수의 순서나 종류를 달리해 상황에 따른 여러 생성자를 추가할 수 있지만 결코 좋은 방법이 아닙니다.</p>
<p>왜냐하면, 여러 생성자가 있을 때, 해당 생성자의 내부 구조를 잘 알지 못하는 개발자가 엉뚱한 생성자를 호출할 위험이 있기 때문입니다. 또한, 도대체 어떤 인스턴스가 반환되는지 해당 클래스의 내부 구현을 직접 읽지 않으면 알 수 없습니다. 결국, 여러 생성자를 통한 인스턴스 생성은 실수를 방지하기 위해선 직접 코드를 살펴봐야 하는 번거로움이 발생하기 때문에, <strong>한 클래스에 여러 생성자가 필요할 것 같다</strong>면 <strong>정적 팩토리 메소드 작성을 적극 고려</strong>해봐야 합니다.</p>
<p><strong>두 번째</strong>, 정적 팩토리 메소드는 호출될 때마다 <strong>인스턴스를 새로 생성하지 않아도 됩니다</strong>.</p>
<p>생성자를 사용하면 매번 새로운 인스턴스가 생성됩니다. 그런데, 같은 값이나 상태를 가진 인스턴스를 매번 새로 만들어야 할 필요는 없습니다. 이미 만들어진 인스턴스를 활용하는 편이 메모리 측면에서도 더 나을 것입니다.</p>
<p>정적 팩토리 메소드는 이런 문제를 해결하기 위해 <strong>인스턴스를 미리 만들어 두거나 새로 생성한 인스턴스를 캐싱하는 방식</strong>으로 <strong>불필요한 중복 인스턴스를 생성하지 않습니다</strong>.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// Boolean 클래스의 일부</span>
</span><span class="code-line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Boolean</span> TRUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Boolean</span> FALSE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 정적 팩토리 메소드 valueOf()</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> b <span class="token operator">?</span> TRUE <span class="token operator">:</span> FALSE<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>실제로 Java의 <code>Boolean</code>과 같이 한 번 생성된 인스턴스의 값이나 상태가 절대 변하지 않는 <strong>불변 클래스(immutable class)는</strong> 특정 값을 가진(<code>true</code>와 <code>false</code>) 인스턴스를 <strong>미리 만들어</strong>두고 이를 <strong>정적 팩토리 메소드를 통해 반환</strong>하는 방식으로 같은 값을 가지는 중복 인스턴스 생성을 방지합니다. 이 장점은 생산 비용이 큰 객체가 자주 요청되는 상황에 성능 향상에 도움이 됩니다.</p>
<h2 id="정적-팩토리-메소드의-단점" class="heading">정적 팩토리 메소드의 단점</h2>
<h2 id="정리" class="heading">정리</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[MVC Pattern]]></title>
    <link>https://blog.hangilog.kr/mvc-pattern</link>
    <pubDate>2023-07-04</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/mvc-pattern</guid>
    <description>
    <![CDATA[Java와 Servlet]]>
    </description>
    <content:encoded>
      <![CDATA[]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Java의 ORM 표준 기술, JPA]]></title>
    <link>https://blog.hangilog.kr/about-jpa</link>
    <pubDate>2023-07-03</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/about-jpa</guid>
    <description>
    <![CDATA[객체와 관계형 DB의 조화를 위한 기나긴 여정]]>
    </description>
    <content:encoded>
      <![CDATA[<!-- 01 -->
<h2 id="jpa" class="heading">JPA?</h2>
<p>제가 주력으로 사용하는 프로그래밍 언어는 <strong>Java</strong>입니다. 대표적인 객체지향 언어이며, 우리나라 뿐만 아니라 전세계적으로 많이 사용되고 있습니다. 또한, <strong>Spring 프레임워크</strong>의 등장으로 정말 객체지향다운 객체지향 프로그래밍을 하면서도 쉽고 빠르게 웹 어플리케이션 개발이 가능해졌습니다. 백엔드 개발자를 꿈꾸는 저 역시, Spring 프레임워크와 Spring의 여러 하위 프로젝트들을 공부하면서 객체지향 프로그래밍에 대해 더 깊게 공부할 수 있었습니다.</p>
<p>그런데 첫 팀 프로젝트를 진행하며, 한가지 난관에 봉착했었습니다. 객체를 다루며 프로그래밍하는 것은 어느 정도 익숙해졌는데, 가공한 객체(데이터)를 영구히 저장하는 방법은 잘 알지 못했습니다. 어렴풋이 데이터베이스에 저장해야겠다는 생각은 있었고, 동아리 스터디 시간에 서비스 구현에 사용할 수는 있도록 정말 얉게 학습한 <strong>Spring Data JPA</strong>를 열심히 구글링해가며 프로젝트를 완성했었습니다. 익숙하지 않은 기술을 잘 모르는 채로 사용하다보니 예상대로 웹 어플리케이션의 성능은 썩 좋지 못했습니다.</p>
<p>팀 프로젝트가 끝난 후, Spring Data JPA의 근간인 <strong>JPA</strong>(Java Persistence API)를 본격적으로 공부하고자 했습니다. JPA가 <strong>ORM</strong>(Object Relational Mapping) 기술의 Java 진영 표준이라는 설명을 읽고 처음 든 생각은 <strong>ORM 기술이 도대체 무엇인가</strong>였습니다.</p>
<h2 id="sql-중심-개발의-문제점" class="heading">SQL 중심 개발의 문제점</h2>
<p>ORM 기술에 대해 공부하기 위해서는 먼저 객체와 관계형 데이터베이스의 차이에 대해서 알아야 했습니다. NoSQL 데이터베이스를 사용하는게 아닌 이상, 우리는 Java와 같은 객체지향 프로그래밍 언어를 통해 객체를 생성하면, 이를 <strong>관계형 데이터베이스</strong>에 저장해야 합니다. 어떠한 객체도 데이터베이스에 저장하지 못한다면 사용자들이 어플리케이션을 사용할 수도 없고 굳이 사용할 필요도 없기 때문이죠.</p>
<p>그런데, 객체를 관계형 데이터베이스에 바로 저장할 수는 없습니다. 객체 안에는 많은 속성들이 있고 상속관계, 연관관계 등, 다른 객체와의 복잡한 관계가 있을 수 있습니다. 심지어는 여러 객체를 가지고 하나의 객체로 묶어두는 컬렉션 객체도 있습니다.</p>
<p>ORM 기술이 없었다면, <strong>CRUD</strong>라고 불리는 등록, 조회, 수정, 삭제 연산들을 위한 SQL을 작성하기 위해서 먼저 Java 객체를 SQL로, SQL을 Java 객체로 전환하는 코드를 <strong>직접</strong> 작성해야 했습니다. 거기다 객체에 속성이라도 추가된다면 기껏 작성해놓은 SQL을 몽땅 수정해야하는 불상사가 일어나기도 했습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 만약 객체에 속성을 하나 추가한다면?</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> memberId<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-sql"><code class="language-SQL code-highlight"><span class="code-line"><span class="token comment"># 이 SQL 쿼리도 수정해야 한다.</span>
</span><span class="code-line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> MEMBER<span class="token punctuation">(</span>MEMBER_ID<span class="token punctuation">,</span> NAME<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token keyword">SELECT</span> MEMBER_ID<span class="token punctuation">,</span> NAME <span class="token keyword">FROM</span> MEMBER M
</span><span class="code-line"><span class="token keyword">UPDATE</span> MEMBER <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>즉, SQL에 의존적인 개발이 피하기 어려웠습니다. 다형성을 통한 유연한 확장이 장점인 객체지향 프로그래밍인데, 객체 데이터를 저장하려면 SQL에 의존적인 개발이 불가피한, 가장 중요한 객체지향의 원칙이 깨지는 문제가 발생한 것입니다.</p>
<h2 id="객체와-관계형-데이터베이스의-차이" class="heading">객체와 관계형 데이터베이스의 차이</h2>
<p>이렇게 치명적인 문제를 가지고 있는 SQL 중심의 개발을 할 수 밖에 없었던 이유는 <strong>객체와 관계형 데이터베이스의 패러다임 불일치</strong>에 있습니다. 객체는 어쨌든 관계형 데이터베이스에 저장하기 위해서 SQL로 변환해야 하는데, 이 작업을 모두 개발자가 해야 했기 때문에 SQL에 의존적일 수 밖에 없었습니다. 그럼, 객체와 관계형 데이터베이스 사이에 얼마나 큰 차이가 있길래 개발자가 개발은 뒷전이고 SQL 쿼리를 작성하느라 바빠진 것일까요?</p>
<h3 id="객체-vs-관계형데이터베이스---상속">객체 VS 관계형데이터베이스 - 상속</h3>
<p>패러다임 불일치 중 첫 번째는 <strong>상속</strong>입니다. 객체지향 프로그래밍에서 너무나 중요하고 핵심적인 개념인 <strong>상속은 관계형 데이터베이스에 존재하지 않습니다</strong>. 분명히 객체는 상속관계를 가지고 있는데 관계형 데이터베이스에는 상속이라는 개념이 없다보니 상속관계의 객체를 저장하기 위해서는 특수한 방법을 이용해야 합니다.</p>
<img width="1292" alt="objectrdbdiff" src="https://github.com/hangillee/coderoad.kr/assets/14046092/ecbaa265-dc84-47f7-b4ee-1e28f2df5d62">
<div align="center"><I>관계형 데이터베이스에서는 상속관계 대신 슈퍼타입 서브타입 관계를 사용한다.</I></div>
<br>
<p>대표적으로 <strong>슈퍼타입 서브타입 관계</strong>라는 설계 기법을 통해 상속관계를 유사하게 표현하지만, 이것을 객체의 상속과 동일하다고 볼 수 없습니다. 슈퍼타입과 서브타입 테이블은 엄밀히 말하자면 서로 다른 테이블이고 상속관계의 객체가 이 테이블을 조회할 때 <code>JOIN</code> 연산으로 하나로 묶어서 결과를 반환하는 것일 뿐입니다.</p>
<p>부모 객체에 대한 자식 객체가 하나라면 <code>JOIN</code> 연산 쿼리 작성은 큰 문제는 아니겠지만, 자식 객체를 통해 유연하게 확장(다형성)하는 것이 객체지향 프로그래밍임을 생각한다면 어림도 없는 이야기입니다. 당연히 이 연산을 위한 SQL 쿼리 작성과 객체와 SQL의 변환 코드는 모두 개발자가 직접 해야 합니다.</p>
<p>객체를 저장하는 것 역시 쉽지 않은 작업입니다. 객체 데이터를 저장할 때는 슈퍼타입과 서브타입 테이블 두 곳 모두에 자식 객체를 분해해서 각 테이블에 맞는 속성을 저장합니다. 즉, 하나의 객체를 저장하는데 두 테이블에 SQL 쿼리가 날아가는 것입니다.</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token comment"># 부모 객체로 부터 상속 받은 속성은 슈퍼타입 테이블에</span>
</span><span class="code-line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> ITEM <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token comment"># 자식만의 속성은 서브타입 테이블에</span>
</span><span class="code-line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> ALBUM <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>상속이 자식 객체가 부모 객체의 속성을 물려받아서 자유자재로 다룰 수 있는 것과는 분명 차이가 존재합니다. 그래서 DB에 저장할 객체에는 상속 관계를 사용하지 않습니다.</p>
<h3 id="객체-vs-관계형-데이터베이스---연관관계">객체 VS 관계형 데이터베이스 - 연관관계</h3>
<p>객체와 관계형 데이터베이스의 두 번째 불일치는 <strong>연관관계</strong>입니다. 연관관계는 서로 다른 두 객체가 <strong>참조</strong>를 통해 연결되는 것을 말합니다. 다행히도 데이터베이스 테이블 역시, <strong>외래 키</strong>를 통한 <code>JOIN</code> 연산을 활용하면 연관관계를 가질 수 있습니다. 그런데, 참조와 외래 키는 엄연히 다른 개념입니다. 참조는 다른 객체의 주소를 갖는 것과 마찬가지입니다. 따라서, 객체의 참조를 가져오는 것은 객체 그 자체를 가져오는 것이라고 볼 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// Team 객체를 향한 참조 존재. Team 객체와 연관관계를 맺음.</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">String</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">Team</span> team<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">String</span> username<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// team은 member와 연관관계를 맺는 Team 객체 그 자체를 가리킨다.</span>
</span><span class="code-line"><span class="token class-name">Team</span> team <span class="token operator">=</span> member<span class="token punctuation">.</span><span class="token function">getTeam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>문제는 관계형 데이터베이스가 <strong>객체를 객체 그 자체로 저장할 수 없다</strong>는 것입니다. DB 테이블은 연관관계를 위해 외래 키를 가지고 있어야 하고, 이 외래 키를 통해 다른 테이블과 <code>JOIN</code>한 후, 데이터를 가져와야 합니다. 외래 키가 없다면 연관관계를 절대 표현할 수 없고, 연관관계를 가진 객체를 저장할 방법도 없습니다. 결국, 이러한 관계형 데이터베이스 테이블의 한계 때문에 객체를 테이블에 맞춰서 모델링해야 합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">String</span> id<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">Long</span> teamId<span class="token punctuation">;</span> <span class="token comment">// 외래 키</span>
</span><span class="code-line">    <span class="token class-name">String</span> username<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 테이블에 맞춰서 객체를 모델링하면 데이터베이스에 객체를 저장하는 것은 간단해지지만, <strong>이런 모델링은 전혀 객제지향스럽지 않은 모델링</strong>입니다. 객체는 참조로 연관관계를 맺어야 하는데, 객체의 특정 속성을 통해 연관관계를 맺어야 하는 상황이 벌어졌습니다. 물론, 참조를 이용해 객체를 모델링하고 테이블에 저장할 때만 <code>team.getId()</code>와 같은 과정을 추가로 거쳐 SQL을 잘 작성하면 객체다운 모델링이 가능하지만, 이런 과정 자체가 번거롭고 실수하기 쉬운 작업입니다!</p>
<h3 id="객체-vs-관계형-데이터베이스---객체-그래프-탐색">객체 VS 관계형 데이터베이스 - 객체 그래프 탐색</h3>
<p>객체와 관계형 데이터베이스의 세 번째 불일치는 <strong>객체 그래프 탐색</strong>입니다. 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 합니다. 즉, 객체는 <strong>참조</strong>를 통해서 여러 객체를 넘나들며 원하는 작업을 수행할 수 있어야 합니다. 문제는 데이터베이스의 경우, 처음 실행하는 SQL에 따라 탐색 범위가 결정되어버린다는 것입니다.</p>
<img width="805" alt="objectgraph" src="https://github.com/hangillee/coderoad.kr/assets/14046092/96b19326-bce2-481a-879e-6974f639903c">
<div align="center"><I>객체는 이런 객체 그래프를 자유롭게 탐색할 수 있다.</I></div>
<br>
<p>예를 들어, 다음과 같은 SQL을 통해 객체를 조회했을 때는 객체 그래프 탐색이 제한됩니다.</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token keyword">SELECT</span> M<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token operator">*</span>
</span><span class="code-line"><span class="token keyword">FROM</span> MEMBER M
</span><span class="code-line"><span class="token keyword">JOIN</span> TEAM T <span class="token keyword">ON</span> M<span class="token punctuation">.</span>TEAM_ID <span class="token operator">=</span> T<span class="token punctuation">.</span>TEAM_ID
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">member<span class="token punctuation">.</span><span class="token function">getTeam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NULL</span>
</span></code></pre>
<p>분명히 위에서 본 객체 그래프에 의하면, <code>Member</code>와 <code>Order</code>가 연관관계를 갖고 있어 <code>Member</code>에서 <code>Order</code>로 출발하는 객체 그래프 탐색이 가능해야 합니다. 그러나, SQL에서는 오직 <code>Team</code> 테이블과 <code>JOIN</code>해서 <code>Team</code> 말고는 어떠한 객체도 탐색이 불가능합니다.</p>
<p>이런 객체 그래프 탐색의 제한은 <strong>엔티티 신뢰 문제</strong>를 일으킵니다. 객체 입장에서는 연관관계를 맺은 다른 객체를 전적으로 신뢰하고 사용할 수 있어야 하는데, 작성한 SQL에 따라 결과가 완전히 달라질 수 있다는 큰 위험이 존재하는 것입니다. 즉, 다음과 같은 코드의 결과를 전혀 예측할 수 없다는 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">Member</span> member <span class="token operator">=</span> memberDAO<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        member<span class="token punctuation">.</span><span class="token function">getTeam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 결과를 예측할 수 없음</span>
</span><span class="code-line">        member<span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDelivery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//결과를 예측할 수 없음</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이런 신뢰 불가능한 코드는 결국 서비스 로직을 구현하다 말고 <code>memberDAO</code> 같이 데이터베이스에 접근하는 객체의 코드를 직접 확인해야 하는 비효율적인 작업이 추가로 필요해집니다. 그렇다고 미리 모든 데이터를 전부 불러와서 준비해두는 것도 문제가 있습니다. 당장 사용하지 않을 객체의 테이블까지 모조리 <code>JOIN</code>해 SQL 쿼리 자체가 비대해지고 성능 저하가 발생하면 개선하기 어려워질 수도 있습니다.</p>
<p>이런 문제를 피하기 위해 모든 상황에 대비해 필요한 객체만 가져오는 메소드와 SQL 쿼리를 작성할 수도 있겠지만 이 방법 역시 여전히 효율적인 방법은 아닙니다.</p>
<h3 id="객체-vs-관계형-데이터베이스---비교">객체 VS 관계형 데이터베이스 - 비교</h3>
<p>마지막 객체와 관계형 데이터베이스 간의 불일치는 <strong>비교</strong>입니다. 어쩌면 가장 치명적일 수 있는 차이입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">String</span> memberId <span class="token operator">=</span> <span class="token string">"100"</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token class-name">Member</span> member1 <span class="token operator">=</span> memberDAO<span class="token punctuation">.</span><span class="token function">getMember</span><span class="token punctuation">(</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token class-name">Member</span> member2 <span class="token operator">=</span> memberDAO<span class="token punctuation">.</span><span class="token function">getMember</span><span class="token punctuation">(</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">member1 <span class="token operator">==</span> member2<span class="token punctuation">;</span> <span class="token comment">// false</span>
</span></code></pre>
<p>데이터베이스에서 같은 <code>memberId</code>를 기준으로 조회해도 비교 시에 두 객체가 서로 다르다는 결과를 반환합니다. 우리는 위의 코드가 데이터베이스에서 같은 데이터를 가져왔다고 생각했지만, 객체 변환 과정에서 <strong>SQL의 결과를 새로운 인스턴스로 생성해서 반환</strong>하기 때문에 객체 입장에서는 전혀 다른 객체인 것입니다. 결론적으로, 우리의 예상과는 전혀 다르게 동작하기 때문에 예기치 못한 오류가 발생할 수도 있는 것입니다.</p>
<p>지금까지 여러 불일치들을 살펴보면 객체답게 객체를 모델링할수록 SQL 매핑 작업만 늘어나는 것을 볼 수 있습니다. 여기서 한 가지 고민을 해볼 수 있습니다. <strong>객체를 Java 컬렉션에 저장하는 것처럼 DB에 저장할 수는 없을까요?</strong> 이런 고민을 해결하기 위해 등장한 기술이 바로 <strong>ORM 기술</strong>, 그 중에서도 Java 진영의 ORM 기술 표준인 <strong>JPA</strong>입니다.</p>
<h2 id="orm과-jpa" class="heading">ORM과 JPA</h2>
<p><strong>ORM</strong>은 <strong>Object-relational Mapping</strong>(객체 관계 매핑)의 약자입니다. ORM 기술을 활용하면 개발자가 객체는 객체대로 설계하고 관계형 데이터베이스는 데이터베이스대로 설계할 수 있습니다. ORM 프레임워크가 각자의 패러다임에 맞게 설계된 객체와 관계형 데이터베이스를 중간에서 매핑해주기 때문에 개발자는 더 이상 객체를 데이터베이스 테이블에 맞춰서 설계할 이유도, SQL 매핑에 시간을 쏟을 이유도 없어진 것입니다!</p>
<p>대부분의 대중적인 프로그래밍 언어에는 ORM 기술이 존재하고, 그 중 Java의 ORM 기술 표준이 <strong>JPA</strong>(Java Persistence API)입니다. 즉, ORM 기술을 Java 프로그래밍에서 잘 사용할 수 있도록 해주는 것이 JPA인 것입니다. 물론 JPA 자체만 가지고 ORM 기술을 바로 사용할 수 있는 것은 아닙니다.</p>
<p>JPA는 이름 그대로 API이기 때문에 구현 클래스 없이 인터페이스만 모아둔 <strong>표준 명세</strong>일 뿐이고, <strong>Hibernate</strong>(하이버네이트)라는 JPA의 인터페이스들을 실제로 구현한 프레임워크를 사용해야 합니다. 하이버네이트 외에도 여러 다른 구현체들도 있지만 주로 하이버네이트를 사용합니다.</p>
<h3 id="jpa의-동작">JPA의 동작</h3>
<p>JPA는 어플리케이션과 <strong>JDBC</strong>(Java Database Connectivity) API 사이에서 동작합니다. 결국 JPA도 따로 데이터베이스를 다루는 기술이 있는 것이 아니기 때문에 Java의 데이터베이스 접근 기술 API인 JDBC를 사용합니다. JPA는 단지 Java 객체와 데이터베이스 테이블 사이의 <strong>패러다임 불일치를 해결</strong>하고 <strong>번거로운 SQL 매핑 작업을 대신</strong>해주는 기술일 뿐입니다.</p>
<p>예를 들어 객체를 데이터베이스에 저장하고 조회하는 과정은 다음과 같습니다.</p>
<img width="945" alt="persist" src="https://github.com/hangillee/coderoad.kr/assets/14046092/380c2325-698c-4bbf-928a-e8208158e430">
<div align="center"><I>JPA는 엔티티를 분석해서 SQL을 작성하고 JDBC를 통해 DB에 엔티티를 저장한다.</I></div>
<br>
<img width="965" alt="find" src="https://github.com/hangillee/coderoad.kr/assets/14046092/480d0393-011d-4622-ab97-0fd5087243d2">
<div align="center"><I>DB에서 엔티티를 조회할 때도 Java 메소드에 맞게 SQL을 작성하고 JDBC를 활용한다.</I></div>
<br>
<p>얼핏 보기에도 JPA가 개발자 대신 해주는 작업의 양이 상당하다는 것을 알 수 있습니다. 개발자 대신 객체와 SQL을 매핑해주고 DB에 접근해서 저장하거나 DB로부터 데이터를 조회합니다. 이 모든 작업을 개발자가 직접 한다면 많은 시간을 DB와의 사투에 쏟아야 한다는 것이 너무나 명확하게 보입니다. 반대로, JPA를 사용하면 이런 작업들을 신경쓰지 않아도 된다는 이야기입니다!</p>
<h3 id="jpa를-사용해야-하는-이유">JPA를 사용해야 하는 이유</h3>
<p>위에서 언급한 것처럼 JPA를 사용하면 SQL 매핑, DB 연결, 패러다임 불일치 해결 등, 개발자가 수많은 부수적인 작업을 신경쓰지 않아도 됩니다. 즉, SQL 중심적인 개발에서 <strong>객체 중심 개발</strong>이 가능해지는 것입니다. 이는 높은 생산성과도 연결되는 장점입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// JPA를 활용한 예시 코드입니다. 실제로 작동하지는 않습니다.</span>
</span><span class="code-line"><span class="token comment">// CREATE</span>
</span><span class="code-line">jpa<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// READ</span>
</span><span class="code-line"><span class="token class-name">Member</span> member <span class="token operator">=</span> jpa<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// UPDATE</span>
</span><span class="code-line">member<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"NewName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// DELETE</span>
</span><span class="code-line">jpa<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>우리가 주로 작성하게 될 CRUD 코드가 너무나 간단하게 작성됩니다. 실제로 작동하는 코드는 아니지만 JPA를 활용하면 정말 위와 같이 코드를 작성합니다. 코드 어디에도 객체를 SQL과 매핑하고 데이터베이스로 SQL 쿼리를 보내는 부분은 찾아볼 수 없습니다. <code>Member</code> 객체를 중심으로 데이터베이스에 저장, 조회, 수정, 삭제하는 기능을 구현할 수 있는 것입니다.</p>
<p>당연히 SQL을 JPA가 자동으로 작성해주니 개발자는 객체의 수정을 자유롭게 할 수 있습니다. 예를 들어, <code>Member</code> 객체의 요구사항이 변경되어 필드를 하나 추가해야 하는 상황을 가정해보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Member</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> memberId<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">String</span> tel<span class="token punctuation">;</span> <span class="token comment">// 새로 추가한 필드</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약 JPA를 사용하지 않았다면 당연히 <code>Member</code>에 새로운 필드가 추가되었으니 데이터베이스의 <code>Member</code> 테이블도 수정해야하며 <code>Member</code>와 관련된 모든 SQL을 수정해야 하는지 확인해야 합니다.</p>
<pre class="language-sql"><code class="language-sql code-highlight"><span class="code-line"><span class="token comment"># 객체를 수정했더니 SQL까지 신경써야 하는 상황...</span>
</span><span class="code-line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> MEMBER<span class="token punctuation">(</span>MEMBER_ID<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> TEL<span class="token punctuation">)</span> <span class="token keyword">VALUES</span>
</span><span class="code-line"><span class="token keyword">SELECT</span> MEMBER_ID<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> TEL <span class="token keyword">FROM</span> MEMBER M
</span><span class="code-line"><span class="token keyword">UPDATE</span> MEMBER <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> TEL <span class="token operator">=</span> ?
</span></code></pre>
<p>그러나, JPA를 사용한다면 위와 같은 SQL은 전혀 신경쓰지 않아도 됩니다. JPA가 자동으로 새로 추가된 필드를 SQL에 알아서 추가해주기 때문입니다. JPA의 이러한 SQL 작성 기능은 개발자가 객체만 신경쓰면 되도록 돕습니다!</p>
<p>또한, <a href="#%EA%B0%9D%EC%B2%B4%EC%99%80-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4">객체와 관계형 데이터베이스의 차이</a> 절에서 정리한 여러 객체와 관계형 데이터베이스의 <strong>패러다임 불일치를 해결</strong>해줍니다. 상속관계, 연관관계, 객체 그래프 탐색, 객체 비교 등에서 JPA를 사용하지 않았을 때 발생하는 여러 불일치 문제를 JPA는 적절한 SQL 작성이나 동일한 트랙잭션 내에서 조회한 엔티티의 동일을 보장하는 방식을 통해 모두 해결해줍니다.</p>
<p>JPA는 객체 중심 개발을 통한 생산성 향상과 패러다임 불일치 해결 뿐만 아니라 <strong>성능 최적화 기능</strong>까지 제공합니다. 먼저, <strong>1차 캐시</strong>를 활용하는 방식입니다. JPA는 <strong>동일 트랜잭션</strong> 내에서 한 번 조회한 엔티티는 저장해뒀다가 다시 조회할 때 1차 캐시에 저장해둔 엔티티를 반환해 DB에 직접 조회 쿼리가 날아가지 않도록 조회 성능을 향상시킵니다. 즉, 같은 엔티티를 두 번 호출 했을 때, 두 객체의 동일성(identity)을 보장합니다. 이는 패러다임 불일치를 해결하는 것이기도 합니다.</p>
<blockquote>
<p>트랜잭션(Transaction), 또는 데이터베이스 트랜잭션(Database Transaction)은 데이터베이스에서 데이터에 대한 작업의 논리적 실행단계를 의미합니다. <strong>ACID</strong>라는 성질을 가지는데, 이는 원자성(Atomicity), 일관성(Consistency), 독립성(Isolation), 영구성(Durability)의 앞글자를 따서 만든 것입니다. 쉽게 설명해서 데이터베이스의 상태를 변화시키는 여러 SQL을 묶어둔 하나의 작업 단위입니다.</p>
</blockquote>
<p>다음으로 <strong>트랜잭션을 지원하는 쓰기 지연</strong>(transactional write-behind)을 통해 Java 메소드가 실행될 때마다 매번 SQL을 작성하고 DB로 보내는 것이 아니라, 하나의 트랜잭션을 커밋(Commit)하기 전까지 SQL을 모아뒀다가 JDBC의 <strong>BATCH SQL</strong> 기능을 통해 한 번에 DB로 전송합니다.</p>
<p>트랜잭션 지원 쓰기 지연 덕분에 <code>UPDATE</code>나 <code>DELETE</code>처럼 서로 다른 두 사용자가 동시에 진행하면 안되는 작업이 동시에 수행되는 것을 방지하기 위해 걸리는 로우 락(Row Lock) 시간도 최소화됩니다. 수정이나 삭제 메소드가 중간에 작성되어 있어도 여러 비즈니스 로직을 수행하면서 데이터를 가공하다가 트랜잭션의 커밋 순간에만 <code>UPDATE</code>나 <code>DELETE</code> 쿼리가 실행되기 때문에 로우 락 시간이 짧습니다.</p>
<p>마지막으로, <strong>지연 로딩</strong>이라는 기능 덕분에 객체 그래프에서 당장 사용하는 객체만 조회하고, 모든 객체를 한 번에 조회하지 않아도 되기 때문에 객체 조회에 소요되는 시간이 줄어듭니다.</p>
<img width="1310" alt="loading" src="https://github.com/hangillee/coderoad.kr/assets/14046092/5777b92e-0641-43f4-925f-b7f541532ee2">
<div align="center"><I>지연 로딩을 사용하면 실제로 객체가 필요한 순간에 조회한다.</I></div>
<br>
<p>가장 많은 비용이 들어가는 SQL 연산이 조회(SELECT)연산이기 때문에 JPA는 조회 연산을 최대한 적게할 수 있도록 위와 같은 여러 최적화 기능을 제공합니다. 결론적으로 <strong>개발자가 객체에 집중해서 개발할 수 있게</strong> 도와주고, 객체와 관계형 데이터베이스의 <strong>패러다임 불일치를 해결</strong>해주며, <strong>성능 최적화</strong>까지 해주는 JPA를 사용하지 않을 이유가 없는 것 같습니다.</p>
<h2 id="요약" class="heading">요약</h2>
<ul>
<li>객체와 관계형 데이터베이스 사이에는 여러 패러다임의 차이가 있다.</li>
<li>SQL 중심의 개발과 패러다임 차이를 해결하기 위해 ORM 기술이 등장했다.</li>
<li>Java 진영의 ORM 기술 표준은 JPA이며, 구현체로는 Hibernate가 있다.</li>
<li>JPA는 어플리케이션과 JDBC API 사이에서 동작한다.</li>
<li>JPA는 객체 중심 개발, 패러다임 불일치 해결, 성능 최적화를 위해 꼭 사용해야 한다.</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[객체지향의 사실과 오해]]></title>
    <link>https://blog.hangilog.kr/essence-oop</link>
    <pubDate>2023-06-30</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/essence-oop</guid>
    <description>
    <![CDATA[역할, 책임, 협력 관점에서 본 객체지향]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="객체지향의-사실과-오해" class="heading">객체지향의 사실과 오해</h2>
<p>처음 소감을 남길 책은 '<strong>객체지향의 사실과 오해</strong>'입니다. 그렇게 두꺼운 책은 아니지만 꽤 긴 시간을 투자하며 여러번 읽었습니다. 이 책은 Java와 Spring 프레임워크를 공부하는 제게 너무나 중요한 개념인 '객체지향'이란 무엇인가를 쉽고 명확하게 설명합니다. 특히, 저를 포함한 많은 초보 개발자들이 가지고 있을 '객체지향은 <code>class</code>가 중심이다'라는 큰 오해를 완전히 뒤바꿔주는 강력한 책입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[GDSC SKHU 해커톤 in F-Lab]]></title>
    <link>https://blog.hangilog.kr/hackathon</link>
    <pubDate>2023-02-01</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/hackathon</guid>
    <description>
    <![CDATA[약 12시간의 개발 마라톤 후기]]>
    </description>
    <content:encoded>
      <![CDATA[<h2 id="주최는-해봤지만-참가는-처음이라" class="heading">주최는 해봤지만, 참가는 처음이라!</h2>
<p>특성화 고등학교를 졸업한 저에게 해커톤은 익숙한 대회입니다. 밤을 새워가며 마라톤처럼 쉬지 않고 프로그래밍 하는 해커톤은 특성화고 학생에게는 꽤 가까이, 그리고 많이 있었습니다. 제 친구들은 고등학생 시절부터 해커톤, 앱잼, 게임잼 가리지 않고 참여했습니다.</p>
<p>당연히 저에게도 여러 해커톤 대회에 참여할 기회는 있었습니다. 그러나 저는 '내가 팀의 짐덩어리가 되면 어떡하지'와 같은 생각으로 지레 겁 먹고 참여하지 않았습니다. 물론 고등학생 때는 지금보다 실력적으로도 떨어졌었고, 어떤 분야를 중점적으로 공부할지도 정하지 못해 다소 방황했었습니다. 지금 생각해보면 오히려 이런 태도가 제 실력 성장을 더디게한 것 같아 아쉽습니다. 누구보다 앞서 나갈 수 있었던 시간을 허투루 보내버린 셈입니다.</p>
<p>그래서 고등학교 3년 동안 하지 못한 것, 대학에서는 꼭 해보자는 마음을 가지고 고민할 것도 없이 개발 동아리에 가입했습니다. 저는 동기나 선배들보다 앞서 고등학교에서 경험한 것들을 공유하며 열심히 활동했고, 결국엔 회장직도 맡았습니다. 제가 회장이 된 해 겨울, 드디어 저는 인생 첫 해커톤에 참여했습니다.</p>
<p>그러나 저는 이번에도 '주최자'이자 '운영진'이라는 핑계로 개발은 커녕 팀에 소속되지도 않았습니다. 제가 그토록 아쉬워했던 경험의 기회를 제가 만들고 제가 걷어차버린 격입니다. 지금 생각해보면 '내 실력이 동아리원들의 기대에 못 미치는 실력이면 어쩌지'라는 두려움에 그런 선택을 했던 것 같습니다. 저는 또 다시 후회할 행동을 한 것입니다. 의외로 동아리원들은 제 실력에 별 생각이 없었고, 저 혼자 남 눈치를 보며 소중한 기회를 잃어버렸습니다.</p>
<p>그래서 저는 이번 GDSC 겨울 해커톤이 처음 "제대로" 참가하는 해커톤이었습니다. 저보다 뛰어나거나 저와 비슷한 수준의 개발 실력을 갖춘 사람들과 밤새 협업하면서 고민하고 토론하는 첫 기회였기에 기대도 됐고 긴장도 됐습니다. 이번엔 직접 팀에 참가했고, 팀의 리더를 맡아 주도적으로 프로젝트를 이끌었습니다. 팀원 모두 의욕이 가득했고, 해커톤은 활기찬 분위기 속에 시작됐습니다.</p>
<h2 id="코딩-올-나잇" class="heading">코딩 올 나잇</h2>
<p>이번 해커톤은 개발자 멘토링 서비스 기업 <a href="https://f-lab.kr/?utm_source=gdn&#x26;utm_medium=sa&#x26;utm_campaign=mentee&#x26;utm_content=mentoring&#x26;utm_term=&#x26;gad=1&#x26;gclid=CjwKCAjwjMiiBhA4EiwAZe6jQzLzQwsWxl_JmBl6eD_elDyRf7yHzubwZqbkEw3C8ioFkobBFwHXsBoCIEsQAvD_BwE" target="_blank" rel="noopener noreferer">F-Lab</a>에서 해커톤 장소와 맛있는 야식을 후원해주셨습니다. 23년 1월 27일, 추운 겨울 바람을 뚫고 F-Lab 사무실에서 모인 GDSC 멤버들은 후원사 연설과 간단한 브리핑을 들은 후, 팀 빌딩 과정을 거쳐 본격적인 해커톤을 시작했습니다.</p>
<p>백엔드 파트 코어 멤버였던 저는 이번 해커톤에 백엔드 개발자로 참여했습니다. 팀장이었던 저는, 프론트엔드 담당 2명과 백엔드 담당 1명과 팀을 이루었습니다. 개발을 시작하기에 앞서, 다른 백엔드 멤버와 각자 책임지고 개발할 영역을 나누고 시간 계획을 세웠습니다. 개발에 주어진 시간이 그리 넉넉하지 않아 시간이 낭비되지 않게 해야 했습니다.</p>
<p>또한, 틈틈히 페어 프로그래밍하며 코드 컨벤션을 통일하고 서로의 코드를 바로 이해해가며 최대한 시간을 효율적으로 사용하며 협업했습니다. 다행히 GDSC 백엔드 파트에선 멤버 모두 Spring 프레임워크를 함께 스터디했기 때문에 이번 프로젝트에서 사용할 기술 스택은 큰 어려움 없이 빠르게 결정할 수 있었습니다.</p>
<p><img src="https://github.com/hangillee/kotlin-practice/assets/14046092/72afd62f-6e3b-4b25-b82a-ad5c67771c78" alt="hackathon01"></p>
<div align="center"><I>서비스 개발 계획에 대해 발표하는 나</I></div>
<p>개발 준비를 모두 마치고 약 12시간 동안 Spring Boot 뿐만 아니라 Spring Data JPA, Spring Security 등, 다양한 Spring 프레임워크 생태계의 프로젝트들을 통해 열심히 웹 어플리케이션 서버(WAS)를 구축해나갔습니다. 이번에 저와 제 팀원들이 기획한 서비스는 소비 기록을 통해 소비 습관 조언 서비스, "달빗"이었습니다. 사용자가 한 달, 혹은 하루에 쓸 수 있는 금액의 한도를 정해두고 매일 가계부를 작성하면 예산 초과 여부에 따라 다양한 소비 습관 개선 방법을 제안하는 서비스입니다. 이 서비스를 구현하면서 가장 어려웠던 점은 "날마다 작성할 가계부를 어떻게 데이터베이스에 저장할 것인가?"였습니다. Spring을 공부하면서 예제로 다뤘던 상품 주문 서비스나 게시판 서비스와는 다르게 년, 월, 일, 예산 등, 다양한 기준으로 조회가 가능해야했고, 프론트엔드 페이지가 달력으로 구성되어 있기 때문에 한 번에 여러 데이터를 조회해야 했습니다. 덕분에 엔티티 클래스에 작성한 필드가 상당히 많아져 제대로 하고 있는게 맞는지 헷갈리기도 했습니다. 그래도 프론트엔드 팀원들과 소비 내역을 어떻게 화면에 그릴 것인지 충분히 상의하고, 프론트엔드 팀원들의 기술 수준과 요구 사항에 맞춰 데이터베이스를 구축한 후, API를 구현하는데 성공했고, 야식을 먹기 전까지는 순조롭게 완성될 것이라 생각했습니다.</p>
<p><img src="https://github.com/hangillee/kotlin-practice/assets/14046092/5f95bb29-3d0a-46eb-a9ba-b651aecb3af0" alt="hackathon02"></p>
<div align="center"><I>이 사진이 찍힐 때까지는 여유로웠지만...</I></div>
<p>그러나 프론트엔드와 백엔드 간의 통신에서 예상치 못한 오류가 발생했고, 마감 기한 1시간 전까지도 제대로 통신하지 못해 힘들었습니다. 이 문제를 해결하는 과정에서 CORS의 개념에 대해 알게됐고, API 문서화의 필요성을 느끼게 됐습니다. 그동안 로컬 환경에서만 개발하고 프론트엔드와 직접 통신해본 적이 없어 마주치지 못했던 여러 문제들을 파악할 수 있었습니다.</p>
<p>해커톤 덕분에 CORS로 인해 발생하는 문제들을 해결하는 여러 방법을 알게 되었고, 이러한 문제 해결 과정에서 Spring Security가 정말 큰 도움이 되었습니다. 또한, API 문서화 도구들도 어렴풋이 알고만 있었고 어떻게 활용해야하는지, 왜 활용해야하는지 잘 알지 못했는데, 프론트엔드 팀원들이 개발 과정 내내 API의 정확한 사용법을 알지 못해 차질이 생겼던 것을 보며 API 문서화 도구는 필수이며, 사용하는 방법을 꼭 익혀야겠다고 생각했습니다.</p>
<p>서로 API에 대해 이해한 내용이 다르니 서비스가 제대로 동작할 수 없는 것은 너무나 당연한 사실이었습니다. 결국, 프론트엔드는 제대로 배포하지 못한 채 마감 기한이 다가왔고, "달빗"은 미완성으로 남게 됐습니다. 백엔드 역시 CI/CD 파이프라인 구축에 실패하면서 반쪽짜리 완성이었던 아쉬움이 큰 12시간이었습니다.</p>
<h2 id="여전히-알아야할-것은-많았다" class="heading">여전히 알아야할 것은 많았다.</h2>
<p>저는 지난 하반기 동안 GDSC의 코어 멤버로 활동하면서 일반 멤버들에게 Java, Spring, DB 관련 지식들을 공유하기 위해 열심히 공부했고, 덕분에 백엔드 개발과 서비스 배포 과정을 간단하게나마 홀로 해낼 수 있었습니다. 해커톤에 앞서 동아리원들끼리 진행한 미니 프로젝트까지 성공적으로 완성해 제 실력에 상당한 자신감을 가지고 있었습니다. 그러나, 넘쳐나던 자신감이 무색하게, 아직도 제가 갈길이 멀었다고 느낀 해커톤이었습니다.</p>
<p>특히, Dokcer와 Github Actions를 통한 CI/CD 파이프라인 구축은 완전 처음 해보는 작업이어서 그런지 많은 시행착오를 겪었습니다. 결국 제대로 알지 못하고 사용한 탓에 프로젝트 제출 제한 시간까지 CI/CD 파이프라인은 원하는 대로 동작하지 않았습니다. 좋은 개발자를 꿈꾼다는 사람이 사실상 표준이 되어가는, 백엔드 개발자라면 잘 다뤄야만 하는 기술을 아직도 어려워한다는게 부끄러웠습니다. 대학생이라, 시간이 모자라서, 아직 그렇게 중요하지 않아서 같은 변명은 이제 전혀 통하지 않는 고학번이 되었고, 정말 변해야겠다는 생각이 강하게 들었습니다.</p>
<p>그동안 저는 주변 사람들보다 조금 앞서 나갔다고 해서 절대 뛰어난 실력을 가진게 아닌데, 스스로 '이 정도 했으면 됐다'며 안주했고, 이번 해커톤에서 제 실력의 민낯을 보고 말았습니다. 구글링을 통해 구현하는 것도 제대로 못하는 제 자신에게 화도 나고 여러모로 실망스러웠습니다. 앞으로는 여러 외부 개발 활동에 참여해 최대한 많은 사람들과 다양한 경험을 해보고 제 실력의 척도를 객관화할 필요성을 느꼈습니다. 우물 안 개구리가 되어서는 절대 저의 목표인 "좋은 개발자"가 될 수 없을 것입니다. 여러모로 아쉬운 점이 많았지만 정말 얻어가는게 많았던 해커톤이었습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[미니 프로젝트를 마치고]]></title>
    <link>https://blog.hangilog.kr/miniproject</link>
    <pubDate>2023-02-01</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/miniproject</guid>
    <description>
    <![CDATA[Spring을 본격적으로 공부하고 처음 진행한 프로젝트]]>
    </description>
    <content:encoded>
      <![CDATA[]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 스코프]]></title>
    <link>https://blog.hangilog.kr/bean-scope</link>
    <pubDate>2023-01-24</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/bean-scope</guid>
    <description>
    <![CDATA[Spring 빈의 스코프]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<p>문서 공사중입니다.</p>
<h2 id="spring-빈-스코프" class="heading">Spring 빈 스코프?</h2>
<p>Spring 빈은 Spring 컨테이너가 시작될 때 함께 생성되고, 컨테이너가 종료될 때 같이 소멸됩니다. 이렇게 <strong>빈이 존재할 수 있는 범위</strong>를 <strong>스코프</strong>라고 합니다. Spring은 다양한 스코프를 지원합니다.</p>
<ul>
<li><strong>싱글톤</strong> : 기본 스코프로 컨테이너의 생성과 소멸까지 유지되는 가장 넓은 스코프</li>
<li><strong>프로토타입</strong> : 컨테이너가 빈의 생성과 의존관계 주입까지만 관여하는 매우 짧은 스코프</li>
<li><strong>웹 관련 스코프</strong>
<ul>
<li><strong>request</strong> : 웹 요청이 들어오고 나갈 때까지 유지되는 스코프</li>
<li><strong>session</strong> : 웹 세션이 생성되고 소멸될 때까지 유지되는 스코프</li>
<li><strong>application</strong> : 웹의 Servlet 컨텍스트와 같은 범위로 유지되는 스코프</li>
</ul>
</li>
</ul>
<p>기본적으로 Spring 빈은 싱글톤 패턴으로 생성됩니다. 프로토타입이나 웹 관련 스코프를 적용하려면 <code>@Scope</code> 어노테이션을 활용해서 적용하면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 빈은 프로토타입 스코프입니다.</span>
</span><span class="code-line"><span class="token comment">//빈 생성과 의존관계 주입 후에는 컨테이너가 관리하지 않습니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token annotation punctuation">@Bean</span>
</span><span class="code-line"><span class="token class-name">PrototypeBean</span> <span class="token class-name">ExampleBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        count<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="프로토타입-스코프" class="heading">프로토타입 스코프</h2>
<p>싱글톤 스코프 빈, 즉, 일반적인 빈은 컨테이너에서 조회하면 항상 같은 인스턴스의 빈을 반환해줍니다. Spring 컨테이너가 생성된 빈을 컨테이너 소멸 시까지 관리하기 때문입니다. 반대로, 프로토타입 스코프 빈은 컨테이너가 항상 새로운 인스턴스를 생성해서 반환해주는데, <strong>컨테이너가 빈을 생성하고 의존관계를 주입해주면 더 이상 관리하지 않아</strong> 반환해줄 빈이 없기 때문입니다. 따라서, <strong>클라이언트가 빈을 요청하면 항상 새로 생성해서 반환</strong>합니다.</p>
<p>프로토타입 빈은 초기화 콜백 메소드인 <code>@PostConstruct</code>는 실행되지만, <code>@PreDestroy</code>와 같은 소멸 콜백 메소드는 실행되지 않습니다. 때문에, 프로토타입 빈은 빈을 조회한 클라이언트가 직접 관리해줘야합니다. 당연히 소멸 콜백 메소드에 대한 호출도 클라이언트가 직접 해야합니다.</p>
<h3 id="프로토타입-스코프의-문제점">프로토타입 스코프의 문제점</h3>
<p>프로토타입 스코프 빈에는 큰 문제가 하나 존재합니다. <strong>싱글톤 빈과 함께 사용할 때</strong>, 프로토타입 스코프 빈이 <strong>의도한대로 동작하지 않을 가능성이 있습니다</strong>. 바로, 프로토타입 스코프 빈을 싱글톤 스코프 객체 안의 필드에 저장하게 되면 프로토타입의 특징을 잃어버리는 문제입니다.</p>
<p>우리가 프로토타입 빈을 사용할 때는 빈을 생성할 때마다 매번 새로운 인스턴스가 들어오는 것을 기대합니다. 그러나 막상 싱글톤 빈의 필드에 프로토타입 빈을 주입 받아 사용해보면 <strong>기존에 저장된 인스턴스가 호출</strong>됩니다. 이렇게 의도치 않게 프로토타입 빈이 싱글톤 빈과 함께 유지되는 이유는 프로토 타입 빈이 엄밀히 말하면 <strong>의존관계가 주입 될 때</strong> 새로 생성되는 것이지 <strong>이미 주입된 빈을 사용할 때는 새로 생성되지 않기 때문</strong> 입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//싱글톤 빈의 필드에 프로토타입 빈을 대입하는 예시입니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PrototypeBean</span> prototypeBean<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">SingletonBean</span><span class="token punctuation">(</span><span class="token class-name">PrototypeBean</span> prototypeBean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//의존관계를 주입할 때만 새로운 PrototypeBean 인스턴스가 생성되고,</span>
</span><span class="code-line">        <span class="token comment">//이 필드를 활용할 때는 새로 생성하는 것이 아니라 저장된 인스턴스가 호출됩니다.</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>prototypeBean <span class="token operator">=</span> prototypeBean<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h3 id="스코프와-provider">스코프와 Provider</h3>
<p>이렇게 싱글톤 빈과 프로토타입 빈을 같이 쓸 때 발생하는 문제를 해결하기 위해선 <strong>싱글톤 빈이 프로토타입 빈을 사용할 때 마다 Spring 컨테이너에 새로운 인스턴스를 요청</strong>해야합니다. 이를 <strong>의존관계 탐색</strong>(Dependency Lookup)이라고 하는데, 의존관계 주입과 다르게 스스로 필요한 의존관계를 위한 인스턴스를 컨테이너에서 찾아 반환받는 것입니다. DL를 활용하는 가장 간단하고 익숙한 방법은 Spring 컨테이너, 즉,<code>AnnotationConfigApplicationContext</code>의 <code>getBean()</code> 메소드를 통해 항상 새로운 프로토타입 빈을 생성해 반환받는 방법입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> ac<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//로직을 실행할 때마다 컨테이너로부터 항상 새로운 프로토타입 빈을 반환받습니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>우리가 지금까지 자주 다뤘던 메소드를 통해 해결하는 방법이지만 이 방법에도 문제가 있습니다. 바로 TDD(테스트 주도 개발)을 위한 단위 테스트 작성이 어렵다는 점입니다. 이 방법은 <code>ApplicationContext</code> 객체가 없이는 사용할 수 없기 때문에 테스트를 작성할 때마다 <code>ApplicationContext</code>를 주입받아야 합니다. <code>ApplicationContext</code>는 편리하기도 하지만 그만큼 많은 기능을 제공하고 이 말은 <strong>불필요한 기능도 많다</strong>는 것입니다. 또한, <code>ApplicationContext</code>가 꼭 필요하기 때문에 Spring에 종속적인 코드가 됩니다. 우리가 Spring을 공부하면서 계속 피해왔던 것이 특정 기술에 종속적인 코드를 작성하는 것이었던 걸 생각하면 이 방법보다 더 나은 방법을 찾아야 합니다.</p>
<p>다행히도 Spring에는 불필요한 기능들을 제외하고 <strong>DL</strong> 기능만 제공하는 **<code>ObjectProvider</code>**라는 객체가 있습니다. <code>ObjectProvider</code>는 <code>ObjectFactory</code>에 편의 기능을 추가한 객체로 DL 외에도 <code>ObjectFactory</code> 상속, 옵션, 스트림 처리 기능을 제공합니다. 별도의 라이브러리 없이 간단하게 사용할 수 있고 테스트 작성도 수월합니다. 그러나 여전히 Spring에 의존적이라는 문제는 해결하지 못합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">ObjectProvider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">></span></span> prototypeBeanProvider<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//ObjectProvider를 통해 매번 새로운 프로토타입 빈을 반환받습니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> prototypeBeanProvider<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>마지막 문제인 Spring에 의존적인 코드를 벗어나기 위해선 <code>javax.inject.Provider</code>라는 <strong>JSR-330</strong> Java 표준 Provider를 사용하는 방법입니다. 참고로 <strong>Spring Boot 3.0</strong>에서는 <code>jakarta.inject.Provider</code> ㅖ라이브러리를 사용합니다. 사용법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Provider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">PrototypeBean</span><span class="token punctuation">></span></span> provider<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mainLogic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//jakarta.inject.Provider 라이브러리의 Provider를 사용합니다.</span>
</span><span class="code-line">    <span class="token class-name">PrototypeBean</span> prototypeBean <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    prototypeBean<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> count <span class="token operator">=</span> prototypeBean<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>Provider</code>는 <code>get()</code> 메소드로 Spring의 <code>ObjectProvider</code>와 동일하게 DL을 통해 Spring 컨테이너로부터 새로운 인스턴스를 반환받습니다. 이 방법은 Java 표준이고 단순하기 때문에 Spring에 의존적이지 않고 단위 테스트를 작성하기 좋습니다.</p>
<p>지금까지 열심히 프로토타입 빈에 대해 알아봤습니다. 프로토타입 빈은 <strong>'사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요할 때'</strong> 사용하면 됩니다. 사실, 실무에서 웹 애플리케이션을 개발할 때, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접 사용하는 일은 매우 드물다고 합니다.</p>
<h2 id="웹-스코프" class="heading">웹 스코프</h2>
<p>마지막으로 알아볼 스코프는 <strong>웹 스코프</strong>입니다. 싱글톤 스코프는 Spring 컨테이너의 시작과 끝을 함께하고, 프로토타입 스코프는 빈 생성과 의존관계 주입, 초기화까지만 담당하는 특수한 스코프였습니다. 그렇다면 웹 스코프는 어떤 스코프일까요? 굳이 다르게 구분한 이유는 무엇일까요?</p>
<p>웹 스코프의 가장 큰 특징은 <strong>'웹 환경'에서만 동작</strong>한다는 것입니다. 또한 싱글톤 스코프와 마찬가지로 웹 스코프의 종료 시점까지 Spring에서 관리해 소멸 콜백 메소드를 호출할 수 있습니다. 웹 스코프의 종류는 다음과 같습니다.</p>
<ul>
<li><strong>request</strong> : HTTP 요청이 들어오고 나갈 때까지 유지되는 스코프로 각각의 HTTP 요청마다 별도의 인스턴스를 생성 및 관리</li>
<li><strong>session</strong> : HTTP의 Session과 동일한 생명주기를 가지는 스코프</li>
<li><strong>application</strong> : **서블릿 컨텍스트(ServletContext)**와 동일한 생명주기를 가지는 스코프</li>
<li><strong>websocket</strong> : 웹 소켓과 동일한 생명주기를 가지는 스코프</li>
</ul>
<p>웹 스코프도 프로토타입 스코프와 마찬가지로 인스턴스와 관련된 문제가 발생할 수 있습니다. 바로, 실제 사용자의 웹 요청이 있기 전까지는 웹 스코프 빈의 인스턴스가 생성되지 않아 필요한 인스턴스가 제대로 할당되지 않은 채 로직이 실행되는 문제입니다. 이 문제도 앞서 정리해본 <strong>Provider</strong>를 통해 해결할 수 있습니다. <code>ObjectProvider</code>는 <code>getObject()</code>와 같은 DL 메소드를 호출하는 시점까지 <strong>웹 스코프 빈의 생성을 지연할 수 있습니다.</strong></p>
<p>다시 말해서, HTTP 요청이 진행 중인 순간에 <code>getObject()</code>를 호출하면 빈이 정상적으로 생성되고 로직이 문제 없이 작동하는 것을 알 수 있습니다. 그러나 아직도 근본적인 문제가 남아있습니다. 이 코드는 <strong>너무 비효율적이고 복잡합니다.</strong> 이런 일련의 문제 해결 과정을 직접 구현하는 것은 본 문제보다 부가적인 문제에 너무 집중하게 됩니다. 흔히 말하는 배보다 배꼽이 더 큰 상황입니다.</p>
<h2 id="스코프와-프록시" class="heading">스코프와 프록시</h2>
<p>웹 스코프의 인스턴스 문제를 해결해주기 위해 <strong>프록시</strong>라는 기술을 활용하면 좋습니다. Spring 빈의 스코프를 지정해주는 <code>@Scope</code> 어노테이션의 속성인 <code>proxyMode</code>를 활용해 프록시 방식을 활용할 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"request"</span><span class="token punctuation">,</span> proxyMode <span class="token operator">=</span> <span class="token class-name">ScopedProxyMode</span><span class="token punctuation">.</span>TARGET_CLASS<span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebScopeBean</span> <span class="token punctuation">{</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>proxyMode</code>의 속성에는 <code>TARGET_CLASS</code>와 <code>INTERFACES</code> 두 가지가 있습니다. 스코프를 적용하려는 객체가 클래스일 경우 <code>TARGET_CLASS</code>를, 인터페이스일 경우 <code>INTERFACES</code>를 <code>ScopedProxyMode</code>에 붙여주면 됩니다. 이렇게 속성을 부여한 객체는 HTTP 요청 여부에 상관 없이 <strong>가짜 프록시 인스턴스</strong>를 빈에 미리 주입해 둘 수 있습니다. Provider를 사용하기 전에 인스턴스가 없어서 발생했던 문제를 가짜 프록시 인스턴스를 통해 해결한 것입니다. 즉, 복잡하고 거추장스러운 Provider를 사용하지 않고도 문제를 해결할 수 있게 된 것입니다!</p>
<p>이것이 가능한 이유는 바이트코드를 조작하는 <strong>CGLIB 라이브러리를 활용해</strong> 내가 직접 작성한 클래스(예를 들어 예제 코드의 <code>MyWebScopeBean</code>)를 상속 받은 <strong>가짜 프록시 객체</strong>를 만들어서 대신 주입하고, HTTP 요청이 왔을 때 <strong>가짜 프록시 객체</strong>가 내부의 위임 로직을 통해 진짜 객체의 로직을 실행하기 때문입니다. 쉽게 설명하자면, <strong>가짜 프록시 객체는 자리만 지키고 있다</strong>가 실제 사용자 요청이 들어오면 <strong>자신이 상속 받은 진짜 빈을 호출</strong>하고 그때서야 나타난 진짜 빈이 사용자가 요청한 로직을 수행하는 것입니다.</p>
<p>프록시 객체 덕분에 클라이언트는 싱글톤 빈을 사용하는 것처럼 편리하게 웹 스코프를 사용할 수 있습니다. 이는 다형성의 장점이기도 한데, 클라이언트는 내부 코드가 어떻게 동작하는지, 실제로 내가 어떤 객체를 사용하는지는 전혀 알 필요가 없습니다. 다시 말해서, 다형성 덕분에 <strong>클라이언트의 변경 없이 유연하게 객체를 바꿔가며 문제를 해결</strong>한 것입니다.</p>
<p>사실, Provider를 통한 해결법이든, 프록시 객체를 통한 해결법이든, 중요한 것은 진짜 객체, 진짜 빈을 컨테이너에서 조회하는 시점을 꼭 필요할 때까지(실제 요청이 들어오거나, 사용할 때 마다) 지연 처리 한다는 점입니다. 추가로, 꼭 웹 스코프가 아니더라도 프록시 기능을 사용할 수 있습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[빈 생명주기와 콜백]]></title>
    <link>https://blog.hangilog.kr/lifecycle-callback</link>
    <pubDate>2023-01-23</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/lifecycle-callback</guid>
    <description>
    <![CDATA[Spring 빈의 생명주기, 콜백이란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-빈의-생명주기와-콜백" class="heading">Spring 빈의 생명주기와 콜백</h2>
<p>우리가 웹 애플리케이션을 작성하다보면 다른 객체들과의 연결이 필요하다는 것을 알 수 있습니다. 특히, 데이터베이스와의 연결이나 네트워크 소켓 연결 같은 작업은 웹 애플리케이션 개발 시 필수에 가까운 작업입니다. 그러나, 이렇게 <strong>외부와 연결하는 작업들은 상당히 긴 시간이 소요</strong>됩니다. 개발자는 사용자의 요청이 들어왔을 경우 바로 응답할 수 있도록 <strong>미리 연결</strong>(DB 커넥션 풀 등)된 인스턴스들을 사용해야하며, 예기치 못한 오류를 피하기 위해 외부 연결들을 애플리케이션 종료 시점보다 먼저 연결 종료하는 안전한 프로그램을 작성해야합니다. 따라서, 개발자는 객체의 초기화와 종료 과정(생명주기)을 <strong>직접 제어</strong>해야합니다.</p>
<p>Spring 빈은 <strong>객체가 생성되고 의존관계가 주입된 후에 사용할 준비가 완료</strong>됩니다. 즉, 초기화 작업(구현 객체 주입)은 빈이 Spring 컨테이너에 등록되고, 의존관계까지 주입이 모두 끝난 다음 진행해야합니다. 당연한 이야기지만 초기화 작업을 위해선 Spring 빈의 의존관계 주입이 완료되는 시점을 알아야합니다. Spring 빈이 사용될 준비를 다 마치지도 않은 시점에서 사용하려하면 아무런 구현 객체도 가지지 않는 빈을 사용하게 되어 애플리케이션이 의도한대로 작동하지 않을 것입니다.</p>
<p>다행히, Spring은 의존관계 주입을 완료하면 <strong>콜백 메소드를 통해 빈의 초기화가 가능하다는 것을 알려줍니다.</strong> 또한, Spring 컨테이너가 소멸되기 전에도 <strong>소멸 콜백 메소드를 호출</strong>해 애플리케이션이 종료된다는 것을 알려주는데, 개발자는 이 콜백 메소드들 덕분에 초기화와 종료 전 로직들을 정상적으로 수행할 수 있습니다.</p>
<p>지금까지 살펴본 내용을 토대로 Spring 빈의 생명주기를 정리하자면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">컨테이너 생성 <span class="token operator">-></span> 빈 생성 <span class="token operator">-></span> 의존관계 주입 <span class="token operator">-></span> 초기화 콜백 <span class="token operator">-></span> 빈 사용 <span class="token operator">-></span> 소멸 전 콜백 <span class="token operator">-></span> <span class="token class-name">Spring</span> 종료
</span></code></pre>
<p>이 중, 초기화 콜백과 소멸 전 콜백을 <strong>생명주기 콜백</strong>이라고 합니다. Spring은 크게 3가지 방식으로 생명주기 콜백을 지원합니다.</p>
<ul>
<li>인터페이스 (<code>InitializingBean</code>, <code>DisposableBean</code>)</li>
<li>설정 정보에 초기화 메소드, 종료 메소드 직접 작성</li>
<li><code>@PostConstruct</code>, <code>@PreDestroy</code> 어노테이션</li>
</ul>
<h2 id="인터페이스를-통한-생명주기-콜백-다루기" class="heading">인터페이스를 통한 생명주기 콜백 다루기</h2>
<p>첫 번째로 인터페이스를 통해 콜백 메소드를 다루는 방법에 대해 알아보겠습니다. 먼저, 초기화는 <code>InitializingBean</code> 인터페이스의 <code>afterPropertiesSet()</code> 메소드를 활용해서 진행합니다. 이 메소드는 의존관계가 주입이 모두 완료된 후에 호출되기 때문에, 초기화 관련 코드를 넣어두면 초기화가 누락되는 등의 오류 없이 진행할 수 있습니다.</p>
<p>다음으로 빈 소멸은 <code>DisposableBean</code> 인터페이스의 <code>destroy()</code> 메소드를 통해 구현합니다. 이 메소드는 Spring 컨테이너가 종료 로직이 시작될 때, 호출되어 애플리케이션이 완전 종료되기 전에 필요한 로직들을 먼저 수행할 수 있도록 해줍니다.</p>
<p>인터페이스만 구현해주면 되는 이 방식에는 큰 문제가 있는데, <strong>Spring 전용 인터페이스</strong>이기 때문입니다. 다시 말해서 코드가 Spring에 강하게 의존하게 되고, DIP를 위반할 가능성이 높습니다.</p>
<p>요즘은 인터페이스를 활용하는 방식보다 더 좋은 방식들이 나오게 되어 잘 사용하지 않는 방식입니다.</p>
<h2 id="빈-등록-시-초기화와-소멸-메소드-지정" class="heading">빈 등록 시 초기화와 소멸 메소드 지정</h2>
<p>다음은 Java 설정 클래스에서 <code>@Bean</code> 어노테이션을 통해 Spring 빈을 등록할 때 해당 빈의 초기화 메소드와 소멸 메소드를 직접 지정하는 방식입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//객체를 빈으로 등록할 때,</span>
</span><span class="code-line">    <span class="token comment">//해당 객체에 작성한 메소드들을 각각 초기화와 소멸 메소드로 지정할 수 있습니다.</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"init"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"close"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">DatabaseClient</span> <span class="token function">databaseClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">DatabaseClient</span> databaseClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> databaseClient<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>DatabaseClient</code> 객체의 <code>init</code> 메소드와 <code>close</code> 메소드를 각각 초기화와 소멸 메소드로 지정했습니다. 당연히 직접 작성한 메소드를 활용하기 때문에 메소드 이름은 자유롭게 정할 수 있습니다. 또한, Spring 빈이 더 이상 Spring에 의존적이지 않기 때문에 외부 라이브러리에서도 우리가 직접 지정한 생명주기 콜백 메소드들을 활용할 수 있게 됩니다.</p>
<p>이 방식의 정말 특별한 기능이 하나 있는데, 바로 <strong>소멸 메소드 추론</strong>입니다. 소멸 메소드를 지정하는 <code>@Bean</code> 어노테이션의 <code>destroyMethod</code> 속성은 소멸 콜백 메소드의 이름을 말 그대로 '<strong>추론</strong>'합니다. 개발자나 라이브러리는 주로 소멸 메소드의 이름으로 <code>close</code>, <code>shutdown</code> 등의 이름을 사용합니다. <code>destroyMethod</code>는 이러한 이름들이 확인되면 소멸 메소드를 직접 지정해주지 않아도 해당 이름을 가진 메소드를 소멸 메소드로 '추론'하고 <strong>자동으로 호출</strong>합니다.</p>
<h2 id="어노테이션을-통한-콜백-다루기" class="heading">어노테이션을 통한 콜백 다루기</h2>
<p>마지막으로 어노테이션을 통한 초기화와 소멸 콜백 메소드 구현 방식입니다. 초기화 콜백에는 <code>@PostConstruct</code>를, 소멸 콜백에는 <code>@PreDestroy</code> 어노테이션을 사용합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseClient</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@PostConstruct</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Database connection init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@PreDestroy</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Database connection close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>예시 코드를 보면, 초기화 로직을 구현한 메소드에 <code>@PostConstruct</code>를 붙이고 소멸 로직을 구현한 메소드에 <code>@PreDestroy</code>를 붙인 것을 확인할 수 있습니다. 이렇게 어노테이션을 붙이는 것만으로 간단하게 생명주기 콜백을 구현할 수 있습니다. 또한, 이러한 편리함과 <strong>Java 표준</strong>이라는 점 덕분에 <strong>최신 Spring</strong>에서 가장 권장하는 방법이라고 합니다.</p>
<p>거기다 자동 빈 등록 방식인 <a href="https://blog.coderoad.kr/component-scan" target="_blank" rel="noopener noreferer">컴포넌트 스캔</a>과도 가장 잘 맞는 방식입니다. 일단, 인터페이스를 이용한 방식은 Spring에 의존적이기 때문에 피하는 것이 좋습니다. Java 설정 클래스에서 <code>@Bean</code>의 속성을 이용하는 방법은 Spring 빈이 될 클래스를 직접 지정합니다. 이는 곧 자동 빈 등록 기능을 사용하지 않는 것이기 때문에 딱히 효율적인 방식은 아닙니다.</p>
<p>어노테이션을 활용하는 방식의 유일한 단점은 외부 라이브러리에서는 사용하지 못한다는 점입니다. 따라서 상황과 필요에 따라 <code>@Bean</code>의 속성을 활용하거나 <code>@PostConstruct</code>와 <code>@PreDestroy</code> 어노테이션을 통해 콜백을 다루는 것이 좋습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[의존관계 주입]]></title>
    <link>https://blog.hangilog.kr/di-type</link>
    <pubDate>2023-01-22</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/di-type</guid>
    <description>
    <![CDATA[다양한 DI 방식들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="다양한-의존관계-주입-방법" class="heading">다양한 의존관계 주입 방법</h2>
<p>Spring의 의존관계 주입 방법에는 크게 4가지 방법이 있습니다.</p>
<ul>
<li>생성자 주입</li>
<li>수정자 주입</li>
<li>필드 주입</li>
<li>일반 메소드 주입</li>
</ul>
<h3 id="생성자-주입">생성자 주입</h3>
<p>생성자 주입 방식은 말 그대로 클래스의 생성자(Constructor)를 통해 의존관계를 주입 받습니다. 생성자를 매개체로 사용하기 때문에 생성자 호출 시점에 <strong>딱 1번만 호출되는 것이 보장</strong>되며, 변하지 않고 필수적인 의존관계에 사용합니다. 즉, 생성자 주입 방식을 사용하면 의존관계 주입된 인스턴스를 중간에 변경할 수 없습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//한 번 주입된 의존관계는 외부에서 변경할 수 없습니다!</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//Spring 컨테이너가 memberRepository 이름을 가진 빈을 주입해줍니다.</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 생성자가 딱 1개만 존재하면 <code>@Autowired</code>가 없어도 의존관계가 자동 주입됩니다. 당연히 주입하려는 의존관계가 Spring 빈이어야만 가능합니다.</p>
<h3 id="수정자-주입">수정자 주입</h3>
<p>수정자, 흔히 <code>Setter</code>라고 불리는 <strong>필드 값을 변경하는 수정자 메소드를 통해 의존관계를 주입</strong>하는 방법입니다. 생성자 주입 방식과 다르게 외부에서 언제든 접근이 가능하기 때문에 선택적이고 변경 가능성이 있는 의존관계에 사용하는 방식입니다. <code>Setter</code>를 사용하여 필드에 접근하는 방식을 <strong>Java 빈 프로퍼티 규약</strong>이라 하는데, 수정자 주입 방식이 해당 규약을 따른다고 생각하면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//final로 선언되지 않았기 때문에 수정될 수 있습니다.</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//의존관계 자동 주입 기능을 사용했습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemberRepository</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>만약, 빈의 의존관계를 필수가 아닌 선택적으로 주입되도록 하려면, <code>@Autowired</code>를 <code>@Autowired(required = false)</code>와 같이 작성해야합니다.</p>
<h3 id="필드-주입">필드 주입</h3>
<p>필드 주입은 위의 두 방식보다 훨씬 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//이 한 줄이면 자동으로 의존관계가 주입됩니다!</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>너무나도 간단해서 많은 개발자들을 현혹시켰고, 실제로 많은 프로젝트에서 필드 주입 방식을 사용했다고 합니다. 그러나 필드 주입 방식에는 치명적인 단점들이 있어 <strong>사용을 지양해야합니다.</strong></p>
<p>가장 큰 문제는 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>의 SRP를 위반할 가능성이 크다는 것입니다. Spring을 관통하는 <strong>좋은 OOP를 포기하면서</strong>까지 필드 주입 방식을 사용할 이유가 없습니다!</p>
<p>또한, 클래스의 코드만 봐서는 의존관계가 한 눈에 보이지 않는 <strong>숨겨진 의존관계</strong>(Hidden dependency) 문제가 발생합니다. 실제로 어떤 인스턴스(Spring 빈)가 의존관계 주입되어야 하고, 어떤 의존관계가 필수인지, 어떤 의존관계가 변하면 안 되는지 코드를 하나하나 뜯어봐야하는 매우 비효율적인 상황이 생기는 것입니다.</p>
<p>더군다나 필드를 <code>final</code>로 선언할 수 없어 언제든 변경될 수 있습니다. 이 경우에 변경된 의존관계로 인해 예상치 못한 에러가 발생해도 쉽게 알아차릴 수 없습니다. 바로 전에 설명한 문제점에서 알 수 있듯, 필드 주입 방식은 의존관계가 감춰져 있기 때문입니다!</p>
<p>TDD(Test Driven Development, 테스트 주도 개발)에도 악영향을 끼칩니다. 필드 주입 방식은 의존관계를 주입할 때, <code>@Autowired</code> 어노테이션을 보고 Spring 컨테이너가 자동으로 주입 해주는 방식입니다. 이는, 단위 테스트 시 DI 컨테이너, 다시 말해 Spring 컨테이너가 없으면 의존관계를 주입할 방법이 없다는 이야기입니다. <code>@Autowired</code>를 보고 의존관계를 주입해줘야 하는데 순수한 Java 테스트 코드는 Spring 컨테이너가 없으니 제대로 동작할리가 없습니다.</p>
<p>Spring이 등장한 이유가 특정 기술(EJB)에 종속적이었던 Java 개발 생태계를 개선하려던 것이었음을 생각하면, Spring에 종속적인 코드는 매우 모순적인 상황이 아닐 수 없습니다. 그러니 우리는 필드 주입 방식을 멀리해야합니다.</p>
<h3 id="일반-메소드-주입">일반 메소드 주입</h3>
<p>일반적인 Java 메소드를 통해 의존관계를 주입 받을 수도 있습니다. 그러나, 일반적으로 잘 사용하지 않습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line">    <span class="token comment">//사실 수정자 주입 방식과 별반 다를게 없습니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dependencyInject</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="주입-옵션-처리" class="heading">주입 옵션 처리</h2>
<p>앞서 살펴본 여러 의존관계 주입 방식 중, 선택적으로 의존관계를 주입할 때 수정자 주입 방식을 사용해야 한다는 것을 알았습니다. 다시 말하자면, 주입할 Spring 빈이 없어도 애플리케이션이 정상 작동해야할 때가 있습니다. 그런데 자동 주입 방식의 <code>@Autowired</code> 어노테이션은 주입 대상 빈이 없으면 오류가 발생해, <code>@Autowired(required = false)</code>와 같이 옵션 값을 넣어줘야 한다는 것도 잠깐 설명했습니다. 이 방법은 만약 자동 주입 대상이 없다면 수정자 메소드 자체가 실행되지 않습니다.</p>
<p><code>@Autowired</code>에 옵션 값을 지정하는 방법 외에도 주입 옵션을 설정하는 방법은 2가지가 있습니다.</p>
<ul>
<li><code>@Nullable</code> : 자동 주입 대상이 없다면 <code>null</code>을 입력</li>
<li><code>Optional&#x3C;></code> : 자동 주입 대상이 없다면 <code>Optional.empty</code> 입력</li>
</ul>
<p>두 방법의 예시는 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> nullMember<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">Member</span> optionalMember<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanNullable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Member</span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>nullMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanOptional</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Member</span><span class="token punctuation">></span></span> member<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>optionalMember <span class="token operator">=</span> member<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>Member</code>가 Spring 빈이 아니라고 가정했을 때, 두 수정자 메소드에 의해 필드에 입력되는 값은 각각 <code>null</code>과 <code>Optional.empty</code>가 됩니다.</p>
<h2 id="생성자-주입을-선택해야하는-이유" class="heading">생성자 주입을 선택해야하는 이유</h2>
<p>지금까지 크게 3가지 의존관계 주입 방식에 대해 정리해봤습니다. 이 방식들 중, <strong>필드 주입 방식은 지양</strong>하는게 좋다는 것과 그 이유에 대해서도 알아봤습니다. 그럼 도대체 어떤 방식을 주로 사용해야하는 걸까요? 이 질문에 대한 답은 **생성자 주입을 적극 권장하며, 선택적인 의존관계(필수가 아닌 의존관계)를 지정할 때만 제한적으로 수정자 주입 방식을 사용한다.**입니다. 이는 생성자 주입이 가지는 강력한 장점과 수정자 주입 방식의 한계 때문입니다.</p>
<h3 id="불변">불변</h3>
<p>먼저, 생성자 주입 방식을 통해 의존관계를 주입하면, <strong>애플리케이션이 작동 중인 동안에 변경되지 않습니다.</strong> 컴파일 단계에서 주입된 대부분의 의존관계가 애플리케이션 종료 전까지 변할 일이 없어야 한다는 걸 생각하면 이는 훌륭한 장점입니다. 사실, 수정자 주입 방식의 <code>Setter</code> 메소드는 의도치 않은 변경에 매우 취약해 좋은 설계 방법이 아닙니다. 따라서, 객체를 생성할 때 딱 1번만 호출되는 <strong>생성자 주입 방식</strong>을 사용하도록 설계하는 것이 훨씬 좋은 방법입니다.</p>
<h3 id="누락">누락</h3>
<p>수정자 주입 방식의 큰 문제점이 하나 더 있습니다. 만약 연관관계 주입 자체가 누락될 경우, 컴파일 단계에서 오류가 발생하지 않고 실행 도중 <code>NullPointerException</code>를 맞닥뜨리게 됩니다. <code>NPE</code>는 그 원인을 찾아내기 까다로워 Java 프로그래머들을 가장 많이 괴롭히는 악명 높은 예외입니다. 그에 반해 <strong>생성자 주입 방식</strong>은 연관관계 주입이 누락되었을 경우, <strong>컴파일 오류</strong>가 발생합니다. 생성자에 즉, 생성자 주입 방식을 사용하는 것 만으로도 Java 프로그래머의 골칫거리 <code>NPE</code>를 사전에 차단할 수 있는 큰 장점이 있습니다.</p>
<h3 id="final">final</h3>
<p>더 나아가, <code>final</code> 키워드를 사용할 수 있는 것이 생성자 주입을 사용해야하는 이유입니다. <code>final</code> 키워드가 붙은 필드는 선언과 동시에 값을 할당해야하고, 그 값은 변경할 수 없습니다. 이 <code>final</code> 필드에 값을 할당할 수 있는 방법들 중 한가지가 바로 <strong>생성자</strong>를 활용하는 것입니다. 만약 <code>final</code> 필드에 생성자를 통해 아무런 값도 할당하지 않으면, Java는 다음과 같은 컴파일 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line">java<span class="token operator">:</span> variable might not have been initialized
</span></code></pre>
<p>선언과 동시에 값이 할당(초기화)되어야 하는 <code>final</code> 필드에 아무런 값도 할당되지 않았으니, 이대로 실행시켜도 오류가 발생할 수 밖에 없어 Java가 컴파일 단계에서 오류를 발생시켜주는 것입니다. <strong>컴파일 오류는 세상에서 가장 빠르고, 좋은 오류입니다!</strong> 이렇게 <code>final</code> 키워드를 붙이는 것만으로도 연관관계 주입이 빠지지 않고 제대로 될 수 있도록 강제하는 장점도 있으니, <strong>생성자 주입 방식</strong> 대신 다른 방식을 선택할 이유가 없습니다!</p>
<h2 id="lombok과-함께" class="heading">Lombok과 함께</h2>
<p>자, 이제 우리는 좋은 코드를 작성하기 위해선 <strong>생성자 주입 방식</strong>을 사용해야한다는 것도 알게 되었습니다. 그런데, 대부분의 연관관계는 불변입니다. 덕분에 <code>final</code> 키워드를 붙이는 건 이제 습관이 될 정도로 자주 사용하게 되었습니다. 매번 생성자를 작성하는 것도 반복적이고 지루한 작업으로 느껴질 정도가 되어버렸고, 비효율적인 것은 참지 못하는 개발자들은 더 나은 방법을 고안해내기 시작했습니다. 역시 가장 빠르고 효율적인 개발은 불필요한 코드를 지우는 것이었습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//@Autowired 어노테이션은 생성자가 하나일 때 생략되어도 된다!</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>teamRepository <span class="token operator">=</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p><code>@Autowired</code> 어노테이션은 <strong>생성자가 딱 1개 있을 때 생략해도 된다</strong>는 것을 이 포스트의 초반에서 알아봤습니다. <code>@Autowired</code>를 생략하고보니 <strong>생성자</strong>도 굳이 개발자가 직접 타이핑 하지 않는 것이 더 효율적이지 않을까라고 생각하게 되었습니다. 이때 등장하는 것이 바로 <strong><code>Lombok</code> 라이브러리</strong>입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@RequiredArgsConstructor</span> <span class="token comment">//Lombok 라이브러리의 어노테이션</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TeamRepository</span> teamRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//생성자가 사라져도 문제 없습니다!</span>
</span><span class="code-line">    <span class="token comment">//Lombok 라이브러리의 @RequiredArgsConstructor 어노테이션이</span>
</span><span class="code-line">    <span class="token comment">//연관관계 주입이 필요한 필드를 위해 자동으로 생성자를 만들어줍니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>놀랍게도 <code>Lombok</code>이라는 라이브러리를 사용했더니 어노테이션 한 줄 붙여줬을 뿐인데 생성자를 작성할 필요가 없어졌습니다! 이는 <code>Lombok</code> 라이브러리가 Java의 <strong>어노테이션 프로세서</strong>라는 기능을 통해 애플리케이션의 컴파일 시점에 생성자 코드를 자동으로 생성해줬기 때문입니다. 컴파일의 결과물인 <code>.class</code> 파일(Java 바이트 코드 파일)을 열어보면 알맞은 생성자가 작성되어 있는 것을 확인할 수 있습니다.</p>
<p>최근 실무에서는 이렇게 생성자를 1개만 둬 <code>@Autowired</code> 어노테이션을 생략하는 방법을 사용한다고 합니다. 거기에 <code>Lombok</code> 라이브러리까지 활용해 코드를 최대한 깔끔하게 만들되 기능은 모두 제공하는 방식으로 코드를 작성한다고 합니다.</p>
<h2 id="중복-빈이-존재할-때" class="heading">중복 빈이 존재할 때</h2>
<p>중복된 Spring 빈, 다시 말해 같은 타입의 빈이 여러개 존재할 경우, <code>NoUniqueBeanDefinitionException</code> 오류가 발생할 수 있습니다. 자동으로 의존관계를 주입해주는 <code>@Autowired</code> 어노테이션은 타입 기반으로 빈을 조회하는데, <a href="https://blog.coderoad.kr/container-bean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 빈</a> 포스트에서 정리했던 것처럼 동일한 타입의 빈이 존재하면 오류가 발생합니다. 이 오류를 해결하는 방법에는 여러가지가 있지만, <strong>의존관계 자동 주입 방식을 유지하면서 해결</strong>하는 방법들에 대해 알아보겠습니다.</p>
<h3 id="autowired-필드-이름과-빈-이름-매칭">@Autowired 필드 이름과 빈 이름 매칭</h3>
<p>가장 먼저, 간단하면서도 코드 변경도 적은 방법입니다. 예시로 간단한 의존관계 주입 코드를 작성해봤습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 Spring 빈이 하나만 있다면 문제 없지만...</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>만약, <code>DiscountPolicy</code> 타입의 빈이 여러개 있다면, 오류가 발생할 것입니다. <strong><code>@Autowired</code> 필드 이름 매칭 방식</strong>으로 오류를 해결하려면 다음과 같이 빈 이름을 필드 이름으로 작성해주시면 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token comment">//DiscountPolicy 타입의 rateDiscountPolicy Spring 빈을 주입합니다.</span>
</span><span class="code-line"><span class="token keyword">private</span> <span class="token class-name">DiscountPolicy</span> rateDiscountPolicy<span class="token punctuation">;</span>
</span></code></pre>
<p>이렇게 빈 이름을 필드 이름으로 작성하면 <code>DiscountPolicy</code> 타입의 <code>rateDiscountPolicy</code> 빈이 주입됩니다.</p>
<h3 id="qualifier와-primary-활용">@Qualifier와 @Primary 활용</h3>
<p>필드 이름 매칭 방식 외에도 활용할만한 방식이 2가지 더 있습니다. <code>@Qualifier</code>와 <code>@Primary</code> 어노테이션을 활용하는 방법입니다. 먼저 <code>@Qualifier</code> 어노테이션은 빈을 등록할 때, 추가적인 주입 옵션을 부여하는 어노테이션입니다. 사용 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 Spring 빈으로 등록할 클래스에 <code>@Qualifier</code> 어노테이션으로 의존관계 주입 시에 추가적으로 사용할 옵션을 부여할 수 있습니다. <code>@Qualifier</code>를 통해 추가한 옵션은 다음과 같이 의존관계 주입 시 활용할 수 있습니다. 예시로 우리의 주력 의존관계 주입 방식이 되어야 하는 생성자 주입 방식을 사용하겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"mainDiscountPolicy"</span><span class="token punctuation">)</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@Qualifier</code>를 사용하면 <code>@Qualifier</code> 어노테이션을 통해 <code>mainDiscountPolicy</code>라는 이름을 옵션으로 추가한 빈을 먼저 매칭하고, 없다면 변수 이름과 동일한 빈 이름을 가진 빈을 매칭합니다.</p>
<p>마지막으로 <code>@Primary</code>는 여러 동일한 타입의 빈들이 있을 경우, <strong>우선 순위</strong>를 지정해주는 어노테이션입니다. <code>@Autowired</code>를 통해 의존관계를 자동 주입할 때, 같은 타입의 빈들이 여러개 매칭되면, <code>@Primary</code> 어노테이션이 붙은 빈이 우선권을 가지게 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token annotation punctuation">@Primary</span> <span class="token comment">//RateDiscountPolicy 빈이 우선 순위가 높습니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token annotation punctuation">@Component</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FixDiscountPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscountPolicy</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span></code></pre>
<p>위와 같이 코드를 작성하면 <code>RateDiscountPolicy</code> 빈이 같은 타입을 가진 <code>FixDiscountPolicy</code> 빈 보다 더 높은 우선 순위를 갖고 있게 됩니다. 따라서 다음 코드 실행 시, <code>discountPolicy</code> 필드에는 <code>RateDiscountPolicy</code>가 주입됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Autowired</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token class-name">OrderServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">,</span> <span class="token class-name">DiscountPolicy</span> discountPolicy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token keyword">this</span><span class="token punctuation">.</span>discountPolicy <span class="token operator">=</span> discountPolicy<span class="token punctuation">;</span> <span class="token comment">//@Primary가 붙은 RateDiscountPolicy가 주입됩니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>지금까지 살펴본 바로는 <code>@Qualifier</code>와 <code>@Primary</code> 모두 사용하는데 크게 번거로움은 없어보입니다. 둘 중 아무거나 사용해도 꽤 괜찮은 코드가 완성될 것입니다. 그러나 좀 더 세밀하게 두 어노테이션의 용도를 구분하자면 <code>@Primary</code>는 코드에서 자주 사용하는 빈을 주입해야할 때, <code>@Qualifier</code>는 특별히 지정해줘야하는 빈을 주입해야할 때 사용하는 것이 더 깔끔한 코드를 유지할 수 있습니다.</p>
<p>두 어노테이션 간의 우선 순위는 Spring의 기본적인 우선 순위와도 연관이 있습니다. Spring은 <strong>자동 보다 수동</strong>, <strong>넓은 범위 보다 좁은 범위</strong>가 <strong>우선권을 갖습니다.</strong> 따라서, 더 좁은 범위(특정 빈)를 의존관계 주입 대상으로 지정하는 <code>@Qualifier</code>가 우선권을 갖습니다. 이런 정책 덕분에 특별히 원하는 빈을 주입하고 싶은 곳에만 <code>@Qualifier</code>로 지정해주는 방식이 유효한 것입니다.</p>
<h2 id="조회한-빈이-모두-필요할-때" class="heading">조회한 빈이 모두 필요할 때</h2>
<p>만약, <strong>의도적으로 타입이 중복된 빈들이 모두 필요</strong>한 경우가 생길 때는 어떻게 해야할까요? 너무나 간단하게도 <code>List</code>나 <code>Map</code> 같은 자료구조를 활용해 모든 빈을 일단 컨테이너로부터 불러오고, 필요에 따라 의존관계를 주입하는 방식으로 같은 타입의 여러 빈들을 활용할 수도 있습니다.</p>
<p>이를 소위 <strong>전략 패턴</strong>이라고 합니다. 사용자가 건네준 조건에 따라 다르게 작동해야하는 로직이 있을 때, 타입은 같되 로직이 서로 다른 빈들을 미리 <strong>모두</strong> 준비해두고, Spring 빈 주입 시, 조건에 맞춰 필요한 빈을 유연하게 주입합니다.</p>
<p>전략 패턴을 적절하게 활용하면 추가적인 코드 변경 필요 없이 원하는 로직을 적재적소에 구동할 수 있게 할 수 있습니다. 바로, SOLID의 OCP를 잘 지킨 코드가 되는 것입니다.</p>
<h2 id="자동과-수동-빈-등록-올바른-실무-운영법" class="heading">자동과 수동 빈 등록, 올바른 실무 운영법</h2>
<p>지금까지 상당히 긴 호흡으로 Spring의 의존관계 주입에 대해 알아봤습니다. 어노테이션을 통한 수동 빈 등록과 <a href="https://blog.coderoad.kr/component-scan" target="_blank" rel="noopener noreferer">컴포넌트 스캔</a> 빈 등록, 여러 의존관계 주입 방식들의 장단점 등, Spring이 빈과 의존관계를 다루는 정말 다양한 방식들을 알게 되었는데, 도대체 어떤 방식을 기본으로 사용해야하는 것인지 확신이 서진 않습니다.</p>
<p>천천히 생각해보면 개발자들은 비효율적이고 반복적인 과정을 <strong>직접</strong> 겪어야할 필요가 없습니다. 오히려 그런 과정들을 피할 수 있다면 기존의 방식을 과감하게 포기하고 더 간편하고 효율적인 방식으로 코드를 작성해야합니다. 우리가 사용하는 Spring 생태계는 <strong>자동</strong> 방식들을 선호하고, 더 나아가 자동 방식들을 <strong>기본으로 사용</strong>합니다.</p>
<p>물론, 애플리케이션의 설정 정보를 가지는 <strong>구성자</strong>인 <strong>Java 설정 클래스</strong>나 xml 파일을 통해 애플리케이션의 실제 로직과 구성 정보를 분리해주는 것이 이상적인 코드지만, 개발자는 간편한 컴포넌트 스캔 기능을 포기할 이유가 없습니다. <strong>Spring이 자동 빈 등록 기능을 사용해도 OCP와 DIP를 준수할 수 있도록 돕기 때문에</strong>, Java 설정 클래스를 개발자가 직접 관리하는 것은 오히려 부담스러운 작업이 될 가능성이 높습니다.</p>
<p>기본적으로 자동 빈 등록과 자동 의존관계 주입 방식을 사용하다가, 애플리케이션에 광범위하게 영향을 미치는 <strong>기술 지원 객체나 다형성을 적극 활용해야할 때</strong>, 수동 빈 등록과 주입 방식을 사용하는 것을 추천합니다. 데이터베이스 연결과 같은 애플리케이션 전반에서 필요한 기능을 담당하는 <strong>기술 지원 객체</strong>는 그렇게 많은 수가 필요하지도 않고, 오히려 수동 등록을 통해 어떤 빈인지 명확하게 하는 것이 유지보수에 도움이 된다고 합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[컴포넌트 스캔]]></title>
    <link>https://blog.hangilog.kr/component-scan</link>
    <pubDate>2023-01-21</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/component-scan</guid>
    <description>
    <![CDATA[Spring 빈을 더 현명하게 관리하기]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="컴포넌트-스캔" class="heading">컴포넌트 스캔?</h2>
<p>우리는 지금까지 Spring 빈을 Spring 컨테이너에 등록할 때, 구성자(Java 설정 클래스)에서 <code>@Bean</code> 어노테이션이나 XML 파일을 통해 등록했습니다. (자세한 설명은 <a href="https://blog.coderoad.kr/ioc-di" target="_blank" rel="noopener noreferer">IoC와 DI</a>와 <a href="https://blog.coderoad.kr/container-bean" target="_blank" rel="noopener noreferer">Spring 컨테이너와 Bean</a> 문서 참고!) 아주 간단한 Spring 애플리케이션이라면 이 방식도 괜찮지만, 규모가 큰 서비스에서 하나하나 직접 빈을 등록하는 것은 여러 문제점이 있습니다. 개발자가 직접 설정 정보를 작성해야하기 때문에 설정 클래스의 코드가 지나치게 길어지고, 등록해야할 빈을 실수로 빼먹기도 하는 문제가 발생합니다. 더군다나 이런 단순 반복 작업을 개발자가 하게 되는 것 자체가 너무 비효율적입니다.</p>
<p>다행히 Spring이 개발자가 사소한 일에 너무 많은 시간을 쏟지 않도록 자동으로 Spring 빈을 등록해주는 <strong>컴포넌트 스캔</strong>이라는 기능을 제공합니다. 기존에 <code>@Configuration</code> 어노테이션을 붙여 설정 클래스로 지정한 클래스의 빈 등록 코드를 모두 지우고 <code>@ComponentScan</code>이라는 어노테이션을 붙여주면 빈 생성과 등록을 모두 자동으로 합니다!</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스가 이제 스스로 빈을 생성하고 등록합니다!</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//@ComponentScan이 없던 코드와 다르게 클래스 내부가 비어도 괜찮습니다.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 어노테이션 하나만 추가하고 간단하게 자동 등록 기능이 동작하면 정말 좋겠지만, 그렇지 않습니다. 이 방식을 사용하려면 2가지 선행 조건을 충족해야합니다. <strong>Spring 빈으로 등록하고자 하는 Java 클래스에 <code>@Component</code> 어노테이션</strong>을 붙여줘야 하며, 의존관계를 명시한 코드가 설정 클래스에서 없어졌으니 <strong><code>@Component</code> 어노테이션을 붙인 클래스에서 직접 의존관계 주입</strong>을 해줘야합니다. 그래도 크게 걱정할 필요 없습니다. Spring은 <code>@AutoWired</code> 어노테이션을 통해 의존관계 자동 주입 기능도 제공합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Component</span> <span class="token comment">//이제 이 Java 클래스는 Spring 빈입니다.</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">//Spring이 MemberRepository에 대한 의존관계를 자동으로 주입해줍니다.</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MemberRepository</span> memberRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">this</span><span class="token punctuation">.</span>memberRepository <span class="token operator">=</span> memberRepository<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이 기능들의 원리는 의외로 간단한데, <code>@ComponentScan</code>은 <code>@Component</code> 어노테이션이 붙은 모든 클래스를 Spring 빈으로 등록합니다. 이때 빈 이름은 <code>@Bean</code> 방식과 유사하게 클래스명을 사용하되 맨 앞글자만 소문자로 등록합니다. (<code>@Bean</code> 방식은 메소드 명을 이름으로 사용했습니다.) 또한, <code>@Component("이름")</code>과 같이 빈 이름을 직접 지어줄 수도 있습니다.</p>
<p>이렇게 등록된 빈들은 <code>@Autowired</code> 어노테이션이 붙어 있는 생성자나 필드를 만나면 Spring 컨테이너에 의해 조회되고 주입됩니다. 이때, 컨테이너가 사용하는 기본 조회 방식은 타입으로 찾는 방식입니다. <code>getBean(타입.class)</code>와 동일하다고 보면 됩니다.</p>
<h2 id="컴포넌트-스캔-범위-설정" class="heading">컴포넌트 스캔 범위 설정</h2>
<p><code>@ComponentScan</code>을 사용해 빈을 등록하는 방식은 <code>@ComponentScan</code> 어노테이션이 붙은 클래스가 위치한 패키지와 하위 패키지의 모든 Java 클래스를 하나씩 검사하는 방식입니다. 따라서 명확하게 Spring 빈이 아닌 클래스들은 스캔 범위에서 제외해주면 성능 향상에 도움이 됩니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//컴포넌트 스캔을 시작할 위치를 지정합니다.</span>
</span><span class="code-line">    <span class="token comment">//code.road를 포함해 모든 하위 패키지를 스캔합니다.</span>
</span><span class="code-line">    <span class="token comment">//시작 위치를 여러개 설정할 수도 있습니다.</span>
</span><span class="code-line">    basePackages <span class="token operator">=</span> <span class="token string">"code.road"</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p>물론 이렇게 직접 지정할 수도 있지만, 이 글을 작성하게된 강의의 저자이신 김영한님께서 가장 권장하시는 방법은 <strong>시작 위치를 따로 지정하지 않고 Java 설정 클래스(<code>@ComponentScan</code>이 붙은 클래스)를 프로젝트의 최상단에 두는 방법</strong>이었습니다. Spring Boot도 기본적으로 이 방식을 사용하고, 설정 클래스는 프로젝트를 대표하는 정보이기 때문에 최상단에 두는 것이 좋다라고 하셨기 때문에, 저도 프로젝트를 진행하면서 따로 스캔 시작 위치를 지정하지는 않고 있습니다.</p>
<p>추가로 컴포넌트 스캔 기본 대상은 <code>@Component</code> 어노테이션 뿐만 아니라 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Configuration</code>도 컴포넌트 스캔 기능의 스캔 대상입니다. 우리가 Spring Web MVC를 공부하고 애플리케이션을 만들면서 자주 사용하게 될 어노테이션입니다. 위 어노테이션을 사용하면 우리가 크게 신경쓰지 않아도 Spring 빈으로 자동 등록됩니다.</p>
<h2 id="필터를-사용해보자" class="heading">필터를 사용해보자</h2>
<p>필터를 통해 컴포넌트 스캔 대상에 추가하거나 제외할 수 있습니다. 예시 코드를 통해 간단하게 필터 사용법을 알아보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token comment">//BeanA는 스캔 대상에 추가되고</span>
</span><span class="code-line">    includeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">//BeanB는 스캔 대상에서 제외됩니다.</span>
</span><span class="code-line">    excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">BeanB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">)</span>
</span></code></pre>
<p><code>FilterType</code>에 올 수 있는 옵션에는 5가지가 있습니다.</p>
<ul>
<li>ANNOTATION : 기본값으로 어노테이션을 인식해 필터링합니다.</li>
<li>ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 필터링합니다.</li>
<li>ASPECTJ : AspectJ 패턴을 통해 필터링합니다.</li>
<li>REGEX : 정규 표현식을 통해 필터링합니다.</li>
<li>CUSTOM : <code>TypeFilter</code>라는 인터페이스를 구현해서 필터링합니다.</li>
</ul>
<p>그러나, 스캔 대상에 추가하는 기능은 <code>@Component</code>나 <code>@Service</code> 같은 스캔 대상 어노테이션을 붙여주는 것으로 충분해 거의 사용하지 않습니다. 거기다 스캔 대상에서 제외하는 기능도 사용할 일이 많지 않으며, Spring Boot가 기본적으로 컴포넌트 스캔 기능을 제공하기 때문에, 필터를 사용하지 않는 편이 낫습니다. 그래서 컴포넌트 스캔에 필터라는 기능도 존재한다고 알고 넘어가면 될 것 같습니다.</p>
<h2 id="중복과-충돌" class="heading">중복과 충돌</h2>
<p>컴포넌트 스캔을 이용해 Spring 빈을 <strong>자동</strong> 등록하다보면 빈 이름이 중복되는 문제가 발생할 수 있습니다. 이때, <strong>자동으로 등록된 빈들은</strong> 개발자가 <strong>수동으로 등록한 빈보다 우선 순위가 떨어집니다.</strong> 기존의 Spring 프레임워크는 수동 등록한 빈이 자동으로 등록된 빈을 덮어씌워버리기 때문에 의도하지 않았다면 정말 잡아내기 힘든 버그가 탄생하게 됩니다.</p>
<p>그래서인지 최근 Spring Boot에서는 수동 등록 빈과 자동 등록 빈의 이름 중복으로 등록 과정에서 충돌이 발생하면 덮어씌우지 않고 오류를 발생시킵니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Consider</span> renaming one of the beans or enabling overriding by setting spring<span class="token punctuation">.</span>main<span class="token punctuation">.</span>allow<span class="token operator">-</span>bean<span class="token operator">-</span>definition<span class="token operator">-</span>overriding<span class="token operator">=</span><span class="token boolean">true</span>
</span></code></pre>
<p>물론 자동 등록 빈 사이에서도 빈 이름 중복이 발생하면 오류가 발생합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token class-name">Caused</span> by<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>ConflictingBeanDefinitionException</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span></code></pre>
<p>사실 클래스 이름을 중복해서 작성하지 않는 한, 자주 볼 일 없는 오류지만 주의해야합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[싱글톤]]></title>
    <link>https://blog.hangilog.kr/singleton</link>
    <pubDate>2023-01-20</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/singleton</guid>
    <description>
    <![CDATA[Spring과 싱글톤 패턴]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring과-싱글톤" class="heading">Spring과 싱글톤</h2>
<p>싱글톤 패턴은 클래스의 <strong>인스턴스</strong>가 <strong>딱 1개 생성</strong>되는 것을 <strong>보장</strong>하는 <strong>디자인 패턴</strong>입니다. 따라서 우리가 싱글톤 패턴을 구현할 때, 의도적으로 객체 인스턴스가 2개 이상 생성되지 않게 해야합니다. 제가 갑자기 싱글톤에 대해서 설명하는 이유는, 이 싱글톤 패턴이 Spring과 아주 밀접한 관계가 있기 때문입니다.</p>
<p>웹 애플리케이션은 Spring 애플리케이션의 절대 다수를 차지합니다. Spring 프레임워크가 당시 무겁고 복잡했던 기업용 Java 기술들을 순수하고 편리하게 제공하기 위해 탄생했다는 것을 생각하면 웹 애플리케이션과 Spring은 뗄레야 뗄 수 없는 사이입니다. 그런데 웹 애플리케이션은 다수의 사용자가 동시에 서비스에 접근하게 됩니다. 만약 웹 애플리케이션이 서비스에 접근하는 사용자 모두에게 새로운 서비스 인스턴스를 생성해서 제공한다면, 초당 1천 명만 접속해도 순식간에 1천 개가 넘는 객체가 생성되고 삭제되는 심각한 메모리 낭비가 발생합니다.</p>
<p>이러한 메모리 낭비를 막고자 싱글톤 패턴을 사용해 서비스 객체는 딱 1개만 생성되고 모든 사용자들이 이를 공유하도록 해야합니다. 싱글톤 패턴을 구현하는 방법은 다양합니다. 중요한 것은 애플리케이션이 실행 중인 동안 인스턴스가 1개만 생성되어야 한다는 것입니다. 성공적으로 싱글톤 패턴을 구현했다면, 메모리 낭비가 심해지는 문제를 쉽게 해결할 수 있습니다.</p>
<p>그러나, 이런 싱글톤 패턴에도 문제가 있습니다. 싱글톤 패턴을 직접 구현한다는 것은 결국 핵심 서비스 로직 외에도 추가적인 코드를 작성해야하는 비용이 드는 것이고, 의존 관계상 클라이언트가 구체 클래스(유일한 인스턴스)에 의존하게 됩니다. 이것은 DIP를 위반하게 되는 것으로 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a>를 지키지 못한, 나쁜 객체지향 프로그래밍입니다. 또한 구체 클래스에 의존하게 됐기 때문에, OCP도 위반할 가능성이 높습니다.</p>
<p>메모리 낭비를 줄이겠다고 Spring의 근간부터 흔들리고 코드는 잔뜩 꼬여버리는 배보다 배꼽이 더 커져버린 상황이 발생합니다. Spring은 이런 문제를 해결하기 위해 <a href="https://blog.coderoad.kr/container-bean" target="_blank" rel="noopener noreferer">Spring 컨테이너</a>에게 객체 인스턴스를 싱글톤으로 관리하도록 했습니다.</p>
<h2 id="싱글톤-컨테이너" class="heading">싱글톤 컨테이너</h2>
<p><strong>Spring 컨테이너는 싱글톤 컨테이너</strong>의 역할을 담당합니다. 다시 말해서, Spring 컨테이너가 관리하는 Spring 빈들은 모두 싱글톤 패턴으로 관리되는 인스턴스들입니다. 우리가 Spring 컨테이너에 대해 정리했을때, Spring 빈으로 등록한 객체들은 Spring 컨테이너가 인스턴스화하여 가지고 있다가 요청에 따라 의존관계를 주입해준다는 것을 알았습니다.</p>
<p>이렇게 싱글톤 객체를 생성하고 관리하는 기능을 <strong>싱글톤 레지스트리</strong>(Singleton Registry)라고 합니다. Spring 컨테이너의 이런 기능 덕분에 싱글톤 패턴을 직접 구현하면서 발생한 문제들을 해결하고도 인스턴스를 싱글톤으로 유지할 수 있습니다. 즉, 사용자의 요청이 애플리케이션으로 올 때 마다 인스턴스를 생성하는 것이 아니라 이미 만들어진 인스턴스(빈)을 공유해 효율적으로 재사용할 수 있게 된 것입니다.</p>
<p>물론, Spring의 빈 등록 방식은 다양합니다. 기본 방식이 싱글톤일 뿐, 다른 방식도 지정할 수 있습니다.</p>
<h2 id="싱글톤-방식의-주의점" class="heading">싱글톤 방식의 주의점</h2>
<p>싱글톤 방식을 사용할 때 너무나도 중요하고 명심해야하는 점은 Spring 빈을 설계할 때 <strong>무상태</strong>(Stateless)로 설계해야 한다는 것입니다. 싱글톤으로 관리되는 Spring 빈을 공유하는 사용자들은 인스턴스의 공유 가능한 값(클래스 변수)들도 동시다발적으로 접근 가능합니다. 만약 어떤 값을 유지하고 이를 중요 서비스 로직에 사용하도록 빈을 설계했다면 치명적인 오류가 발생할 수 있습니다.</p>
<p>예를 들어, 클래스 변수에 내가 주문한 금액을 저장해두고(Stateful) 이를 통해 은행 계좌에서 주문 금액만큼 인출되도록 서비스 객체를 설계했다고 가정합시다. 이 서비스 객체가 싱글톤 방식으로 관리되고 인스턴스를 모든 사용자가 공유한다면 클래스 변수도 당연히 모든 사용자가 공유하는 변수입니다. 이 변수에 나의 주문 금액을 저장해두어도 다른 사용자가 몇 초 차이로 나중에 주문 서비스를 이용하면 값이 <strong>덮어씌워질 수 있다</strong>는 것입니다.</p>
<p>만약, 난 10만원만 사용했는데 3초 뒤에 다시 주문 서비스를 이용한 사람이 100만원을 사용했고 내가 5초 뒤에 주문을 확정지었다면 나도 모르는 새에 주문 금액은 100만원으로 늘어나는 대형 사고가 발생하는 것입니다. 때문에, 무슨 일이 있어도 싱글톤 방식을 사용할 때는 무조건 무상태(Stateless), 공유 가능한 필드가 없도록 Spring 빈을 설계해야합니다.</p>
<h2 id="configuration" class="heading">@Configuration</h2>
<p>사실 Spring 컨테이너가 싱글톤 컨테이너의 역할을 할 수 있는 것은 <strong><code>@Configuration</code></strong> 어노테이션이 붙은 <strong>구성자</strong>, Java 설정 클래스 덕분입니다. 우리가 <strong>@Bean</strong> 어노테이션을 통해 Spring 빈으로 등록한 객체들은 <code>@Configuration</code> 어노테이션이 없으면 싱글톤이 보장되지 않습니다. 도대체 <code>@Configuration</code>에 무슨 비밀이 있길래 이 어노테이션만 붙이면 싱글톤이 보장되는 것일까요?</p>
<p>바로, @Configuration 어노테이션이 활용하는 <code>CGLIB</code>라는 기술에 있습니다. <code>@Configuration</code> 어노테이션은 <code>CGLIB</code> 기술을 통해 Java 설정 클래스에서 <strong>같은 객체를 여러번 <code>new</code> 키워드로 생성해도 처음 생성된 인스턴스를 활용</strong>하도록 <strong>바이트코드를 조작</strong>해 싱글톤을 보장합니다. 즉, 아무리 <code>new</code> 키워드를 여러번 사용해도 바이트코드 단계에서 <code>new</code> 키워드가 새로운 인스턴스를 만들지 않고 기존에 생성된 인스턴스를 반환하도록 합니다. 따라서 Spring 컨테이너가 싱글톤 방식을 사용하도록 하려면, Java 설정 클래스(구성자)에 <code>@Configuration</code> 어노테이션을 잊어선 안됩니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring 컨테이너와 빈]]></title>
    <link>https://blog.hangilog.kr/container-bean</link>
    <pubDate>2023-01-19</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/container-bean</guid>
    <description>
    <![CDATA[컨테이너와 빈의 개념 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring-컨테이너" class="heading">Spring 컨테이너</h2>
<p>Spring은 <strong><a href="https://blog.coderoad.kr/ioc-di" target="_blank" rel="noopener noreferer">IoC(제어의 역전)</a></strong> 개념을 통해 탄생한 구성자, <strong>컨테이너</strong>로 프로그램의 흐름을 제어합니다. Spring에서의 컨테이너를 <strong>Spring 컨테이너</strong>라고 부릅니다. Spring 컨테이너는 <code>ApplicationContext</code> 인터페이스를 통해 생성하는데, 이 <code>ApplicationContext</code> 자체를 Spring 컨테이너라고 하기도 합니다. 본격적으로 Spring을 활용하기 위해선 이 Spring 컨테이너를 생성해야합니다. 방법은 매우 간단합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//'AppConfig.class'는 프로그래머가 작성한 구성 정보를 담은 Java 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>위 코드가 바로 Spring 컨테이너를 생성하는 코드입니다. <code>AnnotationConfigApplicationContext</code>는 <code>ApplicationContext</code> 인터페이스의 구현체로, <code>AppConfig</code>와 같이 구성 정보를 담은 <strong>'어노테이션'</strong> 기반의 <strong>'Java 설정 클래스'</strong>(구성자)를 통해 Spring 컨테이너를 생성합니다. Spring 컨테이너를 생성하는 방식은 다양합니다. 그 중, 대표적인 두 가지가 위의 코드와 같이 어노테이션 기반의 Java 설정 클래스를 통한 생성법과 XML을 기반으로한 생성법입니다. 최근에는 주로 Java 설정 클래스를 통해 Spring 컨테이너를 생성합니다.</p>
<p>우리는 Spring 컨테이너를 생성할 때 Java 설정 클래스(이제 설정 클래스라 작성하겠습니다.)를 활용한다는 것을 알았습니다. 그런데 Spring이 프로그램의 수많은 클래스들 중에 설정 클래스가 무엇인지 어떻게 알 수 있을까요? 또, 어노테이션을 기반으로 한다는데, 어노테이션은 무엇일까요? 당연히 모든 클래스가 설정 클래스가 되는 것은 아닙니다. 프로그램의 구성 정보(DI 정보)를 담고 있다고 해서 자동으로 설정 클래스가 되는 것도 아닙니다. 프로그래머가 설정 클래스로 사용하고자 하는 클래스를 <strong>어노테이션</strong>을 통해 직접 명시해줘야 Spring이 이를 확인하고 컨테이너를 생성하는데 설정 클래스로 등록된 클래스를 활용합니다.</p>
<p>어노테이션은 Java의 문법으로 메타데이터의 일종입니다. 쉽게 설명하자면 해당 코드가 무엇인지 설명해주는 역할을 가집니다. Spring은 여러가지 자체적인 어노테이션들을 가지고 있고, 프로그래머가 이를 사용해 Spring의 기술을 활용할 수 있도록 합니다. 그 중 가장 기초가 되는 것이 바로 순수한 클래스를 설정 클래스로 만들어주는 <code>@Configuration</code> 어노테이션입니다. 클래스 선언문 앞에 해당 어노테이션을 붙혀주면 Spring은 해당 클래스를 자동으로 설정 클래스로 인식하고 그에 맞는 동작들을 수행합니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이제 AppConfig 클래스는 Spring에 의해 설정 클래스로 관리됩니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>이렇게 <code>@Configuration</code> 어노테이션을 통해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는 Spring 컨테이너 생성 시 프로그램의 구성 정보로 활용됩니다. Spring은 <code>AppConfig</code>에 적혀진 대로 객체를 생성하고, 관리하며, 의존관계를 주입합니다. 다시 말해, <code>@Configuration</code> 어노테이션에 의해 설정 클래스로 등록된 <code>AppConfig</code> 클래스는, IoC를 통해 프로그램의 제어권을 가지게 된 Spring 컨테이너에게 해당 프로그램의 설명서 역할을 하는 것입니다. <code>AnnotationConfigApplicationContext</code> 클래스를 기반으로 Spring 컨테이너를 생성하기 위해선 <code>AppConfig</code>와 같은 설정 클래스가 필수입니다.</p>
<h2 id="spring-빈" class="heading">Spring 빈</h2>
<p>Spring 컨테이너는 생성될 때, 구성 정보로 등록한 설정 클래스(<code>@Configuration</code>이 붙은 클래스)에 작성되어 있는 객체들을 모두 생성해서 자기 자신에 등록합니다. 이때, 컨테이너에 등록된 객체들을 **빈(Bean)**이라고 합니다.</p>
<blockquote>
<p>@Configuration 어노테이션 뿐만 아니라 @Component, @Controller 같은 어노테이션으로도 컨테이너에 빈 등록이 가능합니다! 각각 어노테이션들은 다른 포스트에서 설명하도록 하겠습니다.</p>
</blockquote>
<p>물론 이 방식을 사용할 때, 설정 클래스에 있는 모든 요소들이 빈으로 등록되는 것은 아닙니다. <code>@Bean</code> 어노테이션을 붙힌 메소드가 반환하는 객체들이 등록되는 것입니다. 빈은 정확히는 컨테이너 내부의 빈 저장소에 등록되는데, 빈을 불러올 수 있는 키(key) 역할을 하는 **'빈 이름'**과 실제 객체인 **'빈 객체'**가 같이 등록됩니다. 빈 이름은 따로 지정해주지 않으면 <code>@Bean</code>을 붙혀 Spring 빈으로 지정한 메소드 이름으로 자동 저장됩니다. Spring 빈으로 등록하는 법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//컨테이너 생성에 활용할 구성 정보를 가진 설정 클래스입니다.</span>
</span><span class="code-line"><span class="token annotation punctuation">@Configuration</span>
</span><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//Spring 빈으로 등록되었습니다.</span>
</span><span class="code-line">    <span class="token comment">//빈 이름 : memberRepository</span>
</span><span class="code-line">    <span class="token comment">//빈 객체 : MemoryMemberRepository 클래스의 인스턴스</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberRepository</span> <span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//IoC에 의해 해당 객체는 이 곳에서만 생성되고 의존관계가 주입됩니다.</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">//빈 이름을 직접 등록할 수도 있습니다.</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"memberServiceBean"</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token class-name">MemberService</span> <span class="token function">memberService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MemberServiceImpl</span><span class="token punctuation">(</span><span class="token function">memberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>빈 이름을 직접 등록할 때 꼭 주의해야할 점은 이름이 중복되면 안된다는 것입니다. 서로 다른 두 빈이 같은 이름을 가지게 될 경우, 컨테이너에서 다른 하나의 빈은 무시되거나 아예 덮어씌워질 수도 있고 설정에 따라 오류가 발생할 수도 있습니다.</p>
<p>컨테이너의 역할인 생성과 관리(빈을 생성하고 컨테이너에 등록)까지 알아봤습니다. 다음은 가장 중요하다고 할 수 있는 컨테이너의 DI, 의존관계 주입 방식에 대해 알아보겠습니다. Spring은 빈을 생성하고 의존관계를 주입하는 단계가 나뉘어져 있습니다. 위의 코드로 설명하면, <code>@Bean</code> 어노테이션을 확인한 Spring은 그 아래에 있는 메소드들의 이름을 빈 이름으로, 그 메소드가 반환하는 객체들을 빈 객체로 Spring 컨테이너에 등록합니다. 이후, 메소드 안에 작성되어 있는 의존관계 정보(MemberServiceImpl 클래스는 memberRepository 빈에 의존합니다.)를 확인하고 그 의존관계를 주입해줍니다. 그런데, 위 코드와 같이 Java 설정 클래스를 통해 빈을 등록하면 생성자를 호출함과 동시에 의존관계도 주입됩니다. 즉, 단계가 나누어지지 않는다는 말입니다. 자세한 내용은 의존관계 자동 주입 파트에서 설명하겠습니다. 지금 가지고 가야할 정보는 설정 클래스를 활용해서 만들어진 Spring 빈은 생성될 때 의존관계가 자동으로 주입된다는 것입니다.</p>
<h2 id="컨테이너의-빈-조회하기" class="heading">컨테이너의 빈 조회하기</h2>
<p>이제 Spring 컨테이너를 생성하고 Spring 빈을 등록하는 방법까지 알아봤습니다. 이제 빈이 잘 등록되어 있는지 확인하는(혹은 빈을 활용하고자 객체를 불러오는) 방법에 대해 알아보겠습니다.</p>
<h2 id="모두-조회하기" class="heading">모두 조회하기</h2>
<p>먼저 Spring에 등록된 모든 빈 정보를 확인할 수 있는 방법입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findAllBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//출력</span>
</span><span class="code-line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>현재 Spring에서 관리하고 있는 모든 Spring 빈을 출력하는 방법입니다. <code>ac.getBeanDefinitionNames()</code>을 통해 Spring에 등록된 모든 빈 이름을 조회하고, <code>ac.getBean()</code>으로 조회한 빈 이름을 가진 빈 객체(인스턴스)를 조회합니다. 여기서 <code>ac</code>는 Spring 컨테이너 인스턴스를 담은 변수입니다. 당연히 이 이름은 바뀔 수 있습니다.</p>
<p>그러나 조금 아쉬운 점이 있습니다. 위의 방식을 사용하면 내가 등록한 Spring 빈 뿐만 아니라 Spring 자체적으로 등록한 Spring 빈들도 모두 조회됩니다. 내가 직접 등록한 빈들만 확인하려면 어떻게 해야할까요? 방법은 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//설정 클래스 AppConfig를 구성 정보로 하는 어노테이션 기반 Spring 컨테이너 생성</span>
</span><span class="code-line"><span class="token class-name">AnnotationConfigApplicationContext</span> ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">void</span> <span class="token function">findApplicationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">//빈 이름들을 모두 받아온 후</span>
</span><span class="code-line">    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">//해당 빈 이름을 가진 빈 객체를 받아와서</span>
</span><span class="code-line">    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">//해당 빈 이름을 가진 빈 객체의 속성을 확인한 후</span>
</span><span class="code-line">        <span class="token comment">//직접 등록한 애플리케이션 빈일 경우</span>
</span><span class="code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">.</span>ROLE_APPLICATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">            <span class="token class-name">Object</span> bean <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">            <span class="token comment">//출력</span>
</span><span class="code-line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> beanDefinitionName <span class="token operator">+</span> <span class="token string">" object = "</span> <span class="token operator">+</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈</span>
</span><span class="code-line">        <span class="token comment">//Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>내가 직접 등록한 빈을 **'애플리케이션 빈'**이라고 합니다. Spring 내부의 빈과 애플리케이션 빈은 <code>getRole()</code> 메소드의 결과값으로 구분할 수 있습니다. <code>beanDefinition.getRole()</code>의 결과값은 <code>beanDefinition</code>에 저장해두었던 빈 이름을 가진 빈의 역할입니다. 만약 프로그래머가 직접 등록한 빈이라면 <code>ROLE_APPLICATION</code>이라는 결과값이 나옵니다. 이를 통해 내가 등록한 빈만 확인할 수 있습니다.</p>
<h3 id="기본-방식">기본 방식</h3>
<p>간단하게 정리하자면 Spring 컨테이너에서 빈을 찾는 가장 기본적인 방법은 <code>ac.getBean(빈 이름, 타입)</code>이나 <code>ac.getBean(타입)</code>입니다. 만약 이 방법으로 조회했는데 찾고자하는 Spring 빈이 존재하지 않는다면 다음과 같은 예외가 발생합니다. <code>NoSuchBeanDefinitionException: No bean named '' available</code></p>
<p>기본 방식을 사용할 때 주의해야할 점은 조회 코드의 <code>타입</code> 인자에 구현체 타입을 대입해서 조회하면 유연성이 떨어진다는 것입니다. 프로그래머는 추상화에 의존해야하지 구현체에 의존해서는 안 된다는 <strong>DIP</strong>를 항상 기억합시다!</p>
<h3 id="동일한-타입-존재-시">동일한 타입 존재 시</h3>
<p>만약 동일한 타입의 빈이 여러개 저장되어 있다면 <code>타입</code> 인자만 넣어서 조회할 시 오류가 발생합니다. 이때는 <code>ac.getBean(빈 이름, 타입)</code> 메소드를 사용해서 찾고자하는 빈의 이름을 정확하게 지정해줘야합니다.</p>
<p>혹은, <code>ac.getBeansOfType(타입)</code>을 사용해 인자로 넘겨준 타입의 모든 빈을 조회할 수도 있습니다. 기본적으로 Spring 빈의 이름은 어노테이션을 통해 직접 지정하거나 메소드의 이름으로 자동 지정되기 때문에 여러 빈을 한 번에 조회해도 내가 찾고자하는 빈을 쉽게 찾을 수 있습니다.</p>
<h3 id="상속-관계">상속 관계</h3>
<p>Spring 빈은 Spring 컨테이너가 관리하는 Java 객체이기 때문에 당연히 <strong>상속 관계도 가지고 있습니다.</strong> 부모 타입으로 빈을 조회하면 자식 타입을 가지는 빈들도 모두 조회됩니다. 이러한 특징을 이용해 <code>Object</code> 타입으로 빈을 조회하면 모든 Spring 빈을 조회할 수 있습니다.</p>
<h2 id="beanfactory와-applicationcontext" class="heading">BeanFactory와 ApplicationContext</h2>
<p>우리는 지금까지 <code>ApplicationContext</code>만으로 Spring 컨테이너를 구현했습니다. 그런데 이 <code>ApplicationContext</code>의 상위 인터페이스가 존재합니다. 바로 <code>BeanFactory</code> 인터페이스입니다. <code>BeanFactory</code>는 Spring 컨테이너의 최상위 인터페이스로 Spring 빈을 관리하고 조회하는 역할을 담당합니다. 바로 이 인터페이스에서 <code>getBean()</code>을 제공합니다. 지금까지 우리가 알아본 대부분의 기능들을 이 <code>BeanFactory</code>가 제공합니다.</p>
<p><code>ApplicationContext</code>은 <code>BeanFactory</code>를 상속받아 모든 기능들을 제공합니다. 그렇다면 <code>ApplicationContext</code>를 사용하는 이유는 무엇일까요? 당연한 말이지만 애플리케이션을 개발할 때는 빈의 관리와 조회 뿐만 아니라 다른 부가 기능들도 필요합니다.</p>
<p><code>ApplicationContext</code>는 <code>BeanFactory</code>를 비롯해 애플리케이션 국제화를 위한 <code>MessageSource</code> 인터페이스, 로컬, 개발, 운영을 구분해서 처리하기 위해 지정하는 환경 변수를 다루는 <code>EnvironmentCapable</code> 인터페이스 등을 추가로 상속받아 더 풍부한 편의 기능들을 제공합니다. 덕분에 우리가 <code>BeanFactory</code>를 직접 사용할 일은 거의 없습니다. 대부분의 경우에 <code>ApplicationContext</code>를 사용합니다.</p>
<p>물론 <code>BeanFactory</code>, <code>ApplicationContext</code> 두 인터페이스 모두 Spring 빈을 관리하고 조회하기 때문에 Spring 컨테이너입니다.</p>
<h2 id="beandefinition" class="heading">BeanDefinition</h2>
<p>우리는 지금까지 Spring 컨테이너가 <strong>어노테이션</strong>과 <strong>Java 설정 클래스</strong>(AppConfig 클래스)를 통해 설정 정보를 읽어와 Spring 빈을 생성하고 DI(의존관계 주입)를 진행한다는 것도 알아봤습니다. 그런데 앞서 Java 설정 클래스 방식뿐만 아니라 XML을 통한 설정법도 있다고 언급했습니다. 물론 지금은 잘 사용하지 않는 오래된 방식이지만 여전히 사용 중인 레거시 프로젝트들이 있기에 정상적으로 지원되고 있습니다. Spring은 어떻게 다양한 설정 방식을 지원하는 것일까요? 그 비밀은 바로 <code>BeanDefinition</code> 인터페이스에 있습니다.</p>
<p><code>BeanDefinition</code>은 XML 방식을 사용하든 Java 설정 클래스를 사용하든 개발자가 작성한 설정 정보를 기반으로 빈 설정 메타데이터를 가지게 됩니다. 그렇기에 Spring 컨테이너는 개발자가 어떤 방식을 사용(구현)했는지 알 필요 없이 <code>BeanDefintion</code>만 알고 있다면 적절하게 빈들을 생성하고, 관리하고 각종 기능들을 제공할 수 있습니다. 즉, 세상을 <strong>역할</strong>과 <strong>구현</strong>으로 나누는 <strong>다형성</strong>을 통해 실제 구현체(Java 설정 클래스나 XML 파일)가 무엇이든 <code>BeanDefinition</code>이라는 역할(추상화)에만 의존하는 것입니다. 덕분에 컨테이너는 유연하게 다양한 설정 지정 방식을 지원할 수 있게 된 것입니다.</p>
<p>사실 실무에서 이 <code>BeanDefinition</code>을 직접 다룰 일은 거의 없다고 합니다. 이 <code>BeanDefinition</code>을 깊이 있게 알기보다 어떤 방식으로 Spring이 다양한 형태의 설정 정보를 다루는지를 알기 위해 공부하는 것이 좋을 것 같습니다. 중요한 점은 Spring이 설정 정보를 다루는 과정에서 <strong>다형성</strong>을 활용한다는 것입니다. 그만큼 OOP에 대해 제대로 공부해야만 Spring을 온전히 내 기술로 다룰 수 있을 것 같습니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[캐시와 조건부 요청 헤더]]></title>
    <link>https://blog.hangilog.kr/cache</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/cache</guid>
    <description>
    <![CDATA[HTTP 캐시와 조건부 요청 헤더란?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="캐시란" class="heading">캐시란?</h2>
<p>캐시가 없다면... 같은 리소스를 매번 다운로드. 인터넷 네트워크는 매우 느리고 비싸다. 브라우저 속도도 당연히 느려지고, 사용자도 느린 속도에 불편함을 경험한다.
"cache-control: max-age=시간(초)" 헤더를 통해 캐시를 적용할 수 있다. 처음 요청을 제외하곤 항상 브라우저 캐시 저장소를 먼저 방문해서 캐시 유무를 확인한다.
그러나 max-age 속성에 정해둔 시간이 지나면 캐시는 자동으로 삭제된다.(캐시 시간 초과) 그러면 서버에서 다시 다운로드 해야한다. 이를 해결하기 위해 검증 헤더와 조건부 요청을 사용한다.</p>
<h2 id="검증-헤더와-조건부-요청" class="heading">검증 헤더와 조건부 요청</h2>
<p>검증 헤더 "Last-Modified: (날짜)"를 추가해 데이터가 마지막으로 수정된 시간을 기준으로 시간 초과된 캐시 데이터와 서버의 데이터가 아직 일치하다면 기존 캐시 데이터 계속 이용 가능. (서버는 304 Not Modified 상태 코드를 보내 캐시를 재사용해도 좋다고 알린다. Not Modified는 HTTP Body가 없다. 데이터를 바꿀 필요도 없고 용량을 절약해야하기 때문.)</p>
<p>검증 헤더
캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
Last-Modified, ETag</p>
<p>조건부 요청 헤더
검증 헤더로 조건에 따른 분기
If-Modified-Since: Last-Modified 사용
If-None-Match: ETag 사용
조건이 만족하면 200 OK
조건이 만족하지 않으면 304 Not Modified</p>
<p>Last-Modified, If-Modified-Since 단점
1초 미만의 캐시 조정 불가. 날짜 기반의 로직 사용해야함. 데이터를 수정해서 날짜는 다른데 정작 데이터 내용은 같으면 캐시 유지 불가. 서버에서 별도의 캐시 로직을 다루지 못함.</p>
<p>ETag(Entitiy Tag)
캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
데이터가 변경되면 이 이름을 바꿈. ETag가 같으면 캐시 유지, 다르면 갱신.
캐시 제어 로직을 서버에서 완전히 관리. (ETag 부여를 서버에서 한다.)</p>
<h2 id="캐시와-조건부-요청-헤더" class="heading">캐시와 조건부 요청 헤더</h2>
<p>캐시 제어 헤더
Cache-Control : 캐시 제어
Pragma : 캐시 제어(하위 호환, HTTP 구 버전을 위함)
Expires : 캐시 유효 기간(하위 호환, HTTP 구 버전을 위함)</p>
<p>Cache-Control: max-age : 유효 시간
Cache-Control: no-cache : 데이터는 캐시 가능. 그러나 항상 원 서버에 검증 요청.
Cache-Control: no-store : 데이터에 민감한 정보 있음. 캐시 불가.</p>
<p>검증 헤더
ETag
Last-Modified</p>
<p>조건부 요청 헤더
If-Match, If-None-Match : ETag 사용
If-Modified-Since, If-Unmodified-Since : Last-Modified 사용</p>
<h2 id="프록시-캐시" class="heading">프록시 캐시</h2>
<p>서버와 서버 사이의 거리는 매우 멀다. 한국의 클라이언트와 미국의 서버(오리진 서버)가 직통으로 통신하면 응답이 느리게 도착한다. 그래서 보통 통신 중간에 캐시 데이터를 저장해두는 프록시 캐시 서버를 두어 응답 속도를 높인다. 이때 클라이언트에 있는 캐시를 private 캐시, 프록시 캐시 서버에 있는 캐시를 public 캐시라고 한다.</p>
<p>Cache-Control: public (프록시 캐시 서버에 저장해도 무방함.)
Cache-Control: private (해당 응답이 사용자만을 위한 것. 프록시 캐시 서버에 저장 불가.)
Cache-Control: s-maxage (프록시 캐시에만 적용되는 max-age)
Age: 60 (오리진 서버의 응답 후 프록시 캐시 내에 머문 시간)</p>
<h2 id="캐시-무효화" class="heading">캐시 무효화</h2>
<p>Cache-Control: no-cache, no-store, must-revalidate (원 서버에 데이터 검증을 항상 받고, 캐시로 저장하지 않으며, 원 서버에 검증받아야 하고 만일 서버 접근 실패 시 504 Gateway Timeout이 발생해야함.)
Pragma: no-cache (HTTP/1.0 하위 호환)</p>
<p>no-cache는 만일 원 서버에 접근이 불가하면 오류대신 기존의 데이터를 사용하는 편이 낫다고 판단하고. 시간이 초과된 캐시 데이터를 계속 사용하게 하지만. must-validate는 504 Gateway Timeout 상태 코드를 반환해 캐시를 삭제시킨다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 헤더]]></title>
    <link>https://blog.hangilog.kr/http-header</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/http-header</guid>
    <description>
    <![CDATA[HTTP의 필수 정보들이 담기는 곳]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-헤더" class="heading">HTTP 헤더</h2>
<p>header-field = field-name":" OWS field-value OWS (OWS : 띄어쓰기 허용)
field-name은 대소문자 구분 없음. (ex. Host: <a href="http://www.google.com" target="_blank" rel="noopener noreferer">www.google.com</a> )
HTTP 전송에 필요한 모든 부가 정보. 표준 헤더가 너무 많다... 필요할 땐 임의 헤더 추가 가능.</p>
<p>HTTP Body
RFC723X 시리즈에 와서 엔티티는 표현(Representation). Representation = representation metadata + representation data. 즉, 표현 = 표현 메타데이터 + 표현 데이터.</p>
<p>메시지 본문을 통해 표현 데이터 전달. 메시지 본문 = 페이로드(payload). 표현은 요청이나 응답에서 전달할 실제 데이터. 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공.</p>
<h2 id="표현" class="heading">표현</h2>
<p>Content-Type : 표현 데이터의 형식
Content-Encoding : 표현 데이터의 압축 방식
Content-Language : 표현 데이터의 자연 언어
Content-Length : 표현 데이터의 길이</p>
<p>표현 헤더는 전송, 응답 둘다 사용</p>
<h2 id="협상콘텐츠-네고시에이션" class="heading">협상(콘텐츠 네고시에이션)</h2>
<p>Accept : 클라이언트가 선호하는 미디어 타입 전달
Accept-Charset : 클라이언트가 선호하는 문자 인코딩
Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
Accept-Language : 클라이언트가 선호하는 자연 언어</p>
<p>협상 헤더는 요청 시에만 사용</p>
<p>협상과 우선순위
0 ~ 1 클수록 높은 우선순위, 생략하면 1, 구체적인 것이 우선한다. 구체적인 것을 기준으로 미디어 타입을 맞춘다.</p>
<h2 id="전송-방식" class="heading">전송 방식</h2>
<p>단순 전송(Content-Length), 압축 전송(Content-Encoding), 분할 전송(Transfer-Encoding), 범위 전송(Range, Content-Range)</p>
<h2 id="일반-정보" class="heading">일반 정보</h2>
<p>From : 유저 에이전트의 이메일 정보
Referer : 이전 웹 페이지 주소
User-Agent : 유저 에이전트 애플리케이션 정보
Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
Date : 메시지가 생성된 날짜</p>
<h2 id="특별한-정보" class="heading">특별한 정보</h2>
<p>Host : 요청한 호스트 정보 (도메인)
Location : 페이지 리다이렉션
Allow : 허용 가능한 HTTP 메소드
Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간</p>
<h2 id="인증" class="heading">인증</h2>
<p>Authorization : 클라이언트 인증 정보를 서버에 전달
WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의</p>
<h2 id="쿠키" class="heading">쿠키</h2>
<p>Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달</p>
<p>생명주기 Expires, max-age
도메인 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함. 생략: 현재 문서 기준 도메인만 적용
경로 : 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
보안 : Secure(https에서만 전송), HttpOnly(자바스크립트의 쿠키 접근 불가.) SameSite(요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송)</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 메소드]]></title>
    <link>https://blog.hangilog.kr/http-method</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/http-method</guid>
    <description>
    <![CDATA[HTTP는 어떻게 동작할까?]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-api-만들기" class="heading">HTTP API 만들기</h2>
<p>URI는 리소스만 고려해야한다. 행동(등록, 조회, 수정, 삭제)는 URI에 포함시키지 않는다.</p>
<h2 id="get" class="heading">GET</h2>
<p>리소스 조회</p>
<h2 id="post" class="heading">POST</h2>
<p>클라이언트에서 서버로 데이터를 전송해 서버가 처리하도록 전달하는 메소드. 메시지 바디를 통해 전달하며 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리 등에 사용한다.</p>
<h2 id="put" class="heading">PUT</h2>
<p>리소스 데이터 등록. 기존 데이터가 있다면 완전히 지우고 요청한 데이터 등록. (덮어쓰기)</p>
<h2 id="patch" class="heading">PATCH</h2>
<p>리소스 데이터 수정. 기존 데이터를 수정한다.</p>
<h2 id="delete" class="heading">DELETE</h2>
<p>리소스 데이터 삭제.</p>
<h2 id="http-메소드의-속성들" class="heading">HTTP 메소드의 속성들</h2>
<p>안전, 멱등, 캐시 가능</p>
<h2 id="클라이언트에서-서버로" class="heading">클라이언트에서 서버로</h2>
<p>크게 두가지 방식. 쿼리 파라미터를 통한 전송 (GET, 주로 정렬 필터(검색어)), 메시지 바디를 통한 데이터 전송 (POST, PUT, PATCH 회원 가입, 상품 주문, 리소스 등록, 리소스 변경). 4가지 상황 (정적 데이터 조회(GET, 리소스 경로), 동적 데이터 조회(GET, 쿼리 파라미터), HTML Form (GET(조회)/POST(저장), multipart/form-data), HTTP API (Server to server, App, Web, POST/PUT/PATCH, GET, Content-Type:application/json))</p>
<h2 id="http-api-설계-예시" class="heading">HTTP API 설계 예시</h2>
<p>HTTP API - 컬렉션 (POST 기반 리소스 등록) : 서버가 리소스의 URI를 관리 POST /members -> 서버가 /members/{id} 생성 후 저장
HTTP API - 스토어 (PUT 기반 리소스 등록) : 클라이언트가 리소스의 URI를 관리 PUT /filse/{filename} -> 서버는 저장
HTML FORM 사용 (GET/POST) : DELETE 같은 HTTP 메소드 사용 불가, 컨트롤러(컨트롤 URI, 동사 형태의 API)를 사용해야함. POST /members/{id}/delete</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP 상태코드]]></title>
    <link>https://blog.hangilog.kr/http-status</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/http-status</guid>
    <description>
    <![CDATA[404? 500? 200? 헷갈리는 HTTP의 상태코드들]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http-상태코드" class="heading">HTTP 상태코드</h2>
<p>클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능. 클라이언트에서는 상위 상태코드로 상태를 해석한다. (2XX이면 성공!)</p>
<h2 id="2xx---successful" class="heading">2XX - Successful</h2>
<ul>
<li>
<p><strong>200 OK</strong>
요청 성공</p>
</li>
<li>
<p><strong>201 Created</strong>
요청 성공으로 새로운 리소스 생성</p>
</li>
<li>
<p><strong>202 Accepted</strong>
요청 접수되었으나 처리 미완 (배치 처리)</p>
</li>
<li>
<p><strong>204 No Content</strong>
요청 성공적으로 수행, 그러나 응답 메시지로 보낼 데이터 없음 (게시글 Save 버튼)</p>
</li>
</ul>
<h2 id="3xx---redirection" class="heading">3XX - Redirection</h2>
<h3 id="영구-리다이렉션">영구 리다이렉션</h3>
<p>리소스의 URI가 영구적으로 변경. 원래의 URL 사용하지 않음. 검색 엔진에서도 변경해야함.</p>
<ul>
<li>
<p><strong>301 Moved Permanently</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문(메시지 바디)이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>308 Permanent Redirect</strong>
리다이렉트 시 요청 메소드와 본문을 유지(첫 요청과 동일하게 유지).</p>
</li>
</ul>
<h3 id="일시적-리다이렉션">일시적 리다이렉션</h3>
<p>리소스의 URI가 일시적으로 변경. 검색 엔진에서 절대 변경되면 안됨.</p>
<ul>
<li>
<p><strong>302 Found</strong>
리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거될 수도 있음.</p>
</li>
<li>
<p><strong>307 Temporary Redirect</strong>
리다이렉트 시 요청 메소드와 본문 유지(절대 요청 메소드를 변경하면 안된다).</p>
</li>
<li>
<p><strong>303 See Other</strong>
리다이렉트 시 요청 메소드가 GET으로 변경</p>
</li>
<li>
<p><strong>304 Not Modified</strong>
캐시를 목적으로 사용. 클라이언트에게 리소스가 수정되지 않았음을 알림(캐시 사용 허가).</p>
</li>
</ul>
<h3 id="prg--postredirectget">PRG : POST/Redirect/GET</h3>
<p>POST로 요청 후에 새로 고침으로 인한 중복 요청 방지. POST 후에 결과 화면(응답)을 GET 메소드로 리다이렉트.</p>
<h2 id="4xx---client-error" class="heading">4XX - Client Error</h2>
<p>오류의 원인이 클라이언트에 있어 서버가 전혀 요청을 수행할 수 없음. 같은 요청을 다시 보내도 서버에선 계속 같은 실패 응답을 보냄.</p>
<ul>
<li>
<p><strong>400 Bad Request</strong>
클라이언트가 잘못된 요청을 보냄. 클라이언트가 요청 내용을 검토해야함. HTTP API 스펙이 맞지 않거나, 요청 파라미터가 잘못됨.</p>
</li>
<li>
<p><strong>401 Unauthorized</strong>
클라이언트가 접근하려는 리소스에 대한 인증 필요. Authentication되지 않음. WWW-Authenticate 헤더와 함께 인증 방법 설명
Authentication (본인 인증), Authorization (권한 확인)</p>
</li>
<li>
<p><strong>403 Forbidden</strong>
서버가 클라이언트의 요청을 이해했지만 승인 거부. 권한 부족. (일반 사용자가 어드민 리소스 접근)</p>
</li>
<li>
<p><strong>404 Not Found</strong>
요청 리소스가 서버에 없음. 또는 클라이언트에게 완전히 리소스의 존재 확인을 막을 때.</p>
</li>
</ul>
<h2 id="5xx---server-error" class="heading">5XX - Server Error</h2>
<p>서버 문제로 오류 발생. 재시도 시 성공 가능성 있음. 서버의 문제일 때만 5XX대 오류 반환해야함.</p>
<ul>
<li>
<p><strong>500 Internal Server Error</strong>
서버 문제로 오류 발생, 애매하면 500.</p>
</li>
<li>
<p><strong>503 Service Unavailable</strong>
서비스 이용 불가. 서버가 일시적인 과부하 또는 예정 작업으로 요청 처리 불가. Retry-After 헤더 필드로 복구 예상 시간 반환 가능.</p>
</li>
</ul>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[HTTP]]></title>
    <link>https://blog.hangilog.kr/http</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/http</guid>
    <description>
    <![CDATA[웹 개발을 한다면 무조건 알아야 할 HTTP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="http의-시대" class="heading">HTTP의 시대</h2>
<p>HTTP 메시지에 모든 것을 전송. HTML, Text, 이미지, 음악, 영상, 파일, JSON, XML, 거의 모든 형태의 데이터 전송 가능. Server to Server 데이터 통신에도 사용</p>
<h2 id="클라이언트-서버-구조" class="heading">클라이언트-서버 구조</h2>
<p>Request - Response 구조
클라이언트는 서버에 요청을 보내고 서버의 응답을 대기
서버가 요청에 대한 결과를 만들어서 응답</p>
<h2 id="stateful과-stateless" class="heading">Stateful과 Stateless</h2>
<p>HTTP는 무상태(Stateless) 프로토콜이다. 서버가 클라이언트의 상태를 보존하지 않는다. 덕분에 서버 확장성(서버 확충)이 높다. 단점은 클라이언트가 매번 추가 데이터를 전송해야한다.
Stateful에서는 이전 요청에 대한 상태를 기억하고 있다. 그런데 한 명의 사용자에게 하나의 서버를 계속 붙여주는 것이 아니기 때문에 중간에 다른 서버에서 응답을 줘야하는 상황에서는 이전 상황에 대해 아는 것이 없어 제대로 된 데이터 통신이 불가능하다. 무상태에서는 현재 상태에 대한 정보를 클라이언트에서 계속 보내주어 이러한 문제가 해결 가능하다.</p>
<p>그러나 모든 상황에서 무상태를 사용할 수 있는 것은 아니다. (로그인 유지는 모든 서버가 알아야 한다.) 그래도 상태 유지는 최소한으로 사용해야한다.</p>
<h2 id="비연결성connectionless" class="heading">비연결성(Connectionless)</h2>
<p>HTTP는 비연결성 프로토콜이다. HTTP는 서버가 클라이언트의 요청에 대한 응답을 완료하면 즉시 연결을 끊는다. 서버 자원의 낭비를 막을 수 있다. 다만 매번 새로 연결을 해야하기 때문에 3 way handshake(SYN, SYN+ACK, ACK)이 매번 발생. 매번 수많은 리소스들이 다시 다운로드됨. 이 문제는 HTTP 지속 연결로 해결. 최신 버전인 HTTP/2, HTTP/3에선 최적화.</p>
<h2 id="http-메시지" class="heading">HTTP 메시지</h2>
<p>start-line -> header -> (공백(CRLF)) -> message body</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[인터넷 네트워크]]></title>
    <link>https://blog.hangilog.kr/internet</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/internet</guid>
    <description>
    <![CDATA[웹 개발을 위한 인터넷 네트워크 기본 지식]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="인터넷" class="heading">인터넷!</h2>
<h2 id="ip" class="heading">IP</h2>
<h2 id="tcp와-udp" class="heading">TCP와 UDP</h2>
<h2 id="port" class="heading">PORT</h2>
<h2 id="dns" class="heading">DNS</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[URI]]></title>
    <link>https://blog.hangilog.kr/uri</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/uri</guid>
    <description>
    <![CDATA[통합 자원 식별자에 대해]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC" target="_blank" rel="noopener noreferer">모든 개발자를 위한 HTTP 웹 기본 지식</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="uri-url-urn" class="heading">URI, URL, URN</h2>
<h2 id="url-살펴보기" class="heading">URL 살펴보기</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[IoC와 DI]]></title>
    <link>https://blog.hangilog.kr/ioc-di</link>
    <pubDate>2023-01-18</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/ioc-di</guid>
    <description>
    <![CDATA[Spring의 시작과 끝, IoC와 DI]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="제어의-역전-ioc" class="heading">제어의 역전 IoC</h2>
<p><strong>제어의 역전</strong>(Inversion of Control)은 말 그대로 제어에 역전이 일어났다는 의미입니다. 제어에 역전이 일어났다니, 도대체 무슨 말일까요? 그동안 우리가 작성해왔던 프로그램들은 크게 신경쓰지 않았다면 자연스럽게 <strong>구현 객체가 프로그램의 흐름을 제어</strong>했습니다. 구현 객체 스스로 로직에 필요한 다른 구현 객체들을 생성하고(new 키워드), 연결하고, 로직에 맞춰 실행했습니다. 그러나 이런 방식은 결국 구현 객체에 의존해야(알아야)한다는 문제가 있습니다.</p>
<p>다시 말해서 <a href="https://blog.coderoad.kr/solid" target="_blank" rel="noopener noreferer">SOLID</a> 중 DIP(의존관계 역전 원칙)를 위반한다는 것입니다. 또한, 기존의 방식은 SRP와 OCP도 함께 위반하게 됩니다. 구현 객체가 객체의 생성, 연결, 실행까지 모두 담당하고 있어 SRP(단일 책임 원칙)에 위배되고, 새로운 구현 객체를 비즈니스에 적용하고자 코드를 수정해야할 때, 기존의 구현 객체에 의존하는 모든 코드들을 수정해야하기 때문에 OCP(개방-폐쇄 원칙)을 위반하게 됩니다.</p>
<p>우린 좋은 객체 지향 프로그래밍을 위해 여러 SOLID 원칙들을 위반하는 문제를 해결해야합니다. 먼저, DIP를 준수하기 위해선 <strong>추상화에만 의존</strong>해야합니다. 구현 객체들은 다른 구현 객체에 전혀 의존하지 않고, 자신들이 맡은 비즈니스 로직만 잘 수행하면 됩니다. 즉, 구현 객체 내부에서 다른 구현 객체들을 알고 있을 필요가 없습니다. 하지만 다른 구현 객체들과 협력하지 못한다면 SOLID를 지키기는 커녕 프로그램이 제대로 돌아갈리가 없습니다. 그렇다면 어떻게 추상화에만 의존하면서 객체들 간의 협력 관계를 부여할 수 있을까요?</p>
<p>방법은 간단합니다. 추상화에만 의존하고 있는 객체들에게 구현 객체를 전달해주는 <strong>구성자</strong>가 존재하면 해결됩니다. 모든 구현 객체들을 생성하고 필요한 곳에 연결해주는 등의 제어 권한을 가진 클래스를 만들어주면 DIP를 준수할 수 있습니다. 이 구성자의 등장으로 SRP와 OCP도 준수할 수 있습니다.</p>
<p>구성자는 앞서 설명했던대로 객체 생성, 연결이라는 책임을 구현 객체들로부터 가져왔기 때문에 구현 객체는 실행이라는 책임만 가지게 됐습니다. 또한, 구현 객체들이 <strong>추상화</strong>에만 의존하게 되었으므로 구현 객체를 교체할 때 수정해야하는 것은 <strong>구성자</strong>이지 구현 객체들이 아니기 때문에 OCP도 준수할 수 있습니다.</p>
<p>이렇게 외부의 <strong>구성자</strong>가 프로그램의 흐름을 관리하는 것을 <strong>제어의 역전</strong>(Inversion of Control)이라고 합니다. 흔히 프레임워크들이 제어의 역전을 통해 우리가 작성한 코드들을 제어하고 대신 실행합니다. 그에 반해 라이브러리는 우리의 코드를 제어하기 보단 라이브러리의 코드를 우리가 직접 활용하기 때문에 제어의 역전을 사용하지 않습니다.</p>
<h2 id="의존관계-주입-di" class="heading">의존관계 주입 DI</h2>
<p><strong>의존관계 주입</strong>(Dependency Injection)은 의존관계를 외부에서 주입해주는 것을 말합니다. 우리는 앞서 SOLID 위반을 피하기 위해 추상화에만 의존하고자 프로그램에 IoC 개념을 적용했습니다. 추상화에만 의존하게 된 구현 객체들은 자신이 의존하고 있는 인터페이스 외에는 알고 있는 것이 전혀 없습니다. 하지만 인터페이스는 역할이고 구현체가 아니기 때문에, 인터페이스만 알고 있어서는 프로그램이 올바르게 동작하지 않습니다. 제대로 프로그램이 동작하도록 프로그램의 제어권을 가져간 <strong>구성자</strong>가 의존관계를 설정해줘야 합니다.</p>
<p>구성자가 관리해야할 의존관계에 대해 자세히 알아보기 전에 의존관계의 두 가지 분류를 살펴보겠습니다. 먼저, <strong>import 구문</strong>을 통해 명시적으로 작성하는 의존관계인 <strong>정적 클래스 의존관계</strong>가 있습니다. 이 의존관계는 import 구문을 읽으면 어떤 객체에 의존하고 있는지 프로그램을 실행하지 않아도 알 수 있습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 MemberRepository 객체에 의존하고 있습니다.</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">hello<span class="token punctuation">.</span>core<span class="token punctuation">.</span>member<span class="token punctuation">.</span></span><span class="token class-name">MemberRepository</span></span><span class="token punctuation">;</span>
</span></code></pre>
<p>그러나, 우리는 프로그램을 오로지 추상화에만 의존하도록 제어의 역전을 일으켜야 SOLID를 준수할 수 있다는 것을 알았습니다. 위의 코드와 같은 정적 클래스 의존관계는 의존하고 있는 추상화가 무엇인지는 알 수 있지만 실제 구현 객체는 전혀 알 수 없습니다.</p>
<p>이때, IoC와 <strong>구성자</strong>의 역할이 중요한 이유가 나타납니다. 프로그램의 제어권을 가져간 구성자는 프로그램의 실행 시점(런타임)에 실제 구현 객체 인스턴스를 직접 생성하고 해당 객체를 필요로하는 코드들에 의존관계를 연결합니다. 이것을 <strong>의존관계 주입</strong>(Dependency Injection)이라고 합니다. DI를 사용하면 클라이언트 코드를 전혀 변경하지 않고, 클라이언트가 호출하는 대상의 인스턴스 타입을 변경할 수 있습니다. 즉, OCP 원칙이 준수된다는 의미입니다.</p>
<h2 id="컨테이너의-등장" class="heading">컨테이너의 등장</h2>
<p>IoC를 통해 프로그램의 제어권을 온전히 가지게 된 <strong>구성자</strong>는 앞서 살펴본대로 객체를 생성하고, 관리하면서, 의존관계를 연결(DI)해주는 역할을 수행하고 있습니다. 이 구성자를 바로 <strong>컨테이너</strong>(Container)라고 합니다. IoC 컨테이너, DI 컨테이너 등, 많은 이름이 있지만 최근에는 DI에 중점을 두고 주로 DI 컨테이너라고 합니다. 물론 Spring에서는 <strong>Spring 컨테이너</strong>라고 합니다. 이름은 차이가 있어도 맡고 있는 역할은 전혀 다를게 없으니 Spring을 공부하는 입장에선 Spring 컨테이너라고 하는 것이 좋을 것 같습니다.</p>
<p>다시 한번 강조하지만, 컨테이너 외부에서는 애플리케이션의 모든 객체는 추상화에만 의존해야합니다. 컨테이너 외부에서 추상화가 아닌 구현체에 의존하게 되면 Spring을 사용하는 의미도 없을 뿐더러 SOLID에 위배되어 좋은 객체 지향 프로그래밍도 아니기 때문입니다. 물론 테스트 코드를 작성할 때는 필요에 따라 <code>new</code> 키워드로 구현 객체를 생성해도 상관 없습니다. 단위 테스트를 위해 간단한 더미 데이터가 필요한데 실제 서비스 코드를 수정하는게 훨씬 비효율적이기 때문입니다.</p>
<p>자, 이제 우리는 IoC를 통해 만들어진 구성자가 컨테이너라는 것도 알았습니다. 좋은 객체 지향 프로그래밍을 위해서 직접 컨테이너를 만들어 구현 객체를 생성하고, 관리하면서, 의존관계도 주입해주면 됩니다! Spring에서는 기본적으로 <strong>ApplicationContext</strong>라는 인터페이스를 통해 컨테이너를 제공하고 있습니다. 즉, 우린 Spring 컨테이너에 대해 공부하면 지금까지 알아봤던 여러 개념들을 간단하게 적용할 수 있는 것입니다! 이제 Spring의 컨테이너에 대해 더 자세하게 공부해, Spring의 장점을 극대화해봅시다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[SOLID]]></title>
    <link>https://blog.hangilog.kr/solid</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/solid</guid>
    <description>
    <![CDATA[Spring과 SOLID]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="solid" class="heading">SOLID?</h2>
<p>SOLID, 단단하다는 뜻을 가진 영단어입니다. Spring과 SOLID는 도대체 무슨 연관이 있을까요? 사실 Spring을 넘어 프로그래밍에서 <strong>SOLID는 객체 지향 프로그래밍 및 설계의 가장 기초적인 원칙 5가지</strong>의 앞 글자를 딴 단어입니다. 2000년대 초반, 미국의 소프트웨어 엔지니어인 로버트 마틴이 "<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener noreferer">The Principles of OOD</a>"라는 제목의 블로그 게시글에서 5개의 원칙을 명명했습니다.</p>
<p>그 원칙들은 다음과 같습니다.</p>
<table style="border: 1px solid gray;">
    <tr>
        <th colspan="2">SOLID</th>
    </tr>
    <tr>
        <th>이름</th>
        <th>설명</th>
    </tr>
    <tr>
        <td>단일 책임 원칙</td>
        <td>SRP (Single Responsibility Principle)<br>한 클래스는 하나의 책임만 가져야 한다.</td>
    </tr>
    <tr>
        <td>개방-폐쇄 원칙</td>
        <td>OCP (Open/Closed Principle)<br>소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.</td>
    </tr>
    <tr>
        <td>리스코프 치환 원칙</td>
        <td>LSP (Liskov Substitution Principle)<br>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</td>
    </tr>
    <tr>
        <td>인터페이스 분리 원칙</td>
        <td>ISP (Interface Segregation Principle)<br>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.</td>
    </tr>
    <tr>
        <td>의존관계 역전 원칙</td>
        <td>DIP (Dependency Inversion Principle)<br>프로그래머는 추상화에 의존해야하지 구체화에 의존하면 안된다. 의존관계 주입은 이 원칙을 따르는 방법 중 하나.</td>
    </tr>
</table>
<h2 id="단일-책임-원칙-srp" class="heading">단일 책임 원칙 (SRP)</h2>
<p><strong>단일 책임 원칙</strong>(Single Responsibility Principle)은 "한 클래스는 하나의 책임만 가져야 한다."라는 원칙입니다. 여기서 '하나의 책임'이라는 말이 모호할 수 있습니다. 책임은 클 수도 있고, 작을 수도 있으며, 문맥과 상황에 따라 다릅니다. 하지만 가장 중요한 것은 <strong>변경</strong>입니다. 즉, 우리는 "변경"을 기준으로 잡아 단일 책임 원칙이 준수되었는지 확인해야합니다.</p>
<p>예를 들어, 웹 애플리케이션에서 특정 기능을 수정하게 된 상황을 가정해보겠습니다. 기능의 수정이 생겼기 때문에 당연히 내부 코드에도 변경이 필요합니다. 이 때, 단 하나의 클래스만 수정되어야 SRP를 잘 준수한 프로그램이 되는 것입니다. 즉, 하나의 클래스가 하나의 기능(책임)을 가지기 때문에 다른 클래스(코드)에 영향을 주지 않고도 변경이 가능합니다.</p>
<h2 id="개방-폐쇄-원칙-ocp" class="heading">개방-폐쇄 원칙 (OCP)</h2>
<p><strong>개방-폐쇄 원칙</strong>(Open/Closed Principle)은 "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."라는 원칙입니다. 그런데 이름부터 모순되는 말입니다. 어떻게 개방과 폐쇄가 동시에 지켜질 수 있다는 말일까요? 애플리케이션을 확장하려면, 즉 기능을 추가하거나 수정하려면 당연히 기존의 코드를 변경해야하는 것 아닐까요? 이 질문의 답은 객체 지향 프로그래밍에서 가장 중요한 <strong>다형성</strong>에 있습니다.</p>
<p>우리가 앞서 살펴봤던 다형성을 활용하려면, <strong>역할</strong>과 <strong>구현</strong>으로 철저하게 구분지어서 설계해야한다고 했습니다. 잘 설계된 역할이 있다면 그 구현체를 새로 만드는 것은 기존 코드에 전혀 영향을 주지 않습니다. 다형성의 목적이 유연하고 변경이 용이하게 하는 것임을 기억한다면, 미리 적어둔 코드의 수정 없이도 완전히 새로운 기능을 추가(확장)하는 것이 가능합니다. 즉, 새로운 클래스를 작성하고 애플리케이션에 적용(확장)할 때 다른 클래스를 수정(변경)한다면 확장에도 열려있고 변경에도 열려있어 OCP를 위반하는 것입니다.</p>
<p>그럼 OCP를 준수하려면 어떻게 해야할까요? 지금까지 우리는 새로 만든 구현체를 적용시키려면 그 구현체를 사용하는 다른 구현체의 코드를 수정해야했습니다. 이제 우리는 새로운 구현체를 외부에서 생성, 조립, 설정까지 모두 해주는 설정자가 필요해졌습니다. 이 설정자를 통해 기존 코드의 수정이 없이 설정자만 변경했을 때 의도한대로 동작한다면 그 프로그램은 OCP를 준수한 것입니다. 이 "설정자"는 나중에 설명하겠지만 "Spring 컨테이너"라는 Spring에서 아주 중요한 역할을 맡게 됩니다.</p>
<h2 id="리스코프-치환-원칙-lsp" class="heading">리스코프 치환 원칙 (LSP)</h2>
<p><strong>리스코프 치환 원칙</strong>(Liskov Substitution Principle)은 "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다."는 원칙입니다. 쉽게 설명해서 자식 클래스는 부모 클래스를 언제든 완전히 대체할 수 있어야 한다는 원칙입니다. 즉, 부모 클래스의 기능이 자식 클래스에서 정반대가 되어버린다면 LSP가 지켜지지 않은 것입니다. 오류는 나지 않겠지만 다형성이 완전히 무너지게 됩니다.</p>
<p>예를 들어, 자동차 인터페이스의 악셀 메소드는 가속을 합니다. 모든 자동차는 악셀은 가속, 브레이크는 감속이라는 기능을 가지는데, 만약 어느 한 구현체(자동차)만 이 인터페이스와는 정반대로 악셀은 감속, 브레이크는 가속이라는 기능을 가지면 대참사가 발생할 가능성이 있습니다. 물론 만들 수는 있고 실제로 운전도 어렵겠지만 가능은 합니다. 그러나 이 예시에선 구현체(자식 클래스)가 인터페이스(부모 클래스)를 완전히 대체하지 못하고 있기 때문에 LSP를 위반하고 있습니다.</p>
<p>가장 지키기 쉬운 원칙 중에 하나입니다. 인터페이스를 설계한 목적 그대로 구현하면 됩니다.</p>
<h2 id="인터페이스-분리-원칙-isp" class="heading">인터페이스 분리 원칙 (ISP)</h2>
<p><strong>인터페이스 분리 원칙</strong>(Interface Segregation Principle)은 "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."는 원칙입니다. 쉽게 설명하면 인터페이스를 더 세세하게 분리하는 것이 좋다는 것입니다. 즉, 하나의 인터페이스가 가지는 책임(기능)이 과다할 때, 분리할 수 있는 책임(기능)이 있다면 따로 분리해두어야 합니다.</p>
<p>예를 들어, 자동차 인터페이스는 "운전"이라는 큰 관점으로 묶이는 기능들과 "정비"라는 큰 관점으로 묶이는 기능들로 분리할 수 있습니다. 또한 사용자 인터페이스도 "운전자"와 "정비사"로 나눌 수 있습니다. 그럼 정비 인터페이스가 변해도 운전자 구현체에는 전혀 영향을 주지 않게 됩니다. 만약 자동차 인터페이스를 ISP 원칙을 지키지 않았다면 정비 부분 기능들을 수정할 때 운전자 구현체에도 영향을 미칠 것입니다. 따라서 ISP를 준수하면 인터페이스가 좀 더 명확해지고 대체 가능성이 높아집니다.</p>
<h2 id="의존관계-역전-원칙-dip" class="heading">의존관계 역전 원칙 (DIP)</h2>
<p><strong>의존관계 역전 원칙</strong>(Dependency Inversion Principle)은 "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다."는 원칙입니다. 의존관계 주입(Dependency Injection)은 이 원칙을 따르는 방법 중 하나입니다. 쉽게 이야기해서 DIP는 구현 클래스에 의존하지 말고, 역할인 인터페이스에 의존하라는 뜻입니다. 여기서 "의존한다."는 "알고 있다."와 같습니다. 즉, 클라이언트가 인터페이스<strong>만</strong> 의존해야(알고 있어야) DIP를 준수하는 것입니다. 만약 인터페이스 뿐만 아니라 구현 객체도 의존한다(알고 있다)면, 구현체를 변경해야할 때 해당 구현체를 의존하는(알고 있는) 코드를 모두 변경해야합니다.</p>
<p>DIP에 대해 더 자세히 알아보기 위해 다형성을 설명하면서 작성했던 코드를 다시 살펴보겠습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//이 코드는 DIP를 위반합니다!</span>
</span><span class="code-line"><span class="token comment">//Car라는 인터페이스를 의존합니다. 그러나 NormalCar라는 구현체도 알고 있습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>한 눈에봐도 추상화(인터페이스)와 구체화(구현 클래스)를 동시에 의존하고(알고) 있어 DIP를 위반했다는 것을 알 수 있습니다. DIP를 준수하려면 추상화에만 의존해야합니다. 그런데 만약 추상화만 의존하기 위해 위의 코드를 아래와 같이 고치면 예외가 발생할 것입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//추상화만 의존하긴 하지만...</span>
</span><span class="code-line"><span class="token comment">//myCar에는 아무것도 들어가지 않았습니다.</span>
</span><span class="code-line"><span class="token class-name">Car</span> myCar<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre>
<p>DIP를 지키려고 했더니 동작조차 하지 않는 망가진 코드가 완성되어버렸습니다. 분명 유연하게 변경할 수는 있지만 SOLID를 준수하자니 무언가 부족합니다. 객체 지향의 핵심이라는 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다는 것을 깨달았습니다. 또한 구현 객체를 변경할 때 클라이언트의 코드도 변경되어버린다는 것도 알았습니다. 즉, 다형성만으로는 DIP와 OCP를 완벽하게 지킬 수 없다는 것을 알아버렸습니다! 그럼 어떻게 해야 SOLID를 준수하면서 객체 지향 프로그래밍을 할 수 있을까요? 정답은 바로 <strong>Spring</strong>에 있습니다.</p>
<h2 id="갑자기-spring" class="heading">갑자기 Spring?</h2>
<p>Spring이 제공하는 <strong>의존관계 주입(Dependency Injection, DI) 기술</strong>과 <strong>DI 컨테이너</strong>를 통해 다형성과 OCP, DIP를 지킬 수 있게 도와줍니다. 이러한 Spring의 기술들 덕분에 클라이언트의 코드의 변경 없이도 기능 확장이 가능해졌습니다. 그렇다고 Spring이 없던 시절에는 OCP, DIP를 준수하는게 불가능하진 않았습니다. 순수한 Java로 OCP, DIP를 준수하기 위해 작성한 코드들이 너무 많아지다보니 한 곳에 모아 프레임워크로 만든 것이 바로 <strong>Spring</strong>입니다. 우리가 OCP와 DIP를 준수하면서 개발을 해보면 결국엔 Spring의 핵심인 DI 컨테이너를 만들게 됩니다.</p>
<p><a href="https://blog.coderoad.kr/spring" target="_blank" rel="noopener noreferer">Spring</a> 포스트에서 Spring의 역사에 대해 알아보면서 Spring은 "좋은 객체 지향"을 위해 탄생한 프레임워크라고 설명했습니다. 좋은 객체 지향 프로그래밍을 위해서는 기초 중의 기초인 SOLID를 준수해야하고 Spring은 이를 쉽게 준수할 수 있도록 돕습니다. 따라서 Spring을 100% 활용하기 위해선 객체 지향 5원칙, SOLID를 반드시 공부해야합니다. 그렇지 않으면 Spring의 동작 원리부터 이해할 수 없기 때문입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Java 웹 기술의 역사]]></title>
    <link>https://blog.hangilog.kr/java-web-history</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/java-web-history</guid>
    <description>
    <![CDATA[Servlet의 등장부터 Spring Boot까지]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="과거의-기술들" class="heading">과거의 기술들</h2>
<h3 id="서블릿-servlet">서블릿 (Servlet)</h3>
<p>Spring, 그리고 Spring의 수많은 프로젝트들이 탄생하기도 전인 1997년, <strong>서블릿</strong>(Servlet)이라는 기술이 Java EE(Java Enterprise Edition)에 정식 제품으로 포함되며 세상에 나왔습니다. 서블릿은 동적으로 웹 페이지를 생성하기 위한 기술로, Java 소스 코드 내부에 HTML을 포함한다는 특징을 가지고 있습니다. 서블릿에 대한 자세한 내용은 <a href="https://blog.coderoad.kr/servlet" target="_blank" rel="noopener noreferer">Servlet이란?</a>에 정리했습니다.</p>
<h3 id="jsp">JSP</h3>
<p>서블릿의 탄생으로 이전에 서버 개발자가 직접 해야했던 여러 복잡한 작업들(TCP/IP 소켓 통신, HTTP 메시지 파싱 등)을 모두 서블릿이 대신 해주면서 웹 애플리케이션 서버를 구축할 때 들어가는 비용이 크게 줄어 들었지만, 여전히 큰 문제가 하나 남아 있었습니다. 서블릿을 이용해 개발자라면 무조건 피해야하는 '유지보수하기 힘든 코드'가 만들어지곤 했습니다.</p>
<p>아래 코드는 순수하게 서블릿만 사용해서 간단한 회원 정보 입력 폼과 폼을 통해 입력된 데이터를 저장하는 로직을 작성한 코드입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 회원의 이름과 나이를 입력하는 폼 서블릿</span>
</span><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token class-name">PrintWriter</span> w <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    w<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&#x3C;!DOCTYPE html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;meta charset=\"UTF-8\">\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;title>Title&#x3C;/title>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;form action=\"/servlet/members/save\" method=\"post\">\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    username: &#x3C;input type=\"text\" name=\"username\" />\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    age:      &#x3C;input type=\"text\" name=\"age\" />\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;button type=\"submit\">전송&#x3C;/button>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/form>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/html>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">// 폼을 통해 입력 받은 데이터를 저장하는 서블릿</span>
</span><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 요청 데이터 받아옴</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MemberSaveServlet.service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">String</span> username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 서비스 로직</span>
</span><span class="code-line">    <span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    memberRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 결과 출력</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">PrintWriter</span> w <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    w<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&#x3C;html>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;meta charset=\"UTF-8\">\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/head>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"성공\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;ul>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;li>id="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"    &#x3C;li>username="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">" &#x3C;li>age="</span><span class="token operator">+</span>member<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&#x3C;/li>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/ul>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;a href=\"/index.html\">메인&#x3C;/a>\n"</span> <span class="token operator">+</span> <span class="token string">"&#x3C;/body>\n"</span> <span class="token operator">+</span>
</span><span class="code-line">            <span class="token string">"&#x3C;/html>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>솔직히 저라면 절대 다시 읽기 싫은 코드인 것 같습니다. Java 코드와 HTML의 스타일이 매우 달라 읽는 것만으로도 스트레스 받을 것 같고, 만약 이 코드가 수천, 수만 줄이 넘어간다면 유지보수는 고행이 될 가능성이 높아 보입니다. 더군다나, Java 코드가 데이터도 가공하고 웹 화면도 그리고 있는, 맡고 있는 책임이 여러 개인 상황입니다. 즉, 단일 책임 원칙을 위반하고 있는 객체지향 관점에서도 좋지 못한 코드가 만들어진 것입니다. 이런 서블릿의 문제들을 해결하기 위해 등장한 기술이 1999년에 발표된 <strong>JSP</strong>(Java Server Pages)라는 <strong>템플릿 엔진</strong>(Template Engine)입니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token class-name">String</span> viewPath <span class="token operator">=</span> <span class="token string">"/WEB-INF/views/new-form.jsp"</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">RequestDispatcher</span> dispatcher <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>viewPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    dispatcher<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token annotation punctuation">@Override</span>
</span><span class="code-line"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 요청 데이터 받아옴</span>
</span><span class="code-line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MemberSaveServlet.service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">String</span> username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token comment">// 서비스 로직</span>
</span><span class="code-line">    <span class="token class-name">Member</span> member <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    memberRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"member"</span><span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token class-name">String</span> viewPath <span class="token operator">=</span> <span class="token string">"/WEB-INF/views/save-result.jsp"</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token class-name">RequestDispatcher</span> dispatcher <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>viewPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    dispatcher<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>JSP를 활용하게 되니 Java 코드는 HTML과 분리되어 훨씬 깔끔하고 한 눈에 알아볼 수 있게 개선되었습니다. HTML을 작성하고 화면에 그리는 역할은 JSP 파일이 담당합니다. JSP는 컴파일 과정에서 서블릿으로 변환되고 서블릿과 완전 동일한 작업을 수행합니다. 즉, JSP는 서블릿을 좀 더 보기 편하고 개발하기 쉽게 만들어주는 기술입니다.</p>
<pre><code class="language-jsp code-highlight"><span class="code-line">&#x3C;!-- 회원 정보 입력 폼 JSP -->
</span><span class="code-line">&#x3C;%@ page contentType="text/html;charset=UTF-8" language="java" %>
</span><span class="code-line">
</span><span class="code-line">&#x3C;html>
</span><span class="code-line">&#x3C;head>
</span><span class="code-line">    &#x3C;title>Title&#x3C;/title>
</span><span class="code-line">&#x3C;/head>
</span><span class="code-line">&#x3C;body>
</span><span class="code-line">&#x3C;form action="/jsp/members/save.jsp" method="post">
</span><span class="code-line">    username: &#x3C;input type="text" name="username"/>
</span><span class="code-line">    age:      &#x3C;input type="text" name="age"/>
</span><span class="code-line">    &#x3C;button type="submit">전송&#x3C;/button>
</span><span class="code-line">&#x3C;/form>
</span><span class="code-line">&#x3C;/body>
</span><span class="code-line">&#x3C;/html>
</span></code></pre>
<pre><code class="language-jsp code-highlight"><span class="code-line">&#x3C;!-- 회원 정보 저장 로직 JSP -->
</span><span class="code-line">&#x3C;%@ page import="hello.servlet.domain.member.MemberRepository" %>
</span><span class="code-line">&#x3C;%@ page import="hello.servlet.domain.member.Member" %>
</span><span class="code-line">&#x3C;%@ page contentType="text/html;charset=UTF-8" language="java" %>
</span><span class="code-line">&#x3C;%
</span><span class="code-line">    MemberRepository memberRepository = MemberRepository.getInstance();
</span><span class="code-line">
</span><span class="code-line">    System.out.println("MemberSaveServlet.service");
</span><span class="code-line">    String username = request.getParameter("username");
</span><span class="code-line">    int age = Integer.parseInt(request.getParameter("age"));
</span><span class="code-line">
</span><span class="code-line">    Member member = new Member(username, age);
</span><span class="code-line">    memberRepository.save(member);
</span><span class="code-line">%>
</span><span class="code-line">&#x3C;html>
</span><span class="code-line">&#x3C;head>
</span><span class="code-line">    &#x3C;title>Title&#x3C;/title>
</span><span class="code-line">&#x3C;/head>
</span><span class="code-line">&#x3C;body>
</span><span class="code-line">성공
</span><span class="code-line">&#x3C;ul>
</span><span class="code-line">    &#x3C;li>id=&#x3C;%=member.getId()%>&#x3C;/li>
</span><span class="code-line">    &#x3C;li>username=&#x3C;%=member.getUsername()%>&#x3C;/li>
</span><span class="code-line">    &#x3C;li>age=&#x3C;%=member.getAge()%>&#x3C;/li>
</span><span class="code-line">&#x3C;/ul>
</span><span class="code-line">&#x3C;a href="/index.html">메인&#x3C;/a>
</span><span class="code-line">&#x3C;/body>
</span><span class="code-line">&#x3C;/html>
</span></code></pre>
<p>이렇게 JSP는 HTML 안에 Java 코드를 활용할 수 있어 좀 더 HTML 작성이 편리하고 알아보기 쉽지만 여전히 문제점이 남아 있습니다. 먼저, 서버에서 수행되는 핵심 서비스 로직 코드들이 모두 JSP에 노출되어 있습니다. 또한, 웹 페이지만 그리는 것이 아니라 결국 Java 코드를 통해 데이터를 가공하는 역할까지 담당하게 되었습니다. 결국, JSP마저도 HTML을 작성하기 쉬워졌다는 장점 말고는 서블릿과 크게 다르지 않은 문제점들을 갖고 있는 것입니다.</p>
<h3 id="mvc-패턴">MVC 패턴</h3>
<p>그래도 서블릿과 JSP가 없던 시절보다는 훨씬 편하게 개발할 수 있었기 때문에, 당시 개발자들은 이 서블릿과 JSP의 문제점을 다시 한번 해결하고자 열심히 생각한 끝에, MVC 패턴이라는 개념이 등장했습니다. MVC는 Model, View, Controller의 약자로 Controller를 통해 사용자 요청을 처리하기 위한 비즈니스 로직을 수행하고, Model에 그 결과를 저장한 다음, View는 Model에서 그 결과를 꺼내와 화면을 그리는, 각자 맡은 역할이 확실하게 구분되는 획기적인 개념이 탄생했습니다.</p>
<p>그러나 초기 MVC에도 여전히 한계점은 있었습니다. View로 이동하는 코드가 항상 중복된다는 점, 서블릿의 <code>HttpServletRequest</code>, <code>HttpServletResponse</code>를 사용할 때도, 사용하지 않을 때도 있지만 항상 작성해야 한다는 점, 다양한 Controller들이 공통으로 처리할 내용도 모두 따로 작성해야 한다는 점 등, 중복되는 코드가 많고 공통 처리가 어려웠습니다. 이를 해결하기 위해 등장한 것이 공통 작업 처리를 위한 Controller 앞에서 요청을 우선 처리하는 Front Controller 패턴이었고, Front Controller 패턴은 Spring MVC에서도 <code>DispatcherServlet</code>이라는 이름으로 사용되고 있을 정도로 현재 사용되는 MVC 프레임워크의 기반이 되었습니다.</p>
<h2 id="어노테이션-기반-spring-mvc" class="heading">어노테이션 기반 Spring MVC</h2>
<p>MVC 패턴이 Java 웹 기술의 대세로 떠오르고 많은 프레임워크들이 등장하며, 길고 긴 Java 웹 기술 시장의 선두 자리를 두고 경쟁했습니다. 스트럿츠, 웹워크, 과거의 Spring MVC 등, 많은 프레임워크들이 있었지만, 결국 Java의 어노테이션을 기반으로 한 새로운 버전의 <strong>Spring MVC</strong>가 다른 프레임워크들을 역사의 뒤편으로 보내버리고 압도적인 점유율을 차지하게 되었습니다. 특히, 수많은 전처리 과정(핸들러 매핑, 핸들러 어댑터 조회, ViewResolver 호출 등)을 모두 자동으로 해결해주는 편의 기능은 엄청난 강점이었습니다. 자세한 내용은 <a href="https://blog.coderoad.kr/mvc-pattern" target="_blank" rel="noopener noreferer">Spring MVC</a>에 정리했습니다.</p>
<h2 id="spring-boot의-등장" class="heading">Spring Boot의 등장</h2>
<p>Java 웹 기술의 최강자로 우뚝 선 Spring은 이에 멈추지 않고 Spring마저 손쉽게 사용할 수 있도록 <strong>Spring Boot</strong>를 출시했습니다. Spring Boot는 과거, 개발자가 서버 컴퓨터에 직접 WAS(Web Application Server)를 설치하고, 개발한 소스 코드는 War 파일로 만들어서 WAS에 배포하는 모든 복잡한 과정을 단순화했습니다.</p>
<p>Spring Boot는 자체적으로 서버를 내장하고 있으며, 소스 코드 빌드 결과(Jar)에도 WAS를 포함시켜버렸습니다. 즉, 소스 코드를 작성하고, 빌드하는 것만으로도 WAS 서버를 통해 배포가 가능해진 것입니다. 또한, Spring의 여러 프로젝트들을 간단하게 추가하거나 제거할 수 있어 Spring Boot의 등장은 사전 설정이 어려웠던 Spring의 진입 장벽을 확 낮춘 계기가 되었습니다.</p>
<h2 id="java-view-template의-역사" class="heading">Java View Template의 역사</h2>
<p>Java 진영에서 사용하는 View Template에는 앞서 살펴본 JSP와 Freemarker, Velocity 등의 여러 기술들이 있습니다. 그러나 최근 Java 진영의 표준이라고 할 수 있는 템플릿 엔진은 <strong>Thymeleaf</strong>입니다. Thymeleaf가 최선의 선택 된 이유는 먼저, JSP는 속도도 느리고 편의 기능이 부족했습니다. 그런 와중에 Thymeleaf가 <strong>Natural Template</strong> 기술을 지원하고 Spring MVC와의 연계를 강화하면서 JSP는 요즘 거의 사용하지 않게 되었습니다.</p>
<p>만약, Spring Boot를 통해 개발하면서 View를 그려야할 상황이 생긴다면 Thymeleaf를 공부하고 적극 활용하는게 좋을 것 같습니다. 물론, 성능 자체는 Freemarker와 Velocity가 더 빠르지만 Spring에서도 Thymeleaf를 전폭적으로 지원하고 있다고 합니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[WAS와 멀티 스레딩]]></title>
    <link>https://blog.hangilog.kr/multi-thread</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/multi-thread</guid>
    <description>
    <![CDATA[동시 요청 처리를 위한 스레드 풀]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="thread" class="heading">Thread</h2>
<h2 id="was와-멀티-스레드" class="heading">WAS와 멀티 스레드</h2>
<h2 id="마치-싱글-스레드-같이" class="heading">마치 싱글 스레드 같이</h2>
<h2 id="주의해야할-점" class="heading">주의해야할 점!</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Servlet이란?]]></title>
    <link>https://blog.hangilog.kr/servlet</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/servlet</guid>
    <description>
    <![CDATA[Java와 Servlet]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="servlet" class="heading">Servlet?</h2>
<h2 id="복잡하고-낭비되는-작업으로부터의-해방" class="heading">복잡하고 낭비되는 작업으로부터의 해방</h2>
<h2 id="servlet-컨테이너" class="heading">Servlet 컨테이너</h2>
<h2 id="싱글톤-패턴" class="heading">싱글톤 패턴</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Web 서버와 WAS]]></title>
    <link>https://blog.hangilog.kr/web-was</link>
    <pubDate>2023-01-17</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/web-was</guid>
    <description>
    <![CDATA[닮은 듯 다른, 웹 시스템의 두 서버]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard" target="_blank" rel="noopener noreferer">스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="web-server-was" class="heading">Web Server? WAS?</h2>
<h2 id="web-server" class="heading">Web Server</h2>
<h2 id="web-application-server" class="heading">Web Application Server</h2>
<h2 id="둘은-왜-분리되어야-하는가" class="heading">둘은 왜 분리되어야 하는가?</h2>
<h2 id="was만-있어도-되는-경우" class="heading">WAS만 있어도 되는 경우</h2>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[좋은 객체 지향 프로그래밍]]></title>
    <link>https://blog.hangilog.kr/oop</link>
    <pubDate>2023-01-16</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/oop</guid>
    <description>
    <![CDATA[Spring과 OOP]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="객체-지향-프로그래밍" class="heading">객체 지향 프로그래밍</h2>
<p>객체 지향 프로그래밍의 특징으로는 다양한 것들이 있습니다. 클래스 개념으로 대표되는 <strong>캡슐화(Encapsulation)</strong>, 캡슐화에서 파생된 개념인 접근 제어자를 통한 <strong>정보 은닉(Information hiding)</strong>, 부모 클래스의 요소들을 자식 클래스에서 물려받을 수 있는 <strong>상속(Inheritance)</strong>, 프로그램이 유연하고 변경이 용이하게 해주는 **다형성(Polymorphism)**이 객체 지향의 특징들입니다.</p>
<p>그 중에서도 가장 핵심이라고 할 수 있는 특징은 <strong>다형성</strong>입니다. Spring은 이 다형성의 장점을 극대화하여 활용할 수 있게 도와주는 프레임워크입니다. Spring이 다형성을 어떻게 다루는지 알아보기 전에 다형성에 대해서 좀 더 알아보겠습니다.</p>
<h2 id="다형성이란" class="heading">다형성이란?</h2>
<p>**다형성(Polymorphism)**을 쉽게 이해하기 위해선 <strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분해보는 것이 가장 좋습니다. 가장 대표적인 예시는 <strong>운전자</strong>와 <strong>자동차</strong>입니다. 운전자와 자동차라는 <strong>역할</strong>은 그 자리에 어떤 구현체(예를 들어 택시 운전사와 아반떼)가 오던 운전자는 자동차를 운전할 수 있습니다. 즉, 구현체와 관계 없이 동작은 한다는 의미입니다. 물론 운전자에 프로 레이싱 선수, 자동차에 슈퍼카라는 구현체가 운전자와 자동차 역할을 담당한다면 훨씬 좋은 성능을 낼 수 있을 것입니다. 여기서 중요한 점은 운전자, 자동차라는 역할과 그 역할을 수행할 구현체는 유연하고 변경이 용이해야한다는 점입니다.</p>
<p>역할과 구현을 분리하는 것이 백엔드 프로그래밍에서 주는 장점은 다음과 같습니다.</p>
<ul>
<li>클라이언트는 대상의 역할(인터페이스)만 알고 있으면 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조를 몰라도 된다.</li>
<li>클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.</li>
<li>클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.</li>
</ul>
<p>우리가 Spring을 공부하는 중요한 이유 중 하나가 백엔드 프로그래밍 분야에서 가장 강력한 기술을 갖기 위해서임은 부정할 수 없는 사실입니다. 위와 같은 장점들을 통해 우린 클라이언트와 상관없이 독립적으로 유연하고 변경이 용이한 환경에서 개발할 수 있습니다.</p>
<h2 id="java에서의-다형성" class="heading">Java에서의 다형성</h2>
<p>Java에서 <strong>역할</strong>은 <strong>인터페이스(Interface)</strong>, <strong>구현</strong>은 인터페이스를 통해 구현한 <strong>구현체</strong>입니다. 우리는 항상 객체를 설계할 때 역할과 구현을 명확하게 분리해야 합니다. <strong>역할을 먼저</strong> 부여하고, 그 역할을 올바르게 수행하는 <strong>구현</strong> 객체를 만들어야합니다. 이 과정이 곧 다형성을 극대화하는 과정이기 때문입니다. Java의 강력한 장점이자 Spring이 탄생한 이유인 <strong>좋은 객체 지향</strong>을 위해서는 필수적입니다.</p>
<p>객체를 역할과 구현으로 구분하는 과정을 Java에서는 **오버라이딩(Overriding)**이라는 문법을 통해 진행할 수 있습니다. 오버라이딩은 Java의 기본 문법으로 프로그램 실행 시에는 오버라이딩된 메소드가 실행된다는 특징이 있습니다. 쉽게 설명하자면 **"덮어쓰기"**입니다. 이 오버라이딩을 통해 확보한 다형성으로 인터페이스를 구현한 구현체를 실행 시점에서 유연하게 변경할 수 있습니다. 물론 인터페이스 뿐만 아니라 클래스 간의 상속 관계에서도 오버라이딩이 가능하고 다형성이 확보됩니다.</p>
<p>코드로 간단하게 Java에서의 다형성을 확인해보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token comment">//역할</span>
</span><span class="code-line"><span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">void</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 1</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">SuperCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">//구현체 2</span>
</span><span class="code-line"><span class="token keyword">class</span> <span class="token class-name">NormalCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">+=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token annotation punctuation">@Override</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">breakPedal</span><span class="token punctuation">(</span><span class="token keyword">int</span> speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        speed <span class="token operator">-=</span> <span class="token number">25</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> speed<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>Car라는 인터페이스를 통해 역할을 설계했고, 해당 역할을 수행할 SuperCar와 NormalCar라는 두 구현체를 만들었습니다. 프로그래머가 나중에 어떤 구현체를 사용하냐에 따라 다른 성능에 차이가 날 것입니다. 오버라이딩을 통해 역할의 메소드를 서로 다른 성능을 가지도록 만들었으며 이를 실행 시점에 유연하게 변경이 가능합니다. 유연하게 변경하는 과정을 코드로 보면 다음과 같습니다.</p>
<pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">//NormalCar 자리에 SuperCar 구현체로 바꿔 넣기만 해도</span>
</span><span class="code-line">        <span class="token comment">//훨씬 향상된 성능의 메소드가 수행된다!</span>
</span><span class="code-line">        <span class="token comment">//이것이 유연하고 변경이 용이하다는 의미이다.</span>
</span><span class="code-line">        <span class="token class-name">Car</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NormalCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">        <span class="token keyword">int</span> currentSpeed<span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">accelPedal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        currentSpeed <span class="token operator">=</span> myCar<span class="token punctuation">.</span><span class="token function">breakPedal</span><span class="token punctuation">(</span>currentSpeed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<h2 id="다형성의-본질" class="heading">다형성의 본질</h2>
<p>다형성의 본질은 결국 **유연하게 변경 가능하다.**에 있습니다. 다형성의 본질을 더 확실하게 이해하려면 <strong>협력</strong>이라는 객체 간의 관계를 이해하는데서 시작해야합니다. 현실 세계에서 <strong>혼자 있는 객체는 없습니다</strong>. 다른 어떤 객체와 협력하지 않는 객체는 존재한다고 할 수 없습니다. <strong>나</strong>라는 객체는 <strong>거주지의 역할</strong>을 하는 <strong>집</strong>이라는 객체와 <strong>협력 관계</strong>에 있습니다. 집은 내가 안전하게 생존할 수 있도록 협력하고 나는 집이 튼튼하게 유지될 수 있도록 돈을 들여 유지보수를 합니다. 만약 이 협력 관계가 없다면 두 객체 모두 빠르게 사라져버릴 것입니다. 사람이 살면서 유지보수하지 않는 집은 집으로서 의미가 없어지고 허물어질 것이며, 집이 없는 사람은 여러 위협에 노출되어 생존에 매우 불리해집니다.</p>
<p>이 협력이라는 관계를 컴퓨터 세계로 가져온다면 <strong>클라이언트</strong>와 <strong>서버</strong>로 볼 수 있습니다. 클라이언트는 서버로 요청을 보내고 서버는 요청에 대한 응답을 클라이언트에게 보냅니다. 클라이언트 객체와 서버 객체는 협력 관계에 있습니다. 만약 두 객체 간의 협력이 없다면 클라이언트가 몇 번이고 요청을 보낸다 한들 서버는 응답을 클라이언트에게 보내지 않을 것입니다. 그렇다면 이 객체들을 클라이언트와 서버로 부르는 것은 옳지 않습니다. 각자 클라이언트와 서버라는 역할을 전혀 수행하지 못하고 있기 때문입니다. 즉, 다형성의 기초였던 역할과 구현으로의 분리는 객체 간 협력 관계가 있어야 성립합니다.</p>
<p>이 협력 관계를 유지하면서 <strong>클라이언트를 전혀 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다</strong>는 것이 다형성의 본질입니다.</p>
<h2 id="다형성의-장점과-한계" class="heading">다형성의 장점과 한계</h2>
<p>다형성의 장점에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음</li>
<li>유연하고 변경이 용이함</li>
<li>확장 가능한 설계가 가능함</li>
<li>클라이언트에 영향을 주지 않는 변경 가능함</li>
</ul>
<p>이러한 다형성의 장점을 제대로 활용하기 위해선 역할(인터페이스)를 안정적으로 잘 설계하는 것이 중요합니다. 구현체가 인터페이스에 전혀 영향을 주지 않고 변경이 가능해야하므로 설계 단계부터 완벽히 해야합니다. 만약 그렇지 못할 경우에 한계는 다음과 같습니다.</p>
<ul>
<li>역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생함</li>
<li>자동차를 비행기로 변경해야할 때..?</li>
<li>USB 인터페이스가 변경된다면..?</li>
<li>도량형이 변경되어 버린다면..?</li>
</ul>
<p>기준이 되는 역할이 바뀌어버리면 구현체도 모두 변경해야하는 치명적인 단점이 존재합니다. 따라서 다형성을 극대화하여 "좋은 객체 지향" 프로그래밍을 하기 위해서는 항상 역할(인터페이스)의 설계에 가장 많은 시간을 들여 변경을 최소화 해야합니다.</p>
<h2 id="spring과-좋은-객체-지향-프로그래밍" class="heading">Spring과 좋은 객체 지향 프로그래밍</h2>
<p>Spring에서는 위에서 말했던 다형성을 극대화하는데 집중합니다. Spring의 주요 개념인 <strong>제어의 역전(Inversion of Control)</strong>, **의존관계 주입(Dependency Injection)**은 다형성을 활용해 역활과 구현을 편리하게 다룰 수 있도록 지원합니다. 다시 말하면 다형성이 Spring의 알파이자 오메가, 전부라고 할 수 있습니다! Spring을 사용한다면 마치 레고 블럭을 조립하듯 구현체를 편리하게 변경할 수 있습니다. "좋은 객체 지향"을 목표로 만들어진만큼 프로그래머로 하여금 더 쉽게 객체 지향적 프로그래밍을 할 수 있도록 돕는 것이 Spring의 <strong>역할</strong>입니다.</p>]]>
    </content:encoded>
  </item><item>
    <title><![CDATA[Spring이란?]]></title>
    <link>https://blog.hangilog.kr/spring</link>
    <pubDate>2023-01-15</pubDate>
    <guid isPermaLink="false">https://blog.hangilog.kr/spring</guid>
    <description>
    <![CDATA[Spring 기초 정리]]>
    </description>
    <content:encoded>
      <![CDATA[<p><strong>본 문서는 인프런에서 수강할 수 있는 <a href="https://inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8" target="_blank" rel="noopener noreferer">스프링 핵심 원리 - 기본편</a>을 수강한 후, 공부한 내용을 정리한 문서입니다. 본 문서의 모든 저작권은 해당 강의의 저자이신 <a href="https://inflearn.com/users/@yh" target="_blank" rel="noopener noreferer">김영한</a> 우아한형제들 기술이사님께 있습니다.</strong></p>
<h2 id="spring" class="heading">Spring?</h2>
<p>흔히 Spring은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크 정도로만 알려져있습니다. 그러나 Spring이 탄생하게된 계기를 알게된다면 Spring의 본질, 핵심 개념을 다음과 같이 말할 수 있습니다.</p>
<blockquote>
<p>"Spring은 <strong>좋은 객체 지향</strong> 애플리케이션을 개발할 수 있게 도와주는 프레임워크이다."</p>
</blockquote>
<p>물론 Spring은 웹 애플리케이션을 만드는데 정말 많은 도움을 주는 프레임워크가 맞습니다. 그러나 Spring이 탄생하게된 계기는 "좋은 객체 지향" 개발을 위해서였습니다. 그렇다면, 도대체 왜, 어떻게 만들어졌길래 Spring이 좋은 객체 지향 애플리케이션을 개발하는데 도움이 되는지 알아보겠습니다.</p>
<h2 id="spring의-탄생" class="heading">Spring의 탄생</h2>
<p>Spring은 2002년 <strong>로드 존슨</strong>(Rod Johnson)이라는 개발자가 써낸 <strong>Expert One-on-One J2EE Design and Development</strong>이라는 책에 나온 코드를 기반으로 발전한 프레임워크입니다. 2000년대 초반, 당시 기업들은 시스템을 구현하기 위한 서버 애플리케이션으로 Java의 가장 거대한 기술 표준이었던 J2EE의 API 중 하나인 <strong>Enterprise Java Beans</strong>(EJB)를 사용했습니다. 서버와 관련된 고급 기술들을 제공하던 종합 선물 세트 같은 느낌의 API였지만 큰 문제가 있었습니다. <strong>EJB는 느리고 어려웠습니다.</strong></p>
<p>EJB에서 지원하는 기술들은 원리를 파악하기도 힘들고 테스트를 통한 개발(추후에 정리할 테스트 주도 개발)도 매우 힘들었습니다. 또한 EJB를 이용해 개발할 때는 전적으로 EJB에 의존해서 개발을 해야했기에 Java의 가장 강력한 장점이자 정체성인 <strong>객체 지향 프로그래밍이 전혀 지켜지지 못할 정도</strong>로 코드가 난해하고 확장성이 떨어졌습니다. 이런 쉽지 않은 개발 환경 때문에 <strong>POJO</strong>(Plain Old Java Object)라는 용어까지 등장하며 **순수한 Java로 돌아가자!**라는 생각이 Java 개발자들 사이에서 많아졌습니다.</p>
<p>이때 등장한 것이 앞서 언급한 로드 존슨의 저서입니다. 로드 존슨은 해당 책에서 EJB의 문제점을 지적하며 EJB 없이 순수한 Java 코드로만 더 나은 프로그램을 만들 수 있다는 것을 보여줬습니다. 또한 이 코드들을 본 유겐 휠러(Juergen Hoeller)와 얀 카로프(Yann Caroff)가 로드 존슨에게 이 소스들을 오픈 소스 프로젝트로 발전시키자는 제안을 했고 마침내 <strong>Spring</strong>이 탄생하게 되었습니다. 현재도 유겐 휠러가 Spring Framework의 리드 개발자로서 Spring을 발전시키고 있습니다. 여담으로 Spring이라는 이름은 혹독한 겨울 같았던 Java 개발 생태계를 봄처럼 따뜻하게 만들었다는 의미로 지어졌습니다.</p>
<p>2003년 6월에 처음 공개된 XML 기반의 Spring Framework 1.0을 시작으로 2023년 1월 현재 최신 버전인 Spring Framework 6.0.4와 Spring의 치명적인 단점이었던 개발 사전 설정을 도와주는 Spring Boot 3.0.1까지 약 20년의 시간 동안 Spring은 꾸준히 발전해왔습니다.</p>
<h2 id="spring-생태계" class="heading">Spring 생태계</h2>
<p>Spring 생태계에는 사용자에게 다양한 기능을 제공해주는 많은 프로젝트들이 있습니다. Spring 생태계를 이루는 대표적인 프로젝트들은 다음과 같습니다.</p>
<ul>
<li>Spring Framework</li>
<li>Spring Boot</li>
<li>Spring Data</li>
<li>Spring Session</li>
<li>Spring Security</li>
<li>Spring Batch</li>
<li>Spring Cloud</li>
<li>Spring REST Docs</li>
</ul>
<p>이외에도 많은 프로젝트들을 Spring 공식 페이지에서 확인할 수 있습니다. <a href="https://spring.io/projects" target="_blank" rel="noopener noreferer">Spring Projects</a></p>
<p>이렇게 많은 Spring 프로젝트 중에서 필수적인 두 가지는 Spring 그 자체라고 할 수 있는 <strong>Spring Framework</strong>와 모든 Spring 기술들을 편리하게 사용할 수 있도록 도와주는 <strong>Spring Boot</strong>입니다. Spring Framework 없이는 위에 적어둔 다른 기술들을 사용할 수 없습니다. 또한 본격적인 개발을 시작하기 전에 프로젝트 설정하기가 Spring의 절반이라고 할 수 있을 정도로 Spring Boot는 요즘 Spring Framework를 사용할 때 항상 함께 사용합니다.</p>
<p>가장 중요한 두 프로젝트의 특징들을 살펴보겠습니다.</p>
<ul>
<li><strong>Spring Framework</strong>
<ul>
<li>Spring의 뿌리</li>
<li>핵심 기술 - Spring DI Container, AOP, Event, etc...</li>
<li>웹 기술 - Spring MVC, Spring WebFlux</li>
<li>데이터 접근 기술 - Transaction, JDBC, ORM, XML</li>
</ul>
</li>
<li><strong>Spring Boot</strong>
<ul>
<li>단독으로 실행할 수 있는 Spring Application을 쉽게 생성</li>
<li>Tomcat과 같은 웹 서버를 내장해 별도의 웹 서버 설치 필요 없음</li>
<li>손쉬운 빌드 구성을 위한 starter 종속성 제공 (starter만 가져오면 자동으로 관련 의존관계 모두 설정)</li>
<li>스프링과 서드 파티(외부) 라이브러리 자동 구성 (주요 라이브러리의 호환성을 자동으로 검사하고 호환이 잘되는 버전을 탑재)</li>
<li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 (운영 환경에서의 모니터링 등)</li>
<li>관례에 의한 간결한 설정</li>
</ul>
</li>
</ul>
<p>위에서 살펴본대로 Spring Framework는 웹 기술 뿐만 아니라 다른 많은 기술들도 제공합니다. 또한 Spring Boot가 제공하는 많은 편의 기능들은 만약 Spring Boot가 없었다면 사용자가 직접 해야하는 작업이 얼마나 많은지 알 수 있게 해줍니다.</p>
<h2 id="spring의-핵심-개념" class="heading">Spring의 핵심 개념</h2>
<p>지금까지 Spring에 관해서 대략적으로 살펴봤습니다. 처음으로 돌아가, Spring의 본질이자 핵심 개념은 웹 애플리케이션을 쉽게 만들 수 있게 도와주는 프레임워크가 아니라고 말했습니다.</p>
<p>Spring이 탄생하게된 계기였던 로드 존슨의 저서도 Java의 EJB를 개선하고자 써내려갔고, 개발자들이 "순수한 Java"(POJO)로 더 나은 서버 프로그래밍을 위해 발전시켜온 것이 Spring이기에 웹 애플리케이션 제작에 큰 도움이 되는 것은 사실입니다. 그러나 Spring은 웹 애플리케이션에 국한되지 않고 <strong>더 빠르고, 더 쉽고, 더 안전한 Java 프로그래밍</strong>을 도와준다고 설명해왔습니다. <a href="https://spring.io/why-spring" target="_blank" rel="noopener noreferer">Why Spring?</a></p>
<p>즉, <strong>Spring의 정수는 더 나은 Java 프로그래밍, "좋은 객체 지향" 프로그래밍</strong>인 것입니다. 따라서 Spring을 완벽하게 이해하고, 활용하기 위해서는 Java의 핵심인 "객체 지향 프로그래밍"에 대한 이해가 필요합니다. Spring이 제공하는 API만 따라치기 급급한 개발자가 아닌 Spring을 통해 더 나은 애플리케이션을 만들어낼 수 있는 개발자가 되어야합니다.</p>
<p>Spring이 EJB의 과도한 의존관계를 비판하며 탄생했던 것처럼, 우리 역시 Spring이 주는 편의성에 의존하지 않아야합니다. 부가적인 기술이 아닌, 더 좋은 객체 지향 프로그래밍을 위해 Spring을 활용해야하는 것입니다.</p>]]>
    </content:encoded>
  </item>
    </channel>
  </rss>